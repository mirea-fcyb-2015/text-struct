STL

Содержание
Предисловие	7
1.	STL для начинающих	8
1.1.	Шаблоны, пространства имен и тип bool	8
1.2.	Знакомство с STL	14
1.3.	Векторы, списки и двусторонние очереди	20
1.4.	Сортировка	24
1.5.	Алгоритм find	29
1.6.	Алгоритм сору и итератор вставки	30
1.7.	Алгоритм merge	.•	32
1.8.	Типы, определенные пользователем	34
1.9.	Категории итераторов	35
1.10.	Алгоритмы replace и reverse	41
1.11.	Возвращаясь к алгоритму sort	42
1.12.	Введение в функциональные объекты	43
1.13.	Использование find	if, remove и removeif	45
1.14.	Класс auto_ptr	49
2.	Другие алгоритмы и контейнеры	52
2.1.	Алгоритм accumulate	52
2.2.	Алгоритм for_each	54
2.3.	Подсчет	55
2.4.	Функциональные объекты, определенные в STL	57
2.5.	Введение в ассоциативные контейнеры	59
2.6.	Множества и множества с дубликатами	60
2.7.	Словари и словари с дубликатами	62
2.8.	Пары и сравнения	65
2.9.	Снова словари	67
2.10.	Функции insert	72
2.11.	Удаление элементов словаря	74
2.12.	Более удобные строки	74
3.	Последовательные контейнеры	81
3.1.	Векторы и связанные с ними типы	81
3.2.	Функции capacity и reserve	85
3.3.	Обзор функций-членов класса vector	88
3.4.	Двусторонние очереди	92
3.5.	Списки	94
3.6.	Векторы векторов	101
3.7.	Как избавиться от явного выделения памяти	103
4.	Ассоциативные контейнеры	107
4.1.	Введение	107
4.2.	Функции-члены множеств	111
4.3.	Объединение и пересечение множеств	117
4.4.	Отличия множеств с дубликатами от просто множеств	119
4.5.	Словари	120
4.6.	Словари с дубликатами	124
4.7.	Сводный указатель	127
5.	Адаптеры контейнеров	131
5.1.	Стеки	131
5.2.	Очереди	134
5.3.	Очереди с приоритетами	135
6.	Функциональные объекты и адаптеры	138
6.2.   Функциональные объекты	138
6.2.	Унарные предикаты и привязки	142
6.3.	Отрицатели	143
6.4.	Два полезных базовых класса STL	145
6.5.	Функциональные объекты и алгоритм transform	147
6.6.	Адаптеры итераторов	150
7.	Обобщенные алгоритмы	155
7.1.	Немодифицирующие последовательные алгоритмы	156
7.1.1.	Алгоритмы find, count, for_each, find_first_of и find_end	156
7.1.2.	Алгоритм adjacent_find	158
7.1.3.	Отличие	160
7.1.4.	Сравнение на равенство	161
7.1.5.	Поиск подпоследовательности	162
7.2.	Модифицирующие последовательные алгоритмы	163
7.2.1.	Преобразовать	163
7.2.2.	Копировать	164
7.2.3.	Переместить по кругу	166
7.2.4.	Обменять	168
7.2.5.	Заменить	170
7.2.6.	Удалить	172
7.2.7.	Заполнить	172
7.2.8.	Породить	173
7.2.9.	Убрать повторы	175
7.2.10.	Расположить в обратном порядке	178
7.2.11.	Перетасовать	178
7.2.12.	Разделить	180
7.3.	Алгоритмы, связанные с сортировкой	181
7.3.1.	«Меньше» и другие операции сравнения	182
7.3.2.	Сортировка	182
7.3.3.	Стабильная сортировка	182
7.3.4.	Частичная сортировка	184
7.3.5.	N-й элемент	186
7.3.6.	Двоичный поиск	187
7.3.7.	Объединение	189
7.3.8.	Операции над множествами для сортированных контейнеров	191
7.3.9.	Операции над пирамидами	194
7.3.10.	Минимум и максимум	197
7.3.11.	Лексикографическое сравнение	199
7.3.12.	Генераторы перестановок	200
7.4.	Обобщенные численные алгоритмы	202
7.4.1.	Накопление	202
7.4.2.	Скалярное произведение	202
7.4.3.	Частичная сумма	204
7.4.4.	Разность между смежными элементами	205
7.5.	Прикладная программа: метод наименьших квадратов	206
8.	Прикладная программа: очень большие числа	211
8.1.	Введение	211
8.2.	Реализация класса large	215
8.3.	Вычисление числа к	229
Библиография	235
Указатель идентификаторов и английских названий	236
Предметный указатель	238
End 

STL для программистов на С++

Леей Аммерааль
Высшая школа Утрехта, Нидерланды
 
STL для программистов на С++

Леей Аммерааль
Высшая школа Утрехта, Нидерланды
 
STL для программистов на С++

Леей Аммерааль
Высшая школа Утрехта, Нидерланды
 
 
Леен Аммерааль
STL для программистов на С++. Пер. с англ. / Леен Аммерааль - М.: ДМК, 1999 - 240 с, ил.
ISBN 5-89818-027-3
Книга Леена Аммерааля посвящена стандартной библиотеке шаблонов (STL) - мощному инстру¬менту повышения эффективности труда программистов, пишущих на С++.
Умелое использование STL позволяет повысить надежность, переносимость и универсальность про¬грамм, а также снизить расходы на их разработку. В книге описана стандартизованная версия STL. Дается введение в предмет, которое позволяет быстро освоить библиотеку шаблонов. Приведен ис¬черпывающий справочный материал, в том числе по новому классу STL, string. Изложение сопровож¬дается многочисленными примерами небольших, но законченных программ, иллюстрирующих клю¬чевые понятия STL. Особое внимание уделено разъяснению сложных понятий библиотеки шаблонов, например, функциональных объектов и адаптеров функций. Для удобства читателей все приведенные в книге программные примеры доступны также в электронном виде, в частности, на Web-узле изда¬тельства «ДМК» (www.dmk.ru).
Книга предназначена как для профессиональных программистов и тех, кто углубленно изучает С++, так и для тех, кто только начинает осваивать этот язык программирования, без преувеличения самый популярный в мире.
ISBN 5-89818-027-3

ISBN 0-471-97181-2	© John Wiley & Sons Ltd, 1997
Baffins Lane, Chichester, West Sussex P019 1UD, England © ДМК, 1999
All Rights Reserved. Authorized translation from the English language edition published by John Wiley & Sons, Inc.
Все права сохранены. Никакая часть настоящего издания не может быть воспроизведена, сохранена в воспроизво-дящей системе либо перенесена в какой бы то ни было форме, с использованием электронных, механических, фото-копировальных, записывающих, сканирующих или любых других приспособлений без предварительного письмен¬ного разрешения со стороны издателя.
В соответствии с Законом об авторском праве, проектах и патентах от 1988 г. Леен Аммерааль заявлен обладателем права считаться автором данной работы.
Материал, изложенный в данной книге, многократно проверен. Но, поскольку вероятность наличия технических и просто человеческих ошибок все равно существует, издательство не может гарантировать абсолютную точность и правильность приводимых сведений. В связи с этим издательство не несет ответственности за возможные ошибки, связанные с использованием книги.
 
Предисловие
Когда несколько лет назад в языке С++ появились шаблоны, лишь немно¬гие из программистов на С++ могли предположить, какое влияние это окажет на стандарт библиотеки языка. Стандартная библиотека шаблонов (Standard Template Library) была первоначально разработана сотрудника¬ми Hewlett-Packard А.А. Степановым и М. Ли совместно с Д.Р. Муссером из Ренсселэровского политехнического института. После внесения незна¬чительных поправок Комитет по стандартизации языка С++ принял STL, сделав ее существенной составной частью стандартной библиотеки.
Использование STL дает возможность создавать более надежные, более переносимые и более универсальные программы, а также сократить рас¬ходы на их разработку. Это значит, что ни один профессиональный про¬граммист не может себе позволить пройти мимо этой библиотеки. Я напи¬сал книгу для таких программистов, а также для людей, в достаточной мере знакомых с С++.
В книге описана стандартная версия STL, а не изначальный вариант, разработанный в Hewlett-Packard. Вы можете загрузить примеры, приводимые в этой книге, из сети Internet не только для того, чтобы сэкономить на на¬бивании кода, но и для упрощения проблем с переносимостью: некоторые из электронных версий примеров сделаны более переносимыми путем до¬бавления условной компиляции, чтобы обойти нестандартное поведение версий STL, поставляемых с компиляторами Borland и Microsoft. Все при¬меры доступны в виде одного файла, stlcpp.zip, на моем Web-сайте по адресу:
http://www.econ.hvu.nl/~ameraal/ или напрямую с одного из следующих ftp-сайтов:
ftp://ftp.expa.fnt.hvu.nl/pub/ameraal
ftp://pitel-lnx.ibk.fnt.hvu.nl/pub/ameraal
Я благодарен Гэйнору Редверс-Маттону из издательства Wiley и Фрэн¬сису Глассброу из Ассоциации пользователей С и С++, которые убедили меня написать эту книгу и дали полезные рекомендации по ее содержанию.

Леен Аммерааль
 


STL для начинающих
1.1. Шаблоны, пространства имен и тип bool
Как легко догадаться из названия, стандартная библиотека шаблонов (STL) основывается на относительно новом понятии шаблона. Поэтому мы начнем с краткого обсуждения этого предмета.
Шаблонные функции
Предположим, что для некоторого положительного числа .г нам приходит¬ся часто вычислять значение выражения
2 * х +  (х * х + 1)  /  (2 * х)
где х может быть типа double или int. В последнем случае оператор деления / обозначает целочисленное деление, дающее целый результат. Например, если х имеет тип double и равен 5.0, тогда значение приведенного выраже¬ния составляет 12.6, но если х имеет тип int и равен 5, то значение выраже¬ния будет 12. Вместо того чтобы писать две функции, такие как
double f(double х) {   double х2 = 2 * х;
return х2 +  (х * х + 1)/х2;
}
 
int f(int x)
{   int x2 = 2 * x;
return x2 +  (x * x + l)/x2;
}
нам достаточно создать один шаблон, как показано в следующем примере, который представляет собой законченную программу:
// ftempi.срр: Шаблонная функция. #include <iostream.h>
template <class T> T f(Т х)
{   Т х2 = 2 * х;
return х2 +  (х * х + 1)/х2;
}
int main()
{   cout « f(5.0) << endl « f(5) « endl; return 0;
}
Программа выведет
12.6 12
В этом шаблоне Т - тип, задаваемый аргументом при вызове/. При вызо¬ве /(5.0) Т будет обозначать double (это тип константы 5.0), так что, к примеру, в выражении (х * х + 1)/х2 выполнится деление с плавающей точкой. Напротив, при исполнении вызова/(5) Т будет обозначать тип int, что приведет к целочисленному делению.
При разборе программы ftem.pl.cpp компилятор создает две различные функции, весьма похожие на функции f(double) и f(int), с которых мы начи¬нали наш пример. Следовательно, компилятор должен одновременно «ви¬деть» как определения, так и вызовы шаблонов. Это делает шаблоны плохи¬ми кандидатами на раздельную компиляцию; вместо этого мы, как правило, помещаем шаблоны в файлы заголовка. Когда мы используем файлы заго¬ловка, написанные кем-то другим, мы не видим определения шаблонов и вызываем их как обычные функции, что показано на примере вызовов /(5.0) и/(5) в нашей программе. Поэтому, применяя шаблоны функций STL, мы можем и не знать, что вызываем функции, созданные из шаблонов.
Что в имени?
Шаблон, который, подобно рассмотренному выше, начинается со слова template, а заканчивается закрывающей фигурной скобкой, следующей за оператором return, создателем языка Бьерном Страуструпом был изна¬чально назван шаблоном функции. Данный термин отражает, что мы име¬ем дело с определенным видом шаблона, отличающимся от шаблонов классов, о которых речь пойдет ниже. Сегодня многие авторы используют вместо этого выражение шаблонная функция (template funcion), потому что шаблоны указанного типа очень похожи на обычные функции. В этой кни¬ге мы также будем использовать термин шаблонная функция, а иногда даже просто функция для обозначения этих шаблонов. То же относится и к об¬суждаемому ниже понятию, которое изначально получило наименование шаблон класса, а в книге зовется шаблонным классом (template class) или просто классом.
Шаблонные классы
Мы можем использовать тип как параметр (Гв предыдущем примере) для классов почти так же, как и для функций. Предположим, нам нужен класс Pair, чтобы хранить пары значений. Иногда оба значения принадлежат к ти¬пу double, иногда к типу int. Тогда вместо двух новых классов, к примеру,
class PairDouble { public:
PairDouble(double xl, double yl): x(xl), y(yl)   {} void showQ(); private:
double x, y;
};
void PairDouble::showQ() {   cout << x/y << endl; }
после чего следует аналогичный фрагмент с классом Pairlnt, нам достаточ¬но написать один шаблонный класс:
II cltempl.cpp: Шаблонный класс. #include <iostream.h>
template <class T> class Pair { public:
Pair(T xl, Tyl): x(xl), y(yl){} void showQ(); private: T x, y;
};
template <class T>
void Pair<T>::showQ() {   cout << x/y << endl; }
int main()
{    Pair<double> a(37.0, 5.0); Pair<int> u(37 , 5); a.showQ(); u.showQ(); return 0;
}
Способ, каким функции-члены шаблонного класса, в этом примере showQ, определены вне класса, может с первого взгляда показаться сложным. Но на самом деле эта конструкция весьма логична: имя любой функции-чле¬на, когда эта функция определяется вне класса, должно быть предварено выражением
type::
и вполне резонно, что вместо type в нашем случае мы пишем Pair<T>. Кро¬ме того, как пользователи STL мы можем не беспокоиться об определени¬ях, так как шаблонные классы STL доступны в виде файлов заголовков, которые можно использовать, не вдаваясь в подробности их программи¬рования. Единственный аспект применения шаблонов, который мы уви¬дим в наших программах, это обозначение фактического типа с помощью конструкции наподобие Pair<double>.
Пространства имен
Существует другой новый элемент языка, который мы обязаны принять во внимание. Если программа состоит из многих файлов, мы должны при¬нять меры во избежание конфликта имен. Концепция пространства имен может быть хорошим способом решения этой задачи. В нижеприведенной программе определены две глобальные переменные г, которые не находят¬ся в конфликте, потому что существуют в различных пространствах имен:
// namespac.cpp: Концепция пространства имен, tinclude <iostream.h>
namespace	А
{ int i =	10;
}
namespace	В
{ int i =	20;
}
 
void fA()
{   using namespace A; cout « "In fA:
A::i <<""<< В
 


: l <<
 


<< i << endl;
 

 
void fB()
{   using namespace B; cout « "In fB:
A: :i « "  " « В
 


: l <<
 


<< i << endl;
 

int main()
{    fA();   fB();
cout << "In main:   " << A::i « "  " << B::i << endl;
// cout << i << endl; Здесь это недопустимо.
using A::i;
cout << i << endl; //А это разрешено, return 0;
}
Эта программа на выходе даст:
In fA:     10 20 10 In fB:     10 20 20 In main: 10 20 10
Благодаря идентификаторам А и В мы впоследствии можем ссылаться на эти пространства имен. Для пространства имен А можем написать либо что-нибудь вроде
А: :   ...
либо одно из выражений:
using namespace А; using А::i;
Только после использования одного из двух последних выражений неквалифицированный идентификатор i будет относиться к переменной i (со значением 10), определенной в пространстве имен А. Результат работы программы наглядно демонстрирует это.
Тип booh синоним для int или встроенный тип?
Тип bool и два его возможных значения, true и false, определены в файлах заголовка первоначальной версии STL с помощью приема, который часто можно встретить в программах на С:
#define bool int #define true 1 #define false 0
Однако в соответствии с проектом стандарта С++ bool является встроен¬ным типом, что подразумевает: следующая программа, вообще не исполь¬зующая файлы заголовков, должна компилироваться без ошибок:
int main() {   bool b; return 0;
}
Некоторые старые компиляторы отвергнут эту программу, поскольку они не распознают bool в качестве встроенного типа.
В соответствии с проектом стандарта С++ типы bool и int не являются идентичными, что проиллюстрируем следующими (типичными) выход¬ными результатами программы boolint.cpp:
sizeof(bool) = 1 sizeof(int) = 4
With В defined as bool B[100], we have sizeof(B) = 100
Программа, которая выводит такие результаты, приведена ниже:
// boolint.cpp: Типы bool и int различны. #include <iostream.h>
int main()
{   cout << "sizeof(bool) = " << sizeof(bool) << endl; cout << "sizeof(int) = " << sizeof(int) << endl; bool B[100];
cout << "With В defined as bool B[100], we have\n"; cout << "sizeof(B)  = " << sizeof(B) << endl; return 0;
}
Очевидно, каждый элемент массива значений типа bool занимает один байт, тогда как при размере машинного слова в 32 бита он занимал бы 4 байта, если бы типы bool и int не различались. Можно представить еще более экономную реализацию, когда восемь булевских значений размеща¬ются в одном байте, но это замедлило бы операции с этими элементами.
В следующем разделе мы обсудим дополнительные различия между версиями С++ (а также STL).
1.2. Знакомство с STL
Установив современный компилятор С++, мы можем сразу начать исполь¬зовать STL, например откомпилировать и запустить следующую програм¬му. Эта программа читает с клавиатуры переменное количество ненулевых целых чисел и печатает их в том же порядке после того, как введен 0. Дан¬ная задача может показаться слишком простой, но на самом деле это не так, потому что нет ограничения на количество вводимых чисел:
// readwr.cpp: Чтение и вывод переменного количества
//	ненулевых целых (ввод завершается нулем).
#include <iostream>
#include <vector>
using namespace std;
int main() {   vector<int> v; int x;
cout << "Enter positive integers, followed by 0:\n"; while (cin >> x, x != 0)
v.push_back(x); vector<int>::iterator i; for (i=v.begin(); i != v.end(); ++i)
cout << *i << " "; cout << endl; return 0;
}
Мы можем использовать шаблон vector как массив переменной длины. Сначала эта длина равна нулю. Поскольку мы хотим, чтобы элементы век¬тора были целого типа, то всегда пишем vector<int>, чтобы обозначить класс, с которым работаем. Выражение
v.push_back(x);
добавляет значение х типа int в конец вектора v.
Оператор for в этой программе используется аналогично тому, как это сделано в следующем фрагменте кода, который выводит массив а вместо вектора v:
int a[N],  *р;
for (р=а; р != a+N; р++) cout << *р << "  ";
Напомним, что выражения &<з[0] и а эквивалентны, равно как и выраже¬ния &а[Щ и а + N. Начав с первого элемента, мы проходим массив, пока
 
не оказываемся за его концом: хотя указываем на адрес a[N], последний элемент массива - a[N-l]. Это может выглядеть опасным, но поскольку мы не используем значение a[N], а только его адрес, такой стиль абсолют¬но безопасен. Переменная i, определенная как
vector<int>::iterator i;
называется итератором. Она используется таким же образом, как указа¬тель в вышеприведенном фрагменте. Значение итератора для первого эле¬мента вектора v обозначается выражением v.beginQ, а значение итератора для элемента, следующего за конечным, обозначается как v.endQ. Значение элемента вектора, на который ссылается допустимый итератор г, обознача¬ется выражением * г, как если бы i был указателем. Для этого итератора г определены также операторы ++ и —, как в префиксном, так и в суффиксном варианте. Это объясняет смысл следующего цикла for.
for (i=v.begin(); i != v.endf); ++i) cout << *i « " ";
В приведенном цикле лучше не заменять != на <. Хотя в примере это сра¬ботает, но оператор < неприменим к некоторым другим типам, отличными от vector<int> (см. раздел 1.9), в то время как оператор != работает во всех случаях.
Обычно в математике запись [а, Ь] используется для обозначения закры¬того интервала а < х < Ь, а запись (а, Ь) - для открытого интервала а<х<Ь. Это объясняет запись
[а, Ь)
для интервала
а < х < Ъ
Подобным же образом мы иногда будем писать [ia, ib)
для диапазона значений итератора в следующем фрагменте кода: vector<int>::iterator i, ia, ib;
for (i = ia; i != ib; ++i)  ... Ошибка выделения памяти
Поскольку все числа, которые читает программа readwr.cpp, хранятся в динамически распределяемой памяти, используемая нами компьютерная система наложит ограничение на размер ввода. Вопрос усложняется из-за реализации некоторыми операционными системами виртуальной памяти, что предполагает использование жесткого диска для расширения опера¬тивной памяти. Хотя этот подход предоставляет в наше распоряжение ог¬ромное количество памяти (за счет уменьшения скорости вычислений), ясно, что рано или поздно фрагмент кода
vector<int> v;
for  (;;) v.push_back(0);
приведет к ошибке выделения памяти. То же самое наблюдается при ис¬полнении
int *р;
for (;;) р = new int;
В последнем фрагменте обычная проверка if (р != NULL) не будет рабо¬тать с современными компиляторами С++. Согласно проекту стандарта С++ ошибка выделения памяти будет приводить не к возвращению значе¬ния NULL, а к «выбросу исключения». Несмотря на то что ошибка рас¬пределения памяти относится к С++, а не к STL, это была бы достаточно важная тема для обсуждения в настоящей книге, если бы существовало простое, переносимое решение, совместимое с большинством популярных компиляторов и соответствующее принятому стандарту С++. Поскольку различные компиляторы требуют разных подходов, а стандарт языка на¬ходится в стадии проекта, мы опустим обсуждение этой темы в данной книге, которая все-таки посвящена STL, а не С++.
Возвращаясь назад
Рекомендация использовать != (или ==) для сравнения значений итераторов вместо <, <=, >, >= усложняет прохождение элементов вектора в обратном порядке с помощью только что обсужденных средств. В программе readwr.cpp мы могли бы добиться этого, заменив цикл for на следующий фрагмент:
i = v.end();
if  (i != v.begin())
do cout << *--i << " "; while (i != v.beginO);
В начале приведенного решения требуется дополнительное сравнение для определения пустого вектора, в случае если число 0 было единственным числом, введенным пользователем программы. Однако существует более простой путь прохождения вектора (и других структур данных) задом на¬перед. Он требует использования двух других функций-членов, rbegin и rend, вместе с другим типом итератора, reverse_iterator, как демонстриру¬ет следующий фрагмент: vector<int>::reverse_iterator i; for (i=v.rbegin; i != v.rend(); ++i) cout << * i << "  " ;
Заметьте, что в этом случае мы пишем ++z вместо —г.
Новые элементы языка и проблемы переносимости
В программе readwr.cpp способ указания файлов заголовка в строках ^include может показаться вам непривычным (и отличающимся от того, как мы писали в разделе 1.1). Раньше мы всегда использовали iostream.h и vector.h вместо просто iostream и vector. Эти короткие формы приняты в последней версии С++, которая называется проектом стандарта С++. Во многих случаях можно использовать любой из вариантов, например, ука¬зывая как <iostream.h>, так и <iostream>. Далее мы везде будем пользоваться последним, более новым вариантом.
Интересно, что, хотя мы пишем <iostream>, на самом деле файл может называться iostream.h (например, для компилятора Borland С++ 5.2). В свя¬зи с этим возникают сомнения, правомерно ли называть iostream файлом за¬головка. С этого раздела начнем использовать термин заголовок, а не файл заголовка. В соответствии с принятым употреблением мы будем применять этот короткий термин не только к именам, заключенным в угло¬вые скобки, как <iostream>, но и к самим файлам, таким как iostreamh.
Другой новый аспект языка заставит нас добавлять конструкцию using namespace std в начале программы. Если опустим эту строчку, может по¬явиться сообщение об ошибке типа «Не определен символ 'vector'». Преиму¬щества использования концепции пространства имен, как мы обсуждали в разделе 1.1, заключаются в том, что имена наподобие vector не «загрязня¬ют глобальное пространство имен». Иными словами, мы вправе использо¬вать слово vector на глобальном уровне для любой другой цели. Если мы поступим так, то при необходимости разрешить неоднозначность напишем ¦..vector для глобальной версии и stdv.vector - для версии STL.
Два популярных компилятора С++
Как Visual С++ 5.0 (VC5), так и Borland С++ 5.2 (ВС5) поддерживают пространства имен. STL полностью интегрирована в их библиотеки, так что не требуется никаких специальных действий, чтобы начать ее исполь¬зование. Многие используют эти компиляторы из интегрированной сре¬ды разработки, с помощью которой возможно редактировать программ¬ные файлы, компилировать их и т. д. Вместо этого мы будем компилировать и компоновать программы из командной строки с помо¬щью команды с/ или Ъсс32.
 
STL для начинающих
 
Для этого в командную строку PATH-файла autoexec.bat должен быть вставлен путь
с:\progra~l\devstudio\vc\bin или
с:\progra~l\borland\cbuilder\bin
Для работы с VC5 необходимо также ввести команду vcvars32
чтобы указать компилятору, где следует искать включаемые файлы и библиотеки.
Версии STL
Изначальная версия STL от компании Hewlett-Packard составила основу значительной части проекта стандарта С++. Эта версия доступна в сети Internet и может быть бесплатно использована и модифицирована при соблюдении не¬строгих условий, указанных в следующем уведомлении о копирайте:
 
Версия STL, включенная в проект стандарта С++, отличается от изна¬чальной (которую мы будем называть HP STL) количеством и именами заголовков. Вместо 48 файлов в HP STL в проекте стандарта С++ ис¬пользуется только 13 (см. табл.).
 
Как VC5, так и BC5 соответствуют проекту стандарта С++ по названиям заголовков. Если у вас более старый компилятор (вместе с HP STL), веро¬ятно, он потребует, чтобы имена заголовков содержали в себе ./г, так что вам придется писать <vector.h> и <iostream.h> вместо <vector> и <iostream>. В этом случае будет также необходимо убрать операторы using, вроде того, что предшествует функции main в программе readwr.cpp.
Стандартная библиотека шаблонов фирмы SGI, адаптированная для VC++ 5.0
Хотя VC5 очень хороший компилятор, в версии STL, которая с ним по¬ставляется, имеются некоторые проблемы. Поскольку они могут быть раз¬решены в следующем релизе этого компилятора, не будем их подробно об¬суждать. В то же время пользователи Visual С++ могут выбрать версию STL, написанную проектировщиком STL Александром Степановым для фирмы Silicon Graphics (SGI) и адаптированную для VC5 Уэйном Учида (Wayne Ouchida). Следующая Web-страничка содержит подробную ин¬формацию по этому вопросу:
http://www.sirius.com/~ouchida/
Версия SGI STL часто упоминается в связи с ее высоким качеством, и эта адаптация поможет программистам, работающим с Visual С++, вос¬пользоваться этим преимуществом.
В тех случаях, где современные версии STL отличаются друг от друга, за основу для примеров в этой книге берется проект стандарта С++ (на декабрь
1996 года). Если у вас возникнут проблемы с переносимостью примеров для компиляторов Microsoft или Borland, попробуйте использовать электрон¬ную версию этих программ, доступную в виде файла std.cpp.zip. Некоторые из них сделаны более переносимыми с помощью условной компиляции.
Кроме того, существуют также коммерческие версии STL, которые мы не будем здесь обсуждать. Поскольку STL состоит только из файлов заго¬ловка, замена одной версии на другую является легко решаемой задачей.
1.3. Векторы, списки и двусторонние очереди
В программе read.wr.cpp три раза встречается слово vector.
#include <vector>
vector<int> v;
vector<int>::iterator i;
Применение концепции вектора обеспечивает выделение непрерывной па¬мяти, для чего программисты на С обычно пользуются функциями malloc, realloc и free. В качестве альтернативы можно употребить связный список, как рекомендуется в книгах по структурам данных. С помощью STL мы мо¬жем использовать (двойные) связные списки, не программируя их самосто¬ятельно. Все, что нам требуется для программы readwr.cpp- заменить всюду слово vector на list, как показано в следующей программе:
// readwrl.срр:Чтение и вывод переменного количества
//	ненулевых целых (ввод завершается нулем).
//	Использует список.
#include <iostream>
#include <list>
using namespace std;
int main() {   list<int> v; int x;
cout << "Enter positive integers, followed by 0:\n"; while  (cin >> x, x != 0)
v.push_back(x); list<int>::iterator i; for (i=v.begin(); i != v.end(); ++i)
cout « *i « "  " ; cout << endl; return 0;
}
Программа также будет правильно выполняться, если заменить слово list на deque (двусторонняя очередь), что дает нам третье решение.
 
Векторы, списки и двусторонние очереди
 
Пользователь не заметит никаких различий в поведении этих трех вер¬сий программы, но внутреннее представление данных будет различать¬ся. Это скажется на наборе доступных операций, которые смогут вы¬полняться эффективно.
 
Для данного типа Т типы vector<T>, deque<T> и list<T> называются последовательными контейнерами.

Vector<T>
Вставка и удаление в любом месте. Нет произвольного доступа.

Рисунок 1.1. Свойства трех последовательных контейнеров
Как показано на рисунке 1.1, мы можем эффективно вставлять и удалять элементы только в конце вектора, в начале и конце двусторонней очереди и в любом месте списка. Хотя вектор накладывает сильные ограничения на вставку и удаление, он имеет преимущество в том, что предоставляет произвольный доступ к своим элементам. Некоторые дальнейшие приме¬ры прояснят эти различия. Для полноты изложения необходимо отметить, что существует четвертая разновидность последовательного контейнера, обычный массив, который описывается как
Т a [N] ;
для массива с элементами типа Т. Далее продемонстрируем, что средства STL предоставляют возможность успешно отсортировать массив. Други¬ми словами, STL может быть полезна даже в программах, которые исполь¬зуют обычные массивы, а не типичные контейнеры STL, о чем рассказано в следующем разделе.
Как показано в приведенной ниже таблице, векторы, двусторонние оче¬реди и списки поддерживают различные наборы операций.
 
Операция	Функция	vector	deque	list
Вставить в конце	push_back			
Удалить в конце	popback			
Вставить в начале	push_front	-		
Удалить в начале	popjront	-		
Вставить в любом месте	insert			
Удалить в любом месте	erase			
Отсортировать (см. раздел 1.4)	sort (алгоритм)			-
Галочка в скобках (S) означает, что функции insert и erase, хотя определе¬ны для векторов и двусторонних очередей, применительно к этим контей¬нерам выполняются гораздо медленнее, чем для списков. Говорят, что их выполнение занимает линейное время для векторов и двусторонних очере¬дей, а это означает: время их выполнения пропорционально длине после¬довательности, хранящейся в контейнере. В противоположность этому все операции, помеченные галочкой S (без скобок), выполняются за постоян¬ное время, то есть время, необходимое для их выполнения, не зависит от длины последовательности.
До сих пор мы видели только, как используется функция pushback. Следующая программа показывает, как использовать все функции для вставки и удаления, перечисленные в вышеприведенной таблице (pushback, popjback, push _front, pop _front, insert и erase).
II insdel.cpp: Вставка и удаление элементов из списка, iinclude <iostream> iinclude <list> using namespace std;
void showlist(const char *str, const list<int> &L) {   list<int>::const_iterator i;
cout « str « endl « "    " ;
for (i=L.begin(); i != L.endf); ++i) cout « *i « " ";
cout « endl;
}
int main() {   list<int> L; int x;
cout « "Enter positive integers, followed by 0:\n"; while (cin » x, x != 0)
L.push_back(x); showlist("Initial list:", L); L.push_front(123);
showlist("After inserting 123 at the beginning:", L); list<int>::iterator i = L.begin(); L.insert(++i, 456); showlist(
"After inserting 456 at the second position:", L); i = L.endO ; L.insert(--i, 999); showlist(
"After inserting 999 just before the end:", L); i = L.beginO; x = *i; L.pop_front();
cout « "Deleted at the beginning: " « x « endl; showlist("After this deletion:", L); i = L.endO ; x = L.pop_back();
cout « "Deleted at the end:  " « x « endl; showlist("After this deletion:", L); i = L.begin));
x = *++i; cout « "To be deleted: " « x « endl; L.erase(i);
showlist("After this deletion (of second element):",
L) ; return 0;
}
Функции для вставки и удаления здесь применяются к списку, посколь¬ку это единственный контейнерный тип, для которого все эти функции определены и выполняются эффективно, как указывает вышеприведенная таблица. В следующем примере выполнения программы (и далее в этой книге) данные, вводимые с клавиатуры, подчеркнуты:
Enter positive integers, followed by 0: 10 20 30     0 Initial list: 10 20 30
After inserting 123 at the beginning:
123 10 20 30 After inserting 456 at the second position:
123 456 10 20 30 After inserting 999 just before the end:
123 456 10 20 999 30 Deleted at the beginning: 123 After this deletion:
456 10 20 999 30 Deleted at the end: 30 After this deletion:
456 10 20 999
То be deleted: 10
After this deletion (of second element): 456 20 999
Употребление const в первых двух строчках функции showlist требует разъяснения:
void showlist(const char *str, const list<int> &L) {   list<int>::const_iterator i;
Добавление приставки const к параметрам типа указатель или ссылка, как это сделано выше, является хорошей практикой, если такие параметры не используются для модификации объектов, на которые они указывают. По¬скольку функция showlist не модифицирует ни строку str, ни список L, от¬сюда происходят два употребления слова const на первой из этих двух стро¬чек. Из-за этого на второй строчке мы должны объявить переменную i типа const iterator, чтобы иметь возможность использовать ее вместе с L. Это похоже на применение модификатора const к указателям: если хотим при¬своить вышеобъявленный параметр str указателю/), мы сможем сделать это, только использовав const при объявлении этого указателя:
const char *р;      // const необходим, поскольку str
р = str;	// типа const char *
Стирание подпоследовательности
Если [il, г'2) является действительным диапазоном для вектора v, мы мо¬жем стереть подпоследовательность в v, заданную этим диапазоном, сле¬дующим образом:
v.erase(il, i2) ;
То же самое относится и к остальным контейнерам.
1.4. Сортировка
Ниже следует расширение программы readwr.cpp, рассмотренной в начале раздела 1.2. Эта программа сортирует вектор v, то есть располагает элемен¬ты v в восходящем порядке:
// sortl.cpp: Сортировка вектора. #include <iostream> #include <vector> #include <algorithm> using namespace std;
int main()
{   vector<int> v;
 
int х;
cout « "Enter positive integers, followed by 0:\n";
while  (cin » x, x != 0) v.push_back(x);
sort (v. begin () , v.endO);
cout « "After sorting:  \n";
vector<int>::iterator i;
for (i=v.begin)) ; i != v.endO; + + i)
cout << *i << "  "; cout « endl; return 0;
}
Сама сортировка выполняется выражением sort (v. begin () , v.endO);
Мы используем два значения итераторов в качестве аргументов: первый, v.beginQ, ссылается на начальный элемент вектора и второй, v.end(), ссы¬лается на следующий за последним элемент вектора. Вывод этой програм¬мы содержит введенные пользователем целые числа, отсортированные в восходящем порядке.
Вышеприведенный вызов функции sort отличается от вызовов push_back, insert, begin и др. Поскольку мы пишем не v.sort(...), а просто sort(...), видно, что sort является не функцией-членом класса vector, а шаб¬лонной функцией, которая не является членом класса. Технический термин, обозначающий такую шаблонную функцию в STL,- обобщенный (generic) алгоритм, или просто алгоритм. Строчка
#include <algorithm>
необходима, поскольку мы используем алгоритм sort. Для некоторых реа¬лизаций STL компилятор не выдает сообщения об ошибках, если мы опу¬стим эту строчку, поскольку заголовок algorithm включается неявным об¬разом с помощью строки
#include <vector>
Так как было бы неразумно рассчитывать на это, мы используем обе строчки Uinclude. Напротив, в следующей программе, которая сортирует обычный мас¬сив вместо вектора, достаточно включить только заголовок algorithm:
II sort2.cpp: Сортировка массива. #include <iostream> #include <algorithm> using namespace std;
int main()
{   int а[10], х, n = 0,  *р;
cout « "Enter at most 10 positive integers,  "
"followed by 0:\n"; while (cin » x, x != 0 && n < 10) a[n++]  = x; sort(a, a+n);
cout « "After sorting:  \n";
for (p=a; p != a+n; p++) cout « *p « "  ";
cout « endl;
return 0;
}
Важно заметить сходство между вызовами
sort (v. begin () , v.endO);
в программе sortl.cpp и
sort(a, a+n);
в программе sort2.cpp. В обоих случаях первый аргумент ссылается на пер¬вый элемент последовательного контейнера, а второй - на элемент, следую¬щий за последним, точнее на позицию, находящуюся непосредственно пос¬ле последнего элемента. Это общий принцип, справедливый не только для алгоритма sort, но и для большинства алгоритмов STL. Мы можем приме¬нить этот принцип также и к заданной подпоследовательности. Например, мы можем отсортировать только элементы а[3], а[4], а[5] и а[6], написав
sort(a+3, а+7); или, что эквивалентно,
sort[&a[3], &а[7]); как показывает рисунок 1.2.
Может показаться более логичным передавать адрес последних элементов, а не следующих за ними, в этом примере а[6] вместо а[7]. Однако исполь¬зование элементов, следующих за последним, имеет несколько преиму¬ществ. Например, мы можем определить количество элементов с помощью простого вычитания:
количество элементов = 7-4 = 3
Принятое соглашение также позволяет нам написать цикл for.
for (i=3; i!=7; ++i)   ...
если мы хотим сделать что-либо с отсортированными элементами. Воз¬можность выбрать подпоследовательность применима и к контейнерам STL, таким как векторы. Например, если в программе sortl.cpp вектор v также содержит не менее семи элементов, отсортируем v[3], v[A], v[5] и у[6], написав
vector<int>::iterator i,  j; i = v.begin ()  + 3 ; j = v.begin() + 7; sort(i, j ) ;
или просто
sort(v.begin() + 3, v.begin()  + 7);
Такое использование оператора + рассмотрим более подробно в разделе 1.9.
Произвольный доступ, доступ по индексу и сортировка
Вы могли заметить, что в предыдущем обсуждении мы использовали вы¬ражения типа v[3], хотя v не является массивом, а определен как
vector<int> v;
Доступ по индексу возможен в этом случае, поскольку вектор является контейнером произвольного доступа, для которого определен operator[] доступа по индексу. Заметьте, однако, что мы не можем заменить v[3] на *(v + 3), потому что тип переменной v является классом, для которого не определен ни бинарный оператор +, ни унарный оператор *.
Алгоритм STL sort требует произвольного доступа. Поскольку такой доступ обеспечивают векторы и массивы, мы могли использовать этот ал¬горитм в программах sortl.cpp и sort2.cpp. Как показывает рисунок 1.1, дву¬сторонняя очередь также обеспечивает произвольный доступ, в отличие от списка. Это объясняет, почему вызов
sort (v. begin () , v.endO);
встречающийся в программе sortl.cpp, будет работать, если мы в программе заменим всюду vector на deque, но не на list. Более подробно - см. раздел 1.9.
Инициализация контейнеров
Как известно каждому программисту на С(++), определение массива может содержать список начальных значений. Например, мы можем написать
int а[3]  = {10, 5, 7}; int b[]  = {8, 13};
// эквивалентно int b[2]  = {8, 13}; int c[3]  = {4};
// эквивалентно int с[3] = {4, 0,  0};
Инициализация также возможна и для трех других типов последователь¬ных контейнеров, как показано в следующем примере:
int а[3] = {10,  5, 7}; vector<int> v(a, а+3); deque<int> w(a, а+3); list<int> х(а, а+3);
Но не только массив, а также и вектор, двусторонняя очередь или список могут служить основой для инициализации контейнера того же типа. На¬пример, если мы продолжим этот пример строчкой
vector<int> vl (v.begin() , v.endO);
вектор vl станет идентичен вектору v, оба будут состоять из трех элемен¬тов типа int, 10, 5 и 7. Этот пример откомпилируется, поскольку v и vl от¬носятся к одному типу - vector<int>. Напротив, следующий пример не бу¬дет компилироваться, поскольку мы не можем использовать значения списках для инициализации вектора vl1:
vector<int> vl (х.begin () , x.endO);
1 В окончательном стандарте С++ нет этого ограничения, поэтому приведенный пример должен откомпилироваться без ошибок на более позднем компиляторе, но рассматриваемые автором компиляторы VC5 и ВС5 основываются на раннем варианте стандарта языка, который не поддерживает версии STL, позволяющие инициализировать контейнер одного типа элементами контейнера другого типа (за исключением массива).  Прим. переводчика.
Ясно, что этот способ инициализации обеспечивается конструкторами контейнерных классов. Кроме этого, существуют конструкторы, прини¬мающие в качестве параметра целое, означающее желаемый размер,
 
и необязательный параметр, задающий значение для элементов, содер¬жащихся во вновь созданном контейнере. Например, мы можем написать
vector<int> v(5, 8)  // Пять элементов, все они равны 8. или
vector<int> v(5);
В последнем случае вектор v будет содержать пять элементов. Эта форма записи удобна в том случае, когда мы хотим присвоить значения элемен¬там позже, как в примере из раздела 1.6.
1.5. Алгоритм find
Следующая программа показывает, как мы можем находить требуемое зна¬чение в векторе:
// findl.cpp: Найти заданное значение в векторе. #include <iostream> #include <vector> #include <algorithm> using namespace std;
int mainO {   vector<int> v; int x;
cout << "Enter positive integers, followed by 0:\n"; while  (cin >> x, x != 0) v.push_back(x);
cout « "Value to be searched for:  "; cin >> x;
vector<int>::iterator i =
f ind(v. begin () , v.endO, x) ; if  (i == v.end())
cout « "Not found\n"; else
{   cout « "Found"; if  (i == v.begin())
cout « " as the first element"; else cout << " after " << *--i;
}
cout << endl; return 0;
}
Алгоритм find применим к каждому из четырех последовательных контейнеров (вектор, двусторонняя очередь, список и массив). Если мы везде заменим vector на deque, поведение программы не изменится, как и в случае, если мы заменим vector на list. Версия для массива целочисленных значений приведена ниже:
// find2.cpp: Найти заданное значение в массиве. #include <iostream> #include <algorithm> using namespace std;
int main()
{   int a[10], x, n = 0;
cout « "Enter at most 10 positive integers, "
"followed by 0:\n"; while (cin » x, x != 0 && n < 10) a[n++]  = x; cout « "Value to be searched for:  "; cin » x;
int *p = find(a, a+n, x); if (p == a+n)
cout « "Not found\n"; else
{   cout « "Found"; if (P == a)
cout « " as the first element"; else cout « " after " « *--p;
}
cout « endl; return 0;

1.6. Алгоритм copy и итератор вставки
Мы можем использовать алгоритм сору для копирования элементов одно¬го контейнера в другой, причем, например, источником может быть век¬тор, а приемником - список, как показывает следующая программа:
// copyl.cpp: Копируем вектор в список.
//	Первая версия: режим замещения.
#include <iostream>
#include <vector>
#include <list>
using namespace std;
int main()
{   int a[4] = {10, 20, 30, 40}; vector<int> v(a, a+4);
list<int> L(4);	// Список из 4 элементов
copy (v. begin () , v.endO, L. begin ()); list<int>::iterator i; for (i=L.begin() ; i != L.endO; + + i)
cout « *i « " ";    // Результат: 10 20 30 40 cout « endl; return 0;
 
Режимы замещения и вставки
Поскольку в список L необходимо скопировать четыре элемента, при его определении ему задана длина 4:
list<int> L(4);    // Список из 4 элементов.
Это необходимо, поскольку алгоритм сору, когда его используют таким спо¬собом, работает в режиме замещения. Это напоминает то, как вводятся сим¬волы с клавиатуры при наборе текста в режиме замещения. В этом режиме мы пишем поверх имеющегося текста; многие, однако, предпочитают ре¬жим вставки. На обычной клавиатуре клавиша Ins переключает режим вставки в режим замещения и обратно. Что касается алгоритма сору, то для него также не составит труда перейти в режим вставки. Попробуем начать с пустого списка, заменив вышеприведенное определение L на следующее:
list<int> L;       // Пустой список.
Затем заменим вызов алгоритма сору на следующий:
copy (v. begin () , v.endO, inserter(L, L.beginO));
С этими двумя изменениями программы содержимое списка L станет та¬ким же, как и в изначальной версии. Новая запись
inserter (...)
зовется итератором вставки, который является особым видом адаптера итератора, о чем рассказано в разделе 6.6. Мы можем также использовать его, чтобы вставить данные в середину последовательности, как показыва¬ет следующая версия:
// сору2.срр: Копируем вектор в список.
//	Вторая версия: режим вставки.
#include <iostream> #include <vector> iinclude <list> using namespace std;
int main()
{   int a[4] = {10, 20, 30, 40}; vector<int> v(a, a+4);
list<int> L(5, 123);    // Список из 5 элементов list<int>: :iterator i = L.beginO; ++i; ++i;
copy (v. begin)) , v.endO, inserter (L, i)); for (i=L.begin() ; i != L.endO; + + i) cout « *i « " ";
 
cout « endl; return 0;
}
Начальное содержимое списка L таково:
123 123 123 123 123
Затем итератор i устанавливается таким образом, чтобы он указывал на третий элемент списка, после чего он используется в выражении
inserter(L, i)
которое вычисляется при вызове алгоритма сору. В результате третий эле¬мент списка и оба элемента, следующие за ним, сдвигаются на четыре по¬зиции вправо, а на место третьего элемента вставляются значения 10, 20, 30 и 40. Это объясняет следующий результат работы данной программы:
123 123 10 20 30 40 123 123 123 Ввод и вывод
Интересно, что мы можем использовать алгоритм сору для ввода и выво¬да, как будет показано в разделе 1.9.
1.7. Алгоритм merge
Рисунок 1.3 иллюстрирует операцию объединения:
 
 

// merge.срр: Объединение вектора и массива в список. #include <iostream> #include <vector> #include <list> #include <algorithm>
using namespace std;
int main()
{   vector<int> a (5);
a[0]  = 2; a[l]  = 3; a[2] = 8;
a[3]  = 20; a[4] = 25;
int b[6] = {7, 9, 23, 28, 30, 33};
list<int> с; // Список с сначала пуст
merge(a.begin(), a.end(), b, b+6,
inserter(с, c.beginf))); list<int>::iterator i; for (i=c.begin(); i != c.endt); ++i)
cout « *i « "  " ; cout « endl; return 0;
}
Как и в случае с сору, нам приходится использовать итератор вставки, если мы хотим писать в список с в режиме вставки. В качестве альтернативы мы могли бы написать
list<int> с(11);  // принимаем 5 + 6 = 11 элементов merge (a. begin () , a.end(), b, b+6, c.beginO);
выделив достаточно места при определении принимающего списка с. Сам по себе алгоритм merge работает в режиме замещения, то есть не создает новых элементов контейнера, а помещает значения в существующие. Что¬бы вставлять новые элементы при объединении, мы должны использовать вставляющий итератор, как показано в полной программе. В любом слу¬чае результат работы программы следующий:
2 3 7 8 9 20 23 25 28 30 33
Как и в разделе 1.4, мы использовали операцию доступа по индексу, на¬писав, например, а[0], хотя а является вектором, а не массивом. Такое же обозначение доступа к элементу используется для двусторонних очередей, но не для списков. Напомним, что списки отличаются от мас¬сивов, векторов и двусторонних очередей тем, что мы не можем исполь¬зовать их вместе с алгоритмом сортировки. К этому вопросу мы вернем¬ся в разделе 1.9.
2-858
1.8. Типы, определенные пользователем

 
До сих пор все контейнеры, которые мы использовали, содержали элемен¬ты типа int. Кроме стандартных типов, таких как int, в контейнерах STL можно хранить типы, определенные пользователем. Так как вызов merge(...) в программе merge.cpp основан на операции сравнения «меньше чем» <, такой вызов для новых типов возможен, только если мы для этих типов определяем operator^. Покажем это на простом примере:
// merge2.срр: Объединяем записи, используя имена
//	в качестве ключей.
#include <iostream> Mnclude <string> #include <algorithm> using namespace std;
struct entry { long nr; char name[30];
bool operator<(const entry &b)const { return strcmp(name, b.name) < 0; }
};
int main()
{   entry a[3] = {{10,  "Betty"}, {11,  "James"}, {80,  "Jim"}}, b[2] = {{16,  "Fred"},
{20,  "William"}}, c[5],  *p; merge(a, a+3, b, b+2, c); for (p=c; p != c+5; p++)
cout « p->nr << " " << p->name « endl; cout << endl; return 0;
}
Для работы программы существенно, что имена в каждом из массивов а и b располагаются в алфавитном порядке. Программа объединяет а и b в с (в соответствии с алфавитным порядком имен), как показывает результат программы:
10	Betty 16	Fred
11	James 80	Jim
20 William
 
Если бы мы хотели, чтобы числа шли в порядке возрастания, их нужно было бы перечислить в таком порядке в заданных массивах а и Ь и, кроме того, заменить определение оператора «меньше». Поскольку числа и так уже рас¬положены в порядке возрастания в обоих массивах, нам остается только вместо функции-члена operator^ использовать следующую:
bool operatorx (const entry &b) const
{   return nr < b.r;
}
После этой модификации вывод программы будет содержать числа в восходящем порядке:
10	Betty
11	James 16 Fred
20 William 80 Jim
Функция operator^ не обязана быть членом класса entry. Иными словами, мы могли бы написать
struct entry { long nr; char name[30];
};
bool operator<( const entry &a, const entry &b) const
{   return strcmp(a.name, b.name) < 0;
}
вместо того определения класса entry, которое приводится в программе merge2.cpp. Кстати, в разделе 7.3.7 мы увидим, что существует версия merge, которая позволяет нам задать функцию сравнения в виде аргумента.
1.9. Категории итераторов
Как видно из раздела 1.4, мы можем использовать алгоритм sort для масси¬вов, векторов и двусторонних очередей, но не для списков. Алгоритм find, напротив, может быть использован для всех четырех типов контейнеров. (В этом разделе воспользуемся термином контейнер, имея в виду последо¬вательный контейнер, игнорируя при этом другие типы контейнеров, кото¬рые обсудим в главах 2 и 4.) Ясно, что для нахождения заданного значения достаточно одного перебора всех элементов, тогда как эффективная сорти¬ровка требует наличия произвольного доступа. В обоих случаях использу¬ются итераторы, но алгоритм sort требует «более мощных» итераторов, нежели алгоритм find. Итераторы можно естественным образом поделить на пять категорий, в соответствии с теми операциями, которые для них опре¬делены. Предположим, что i nj - итераторы одного вида. Тогда три следую¬щие операции
i == j	i != j	i = j
возможны всегда, независимо от категории этих итераторов. Следующая таблица показывает, какие из операций применимы к каждой из категорий итераторов; мы предполагаем, что х является переменной того же типа, что и элементы рассматриваемого контейнера, an - переменная типа int.

Категория итератора	Операции (дополнительно к i ==j, i! =j, i =j)	Какие
контейнеры
предоставляют	Каким
алгоритмом
используется
входной	x = %       i++	все четыре	find
выходной	*i = x,       i+ +	все четыре	сору
(приемник)
прямой	как у входного и выходного сразу	все четыре	replace
двунаправленный	как у прямого и —г, г—	все четыре	reverse
произвольного доступа	как у
двунаправленного и i + n,i — п, i +-и, i — n,i<j,i>j, i < = ;, i > = ;	массив, vector, deque (но не list)	sort
Как указано во втором столбце таблицы, прямой (forward) итератор поддер¬живает все операции как входных (input), так и выходных (output) итераторов. Двунаправленные (bidirectional) итераторы в дополнение ко всем операциям, поддерживаемым прямыми итераторами, поддерживают операции префикс¬ного и постфиксного уменьшения. Добавив к этому набор операций +, -, +=, -=, <, >, <=, >=, мы приходим к категории итераторов произвольного доступа (random access). Добавление целого числа к итератору возможно только для итераторов произвольного доступа; эта операция требуется, к примеру, для алгоритма сортировки. Так как список не предоставляет итераторов произ¬вольного доступа, мы не можем применить к списку алгоритм sort.
Программа findl в разделе 1.5 содержит строчку
else cout << " after " << *—i;
Мог возникнуть вопрос: почему мы не используем выражение *(г - 1) вме¬сто *—i, поскольку не было необходимости изменять значение П Теперь мы видим, что выражение i - 1 допустимо только для операторов произ¬вольного доступа, тогда как —i поддерживается также двунаправленными итераторами. В нынешнем варианте программа findl основана на векторе, а поскольку вектор работает с итераторами произвольного доступа, запись *(г- 1) не создаст проблем. Однако проблемы появятся, если слово vector везде, где оно встречается в программе, заменить на list. В этом случае пе¬ременная i станет двунаправленным итератором, для которого выражение i - 1 не является допустимым. Другими словами, программа findl перестанет компилироваться, если мы одновременно заменим vector на list, а *—i на *(г - 1). Точно так же и для итераторов, определенных классом list, недо¬ступна операция сравнения «меньше чем». Это иллюстрирует коммента¬рий в следующем фрагменте:
// Демонстрация итераторов	произвольного доступа:
int а[3]  = {5, 8, 2};
vector<int> v(a, а+3);
vector<int>::iterator iv =	v.beginf), ivl;
ivl = iv + 1;
bool bl = iv < ivl;
// В двух последних строчках + и < допустимы, поскольку // iv и ivl - итераторы произвольного доступа.
// Демонстрация двунаправленных итераторов: list<int> w(a, а+3);
list<int>::iterator iw = w.beginf), iwl;
iwl = iw + 1;	// Ошибка
bool b2 = iw < iwl;       // Ошибка
// В двух последних строчках + и < недопустимы, поскольку // iw и iwl -   двунаправленные итераторы. // Следующие две строчки, напротив, являются правильными: iwl = iw ;
bool ЬЗ = iw == iwl;
Какие категории итераторов требуются для алгоритмов
Алгоритм find (рассмотренный в разделе 1.5) из всех операций над итератора¬ми требует исключительно те, которые определены для входных итераторов, потому что ему достаточно только читать элементы последовательности, испол¬няя, например, операцию присваивания х = *i. Поэтому в вышеприведенной таблице find служит примером для входных итераторов в столбце Каким алго¬ритмом используется.
Вспомним, как мы использовали алгоритм сору (также упомянутый в рассмотренной таблице) в разделе 1.6:
copy (v. begin () , v.endO, L.beginO);
Чтобы увидеть, как это согласуется с нашей таблицей, заметим, что при¬емник копирования L является списком, который определяет итераторы, относящиеся к двунаправленной категории. Для L достаточно использо¬вать выходные итераторы, но двунаправленные итераторы поддерживают все операции выходных итераторов, так что проблем не возникает. Так как алгоритм сору требует выходной итератор в качестве третьего аргумента, он не будет применять операторы —, +, -, <, <=, >= и > к итераторам, ссыла¬ющимся на элементы списка L; также он не будет читать что-либо из L, ис¬полняя операции вроде х = *i. Однако он воспользуется противоположной операцией *i = х, чтобы записывать копируемые значения в L.
Потоковые итераторы: использование функции сору для ввода и вывода
Мы можем применить алгоритм сору для вывода, как показано в следую¬щем фрагменте:
const int N = 4;
int a[N]  = {7, б, 9, 2};
copy(a, a+N, ostream_iterator<int>(cout,  "  ")) ;
Мы также можем определить переменную-итератор i для использования в качестве третьего аргумента функции сору. Это достигается заменой вы¬зова сору следующими двумя операторами:
ostream_iterator<int> i(cout,  "  "); copy(a, a+N,  i);
В любом случае в поток стандартного вывода cout будут выведены числа 7, 6, 9 и 2, как если бы мы написали
for (int* р=а; р!= a+N; р++) cout « *р « "  ";
Для ввода мы можем использовать аналогичный прием, написав
istream_iterator<int, ptrdiff_t>(file)
где/г'/е является потоком ввода. Это длинное выражение можно, например, употребить вместо v.begin(), которое мы использовали бы для копирования элементов из контейнера v. Если опустить file в приведенной строчке, то по¬лучим выражение istream_iterator<int, ptrdiff_t>()
которое нужно применить вместо v.end(),raK как это выражение служит для обозначения конца файла. Например, пусть у нас есть файл example.txt со следующим содержанием:
10	20 30
40 50
Известно, что файл содержит только целые числа (разделенные пробелами), но мы не знаем заранее, сколько целых чисел находится в файле. Следую¬щая программа читает целые числа из этого файла и показывает их на экра¬не; условная компиляция используется для совместимости с ВС5, который требует наличия второго аргумента для шаблона istream_iterator.
11	copyio.cpp: Используем алгоритм сору
//	для ввода-вывода.
#include <fstream> #include <iostream> #include <iterator> #include <vector> using namespace std;
#if defined!	BORLANDC	)  && 	BORLANDC	 == 0x530
// Для BC5.3:
typedef istream_iterator<int,
char,
char_traits<char>, ptrdiff_t>
istream_iter;
#elif defined!	BORLANDC	)    // Для BC5.2:
typedef	istream_iterator<int, ptrdiff_t> istream_iter;
#else	// Для VC5.0:
typedef	istream_iterator<int> istream_iter;
#endif
int main()
{   vector<int> a;
ifstream file("example.txt"); if (file.faiK))
{   cout « "Cannot open file example.txt.\n"; return 1;
}
copy(istream_iter(file), istream_iter(),
inserter(a, a.beginf))); copy(a.begin(), a.end(),
#if defined!	BORLANDC	)  && 	BORLANDC	 == 0x530
ostream_iterator<int, char,
char_traits<char> >(cout,  "  "));
#else
ostream_iterator<int>(cout,  "  "));
#endif
cout « endl; return 0;
}
Поскольку эта программа не принимает во внимание структуру входного файла, вывод состоит только из одной строчки:
10 20 30 40 50
Мы вернемся к потоковым итераторам в разделе 6.6.
Операции с итераторами
Вспомним, что мы можем применять арифметические операции к итера¬торам произвольного доступа, подобно тому, как оперируем с указателя¬ми, написав, например:
int n, dist;
...	// i и i0 являются итераторами произвольного доступа
i0 = i; i += n;
dist = i - iO;      // dist == n Вместо этого мы можем использовать функции advance и distance: int n, dist;
...	// i и iO являются итераторами, но
// необязательно произвольного доступа
iO = i;
advance(i, n); dist = 0;
distance(iO, i, dist); // dist == n
1 В стандарте С++ принята функция distance с двумя аргументами вместо трех. Поэтому для компилятора, отвечающего стандарту, следует писать: dist = distance(i0, i) вместо dist = 0; distance(i0, i, dist). - Прим. переводчика.
Приведенный фрагмент1 работает для всех итераторов, если п имеет ра¬зумное значение, так что модифицированное значение i ссылается либо на существующий, либо на следующий за последним элемент рассматривае¬мого контейнера. Если i является прямым итератором, п должно быть
 
положительным. Тогда приведенный выше вызов функции advance имеет то же действие, что и применение оператора ++ к i п раз. Операции advance и distance будут выполняться гораздо быстрее для итераторов произволь¬ного доступа, чем для итераторов других типов.
1.10. Алгоритмы replace и reverse
Алгоритм replace, упомянутый в таблице раздела 1.9, позволяет нам найти все элементы с определенным значением в заданном контейнере и заменить их другим значением. Следующая программа служит иллюстрацией сказанного:
// replace.срр: Замена элементов последовательности. #include <iostream> #include <string> #include <algorithm> using namespace std;
int main()
{   char str[] = "abcabcabc"; int n = strlen(str); replace(str, str+n,  'b',  'q'); cout « str << endl; return 0;
}
Программа заменяет все элементы массива str, равные Ъ', на 'q, так что вывод этой программы будет следующим:
aqcaqcaqc
Алгоритм reverse, также упомянутый в таблице из раздела 1.9, позволяет легко заменить последовательность на обратную ей. Согласно этой табли¬це он требует двунаправленных итераторов, которые, как мы знаем, предо¬ставляют все четыре контейнера. Давайте продемонстрируем этот алго¬ритм снова с использованием массива.
// reverse.срр: Замена строки на обратную ей. #include <iostream> #include <string> #include <algorithm> using namespace std;
int main()
{   char str[] = "abcklmxyz";
reverse(str, str+strlen(str));
cout « str « endl;    // Будет выведено: zyxmlkcba return 0;
}
1.11. Возвращаясь к алгоритму sort
Функция qsort из стандартной библиотеки С является достаточно общей, потому что она принимает в качестве четвертого аргумента функцию срав¬нения, определяемую пользователем. При использовании алгоритма sort в разделе 1.4 подобный аргумент отсутствовал, так как sort полагался на оператор сравнения «меньше чем» <. Если имеем дело с массивами экзем¬пляров класса, мы можем придать этому оператору любое значение по на¬шему усмотрению, но это невозможно, если элементами массива являют¬ся значения какого-либо встроенного типа, например int. Допустим, мы захотим отсортировать массив в нисходящем, а не в восходящем порядке. Конечно, это можно сделать, отсортировав массив сначала в восходящем порядке, а затем применив алгоритм reverse, обсуждавшийся в предыду¬щем разделе. Но мы можем решить задачу другим способом, используя ал¬горитм sort с третьим аргументом, который задает функцию сравнения, как в случае с qsort. Например:
// dsortl. срр: Сортировка в нисходящем порядке
//	с использованием функции сравнения.
#include <iostream>
#include <algorithm>
using namespace std;
bool comparefun(int x,  int y)
{   return x > y;
}
int main() {    const int N = 8; int a[N]  =
{1234, 5432, 8943, 3346, 9831, 7842, 8863, 9820}; cout << "Before sorting:\n";
copy(a, a+N, ostream_iterator<int>(cout,  "  "));
cout << endl;
sort(a, a+N, comparefun);
cout << "After sorting in descending order:\n"; copy(a, a+N, ostream_iterator<int>(cout,  "  ")); cout << endl; return 0;
}
Вспомним, что мы обсуждали использование сору для вывода, как это дела¬ется в данной программе, в конце раздела 1.9. Нам необходимо определить функцию comparefun таким образом, чтобы значение comparefun(a[i\, a\j]) равнялось true тогда и только тогда, когда после сортировки a[i] должно
 
предшествовать a\j]. Функции, которые подобно comparefun возвращают значение типа bool, называются предикатами. Программа создает следующий вывод:
Before sorting:
1234 5432 8943 3346 9831 7842 8863 9820
After sorting in descending order:
9831 9820 8943 8863 7842 5432 3346 1234
1.12. Введение в функциональные объекты
Существует другой способ решения задачи сортировки из предыдущего раз¬дела. Хотя для такой простой задачи он и не нужен, обсуждаемые принци¬пы являются важными для других более сложных случаев, поэтому не сто¬ит пропускать этот раздел при чтении. Функциональным объектом называется класс, где определен оператор вызова, который записывается как operatorQ. От класса не требуется наличия каких-либо других членов. Да¬вайте начнем с очень простого примера. (Здесь и далее мы пишем iostreamh вместо iostream, поскольку в последнем случае VC5 также требует наличия строчки using namespace std, а ВС5, напротив, не позволяет использовать эту строчку, если не включаются типичные заголовки STL, такие как vector.)
II funobj.cpp: Очень простой функциональный объект. #include <iostream.h>
class compare { public:
int operator()(int x, int y)const
{   return x > y;
}
};
int main() {   compare v;
cout «ч(2,  15) << endl;	// Вывод: 0
cout << compare()(5, 3) << endl; // Вывод: 1
cout << endl;
return 0;
}
Так как для класса compare определен оператор вызова функции, operatorQ, с двумя параметрами типа int, мы можем использовать выражение v(2,15), где v - переменная этого класса. Это выражение на самом деле является сокра¬щенной формой записи вместо v.operatorQ{2, 15) и таким образом приводит к вызову функции-члена operatorQ класса compare, возвращающей значение 0, поскольку 2 не больше 15. Второй вызов
compare 0(5, 3)
выглядит довольно необычно. Первая часть этой записи, compareQ, пред¬ставляет собой вызов конструктора по умолчанию класса compare. Други¬ми словами, выражение compareQ представляет объект типа compare, и за ним, как и у V, может следовать список аргументов, в этом примере (5, 3).
Следующая программа, основывающаяся на использовании функциональ¬ного объекта, эквивалентна программе dsortl из предыдущего раздела:
// dsort2 .срр: Сортировка в нисходящем порядке
//	с использованием определенного нами
//   функционального объекта.
tinclude <iostream>
tinclude <algorithm>
using namespace std;
class compare {
public:
bool operator()(int x, int у)const
{   return x > y;
}
};
int main() {   const int N = 8; int a[N]  =
{1234, 5432, 8943, 3346, 9831, 7842, 8863, 9820}; cout « "Before sorting:\n";
copy(a, a+N, ostream_iterator<int>(cout,  "  "));
cout « endl;
sort (a, a+N, compared);
cout « "After sorting in descending order:\n"; copyfa, a+N, ostream_iterator<int>(cout, " ")); cout << endl; return 0;
}
В действительности нет необходимости определять класс compare, по¬скольку в STL уже есть подобное определение в более общей форме шаб¬лона. Следовательно, мы можем опустить класс compare и при вызове ал¬горитма sort заменить compareQ на greater<int>Q. Это дает нам следующую, окончательную версию:
// dsort3 .срр: Сортировка в нисходящем порядке
//	с использованием шаблона 'greater'.
tinclude <iostream>
tinclude <algorithm>
tinclude <functional>
using namespace std;
 
int main() {   const int N = 8; int a[N]  =
{1234, 5432, 8943, 3346, 9831, 7842, 8863, 9820}; cout << "Before sorting:\n";
copyfa, a+N, ostream_iterator<int>(cout, " ")); cout « endl;
sort(a, a+N, greater<int>());
cout << "After sorting in descending order:\n"; copyfa, a+N, ostream_iterator<int>(cout, " ")); cout « endl; return 0;
}
Обсудим функциональные объекты более подробно в главе 6.
1.13. Использование find_if, remove и remove_if
В этом разделе мы рассмотрим три алгоритма, используя их для векторов, но имея в виду, что они также применимы к двусторонним очередям и спискам.
Алгоритм findjf
В дополнение к алгоритму find, использовавшемуся в разделе 1.5 для на¬хождения элементов вектора с заданным значением, имеется также алго¬ритм find_if, который является более общим в том смысле, что в качестве одного из аргументов принимает предикат (см. раздел 1.11). Этот алгоритм ищет в векторе первый элемент, который удовлетворяет условию, указан¬ному в этом предикате. Например, следующая программа ищет в векторе первый элемент */, удовлетворяющий
3 < *i < 8
Эта программа проверяет, найден ли такой элемент, и в этом случае печа¬тает его значение:
// find_if.срр: Демонстрация алгоритма find_if. #include <iostream> tinclude <vector> #include <algorithm> using namespace std;
bool condition(int x)
{   return 3 <= x && x <= 8;
}
int main()
{   vector<int> v;
v.push_back(10); v.push_back(7); v.push_back(4); v.push_back(l); vector<int>::iterator i;
i = f ind_if (v.begin () , v.endO, condition); if (i != v.endO )
cout << "Found element:  " « *i << endl; return 0;
}
Как легко предугадать, вывод программы будет следующий: Found element: 7
поскольку в последовательности {10, 7, 4, 1} значение 7 первое находится в диапазоне между 3 и 8. Программа также будет правильно работать, если заменить функцию функциональным объектом (см. раздел 1.12). Для этого вместо функции condition напишем следующее определение класса:
class CondObject { public:
bool operator()(int x)
{   return 3 <= x && x <= 8;
}
};
В то же время мы заменим вызов findjf в тексте программы на следующий:
i = f ind_if (v. begin () , v.endO, CondObjectО ) ; Алгоритмы remove и remove if
Предположим, нам требуется удалить все элементы вектора, равные опре¬деленному значению. Это можно сделать, несколько раз подряд вызывая find и erase, но существует и более эффективный способ добиться того же самого. Необходимо выполнить два действия:
1.	Переупорядочить вектор с помощью вызова remove, разместив все эле¬менты, которые мы хотим оставить, в начале вектора. Эта операция стабильна: порядок, в котором будут находиться сохраненные элемен¬ты, не изменится.
2.	Стереть те элементы, которые нам не нужны; теперь они расположены в конце вектора.	*
Алгоритм remove возвращает новый логический конец данных, не изменяя размер контейнера. Мы можем стереть «мусор», начиная с возвращенного конца с помощью функции-члена erase, рассмотренной в конце раздела 1.3.
Следующая программа показывает, как это делается, удаляя все элементы, равные 1, из последовательности:
// remove.срр: Алгоритм remove.
#include <iostream> #include <vector> #include <algorithm> #include <iterator> using namespace std;
void out(const char *s, const vector<int> &v) {   cout « s;
copy (v. begin () , v.endO,
ostream_iterator<int>(cout,  " "));
cout << endl;
}
int main()
{   vector<int> v;
vector<int>::iterator new_end;
v.push_back(l); v.push_back(4); v.push_back(l); v.push_back(3); v.push_back(l); v.push_back(2); out("Initial sequence v:\n", v); new_end = remove (v. begin () , v.endO, 1) ; outf'After new_end = remove (v. beginf) , "
"v.endO , 1) : \n", v) ; v.erase(new_end, v.endO);
out("After v.erase(new_end, v.endf)):\n", v); return 0;
}
Начиная с последовательности {1,4,1,3,1,2}, эта программа логически уда¬ляет элементы, равные 1; остающиеся элементы помещаются в первых
new_end - v.begin = 3
элементах, где new_end - значение, возвращаемое вызовом функции remove. Остальные три элемента, начиная с позиции newjsnd, затем стираются с по¬мощью функции-члена erase. Вывод этой программы показан ниже:
Initial sequence v: 14 13 12
After new_end = remove (v.begin () , v.endO, 1): 4 3 2 3 1 2
After v.erase(new_end, v.endf)): 4 3 2
Стабильность алгоритма remove иллюстрируется порядком 4, 3, 2 остав¬шихся элементов - этот порядок совпадает с тем, в котором эти элементы встречались в исходной последовательности. Хотя алгоритм remove при¬меним также и к спискам, для них определена функция-член remove, ис¬пользование которой предпочтительнее, как мы увидим в разделе 3.5.
Существует также алгоритм remove_if, являющийся обобщенной верси¬ей remove, точно так же как find_if - обобщенная версия find. Следующая программа показывает, как мы можем использовать remove_if (опять со¬вместно с функцией-членом erase), чтобы стереть все элементы, меньшие или равные 2:
// rm_if.cpp: Алгоритм remove_if.
tinclude <iostream> tinclude <vector> tinclude <algorithm> tinclude <iterator>
using namespace std;
void out(const char *s, const vector<int> &v) {   cout << s;
copy(v.begin(), v.end(),
ostream_iterator<int>(cout,  " "));
cout << endl;
}
bool condfint x) {   return x <= 2; }
int main()
{   vector<int> v;
vector<int>::iterator new_end;
v.push_back(l); v.push_back(4); v.push_back(l); v.push_back(3); v.push_back(l); v.push_back(2); out("Initial sequence v:\n", v); new_end = remove_if(v.begin(), v.endf), cond); v.erase(new_end, v.endf));
out("After erasing all elements <= 2:\n", v); return 0;
}
Эта программа выдает:
Initial sequence v: 14 13 12
After erasing all elements <= 2: 4 3
 
Как и remove, алгоритм remove_if является стабильным, поэтому совпадение порядка следования элементов 4 и 3 в результирующей последовательности с их порядком в исходной последовательности не является случайным.
1.14. Класс auto_ptr
После того как размещена динамическая память, нужно внимательно следить за тем, чтобы она была правильно освобождена. Обычно программисты на С используют для этого malloc и free, а программисты на С++ используют так¬же new и delete. Первое, о чем необходимо помнить, что после
int *р = new int; int *q = new int[n];
в дальнейшем требуется выполнить следующие операторы:
delete р; delete [] q;
Пара квадратных скобок [] должна использоваться для q, но не для р; не¬соблюдение этого правила - довольно частая причина ошибок. Другая сложность заключается в необходимости отслеживать копии указателей. Например, если мы напишем
int *а = new intfn],  *b; b = а;
а и b будут указывать на один и тот же блок памяти. Освобождение этого блока должно быть проведено только один раз, поэтому позже мы должны выполнить либо
delete [] а; либо
delete[] b;
но не оба эти выражения.
В STL определен специальный класс autojptr, который делает более бе¬зопасным использование оператора new в сложных случаях. Функция-член get возвращает указатель на сами данные. Если мы присвоим значе¬ние autojptr а переменной Ь, указателю a.get() автоматически будет присвоено значение NULL, например:
// auto_ptr.срр: Данным соответствует // только один указатель, ¦include <iostream> ¦include <memory> using namespace std;
int main()
{   auto_ptr<int> a(new int), b; *a.get()  = 123;
cout « "*a.get() = " « *a.get() « endl; b = a;
cout « "The assignment b = a has been executed.\n"; if (a.getf)  == NULL)
cout << "As a result, a.getf)  is NULL.\n"; cout « "*b.get() = " « *b.get() « endl; return 0;
}
Вывод этой программы следующий: *a.get()  = 123
The assignment b = a has been executed. As a result, a.getf)  is NULL. *b.get()  = 123
Поскольку выражение a.getQ является обычным указателем, значение, на которое оно указывает, обозначается как *a.get(). Преимущество исполь¬зования класса auto jptr заключается в том, что память освобождается ав¬томатически, когда уничтожается объект, принадлежащий этому классу, и это происходит только один раз: в нашем примере переменные а и b не содержат одновременно указатели на одну и ту же область памяти. Для прояснения механизма действия класса autojptr посмотрим на его де¬структор (в этом коде the jp - скрытый (private) член класса, указыва¬ющий на размещенные данные):
~auto_ptr(){delete the_p;}
В нашей программе деструктор вызывается как для а, так и для Ь, поэтому выполняются оба действия
delete a.the_p; delete b.the_p;
что может показаться ошибкой. Однако один из двух используемых здесь указателей равен NULL, а применение оператора delete к указателю, рав¬ному NULL, является разрешенной операцией, которая не вызывает ника¬ких действий.
Следует упомянуть об унарном операторе *, который возвращает *thejp. Поскольку функция-член get возвращает указатель thejp, мы упростим использованную нами запись. Например, вместо
*a.get()  = 123;
 
напишем *а = 123;
но должны иметь в виду, что а не является настоящим указателем. Предупреждение
В отличие от прочих составляющих библиотеки STL класс autojptr иногда критикуют за странное поведение, поэтому используйте его только тогда, когда точно знаете, что вы делаете. Например, после выполнения
auto_ptr<int> a(new int), b; *a.get() = 123; b = a;
может показаться странным, что, хотя значение *Ь определено и равно 123, мы не имеем права использовать выражение *а, поскольку последнее при¬сваивание приводит к обнулению указателя на целое, содержащегося в а.
Причина этого заключена в необходимости освобождать память, выде¬ленную с помощью оператора new, ровно один раз.
 
 


Другие алгоритмы и контейнеры

2.1. Алгоритм accumulate
Нахождение суммы элементов последовательности или подпоследователь¬ности лучше всего достигается с помощью алгоритма accumulate. Этот алго¬ритм вместе с некоторыми другими, которые имеют отношение к вычисле¬ниям, определен в заголовке numeric, а не algorithm, как большинство остальных алгоритмов. (Если вы работаете с HP STL, то должны использо¬вать algo.h вместо algorithm или numeric.) Следующая программа показыва¬ет, как использовать алгоритм accumulate для массива:
// accuml.cpp: Вычисление сумм. #include <iostream> #include <numeric> using namespace std;
int main()
{   const int N = 8;
int a[N] = {4, 12, 3, 6, 10, 7, 8, 5}, sum = 0;
sum = accumulate(a, a+N, sum);
cout   « "Sum of all elements:  " « sum « endl; cout   « "1000 + a[2] + a[3] + a[4] = "
« accumulate(a+2, a+5, 1000) « endl; return 0;
}
 
Первый и второй аргументы алгоритма accumulate указывают последова¬тельность, сумму элементов которой мы хотим вычислить. Третий аргу¬мент задает начальное значение для процесса суммирования и, следова¬тельно, обычно равен нулю. При первом вызове accumulate мы могли бы использовать константу 0 вместо переменной sum в качестве третьего ар¬гумента. Вот результат работы этой программы:
Sum of all elements: 55
1000 + a[2] + a[3] + a[4] = 1019
Эти значения вычисляются как
0 + 4+12 + 3 + 6+10+ 7 + 8 + 5 = 55 1000 + 3 + 6+ 10 = 1019
Шаблон multiplies<int>() аналогичен рассмотренному в конце раздела 1.12 шаблону greater<int>(). Мы используем его для вычисления произведения вместо суммы:
// accum2.cpp: Вычисление произведения, ¦include <iostream> ¦include <numeric> ¦include <algorithm> ¦include <functional>
using namespace std;
int main()
{   const int N = 4;
int a[N] = {2, 10, 5, 3}, prod = 1;
prod = accumulate(a, a+N, prod, multiplies<int>()) ;
//  ('muliplies' бывший 'times')
cout « "Product of all elements:  " « prod « endl; return 0;
}
Заметим, что ранее шаблон назывался times, а не multiplies. Это по-прежнему так для ВС 5.2. Вывод программы составляет 300 (= 1x2x 10x5x3). В этом примере существенно, что третий аргумент алгоритма равен 1 (это «идентичное» или «нейтральное» значение для умножения). Четвертый ар¬гумент указывает, что будет вычисляться целочисленное произведение.
Снова обратимся к алгоритму accumulate, на этот раз используя наш собственный функциональный объект. Для заданного массива а, содержа¬щего, скажем, четыре элемента, вычисляется следующее значение:
1 * а[0] + 2 * а[1] + 4 * а[2] + 8 * а[3]
Кроме функции operatorQ наш функциональный объект содержит член типа int, который хранит последовательные степени 1,2,4 и 8, а также кон¬структор для инициализации этого члена класса:
// ассшпЗ .срр: Вычисление следующей суммы:
//	1 * а[0] + 2 * а[1] + 4 * а[2] + 8 * а[3].
¦include <iostream>
¦include <numeric>
using namespace std;
class fun { public:
fun(){i = 1;}
int operator()(int x, int y) {   int u = x + i * y;
i *= 2;
return u;
}
private: int i ;
};
int main()
{   const int N = 4;
int a[N]  = {7, 6, 9, 2}, prod = 0;
prod = accumulate(a, a+N, prod, fun());
cout << prod « endl;
return 0;
}
Эта программа выведет значение 71 (= 1x7 + 2x6 + 4x9 + 8x2).
2.2. Алгоритм for each
Мы можем использовать алгоритм for_each для вызова функции с каждым из элементов последовательности в качестве аргумента. Вот программа, которая демонстрирует это:
// for_each.cpp: Алгоритм for_each. ¦include <iostream> ¦include <algorithm>
using namespace std;
void display(int x) {   static int i=0;
cout « "a[" << i++ « "] = " « x « endl;
}
int main()
{   const int N = 4;
 
int a[N] =
{1234, 5432, 8943, 3346}; for_each(a, a+N, display); return 0;
}
Эта программа работает точно так же, как если бы мы заменили вызов foreach следующим оператором for.
lor (int *р=а; р != a+N; р++) display(*р);
В любом случае программа выведет
а[0] = 1234 а[1] = 5432 а[2] = 8943 а[3]  = 3346
Функция display в этом примере обладает существенным недостатком: пере¬менная i равна нулю только тогда, когда эта функция вызывается в первый раз. Например, еще один такой же вызов for_each в функции main приведет к ошибке, поскольку при повторном вызове функция display не начнет с i = 0. Мы можем решить эту проблему с помощью функционального объекта. За¬меним функцию display следующим определением класса:
class display { public:
display!): i(0){}
void operator()(int x)
{   cout « "a[" « i++ «"]="« x « endl; }
private: int i ;
};
Также добавим пару скобок к третьему аргументу foreach:
for_each(a, a+N, display!));
С этими изменениями программа выдаст прежние результаты. В отличие от первоначальной программы этот вывод будет повторен дважды, если мы напишем два вызова for_each.
2.3. Подсчет
Алгоритм count подсчитывает, какое количество элементов последователь¬ности равно заданному значению. Давайте используем этот алгоритм для того, чтобы подсчитать, сколько раз в строке встречается буква е.
// count_e.cpp: Подсчет количества букв 'е'.   • ¦include <iostream> ¦include <string> ¦include <algorithm> using namespace std;
int mainf) // Для ВС 5.2 требуются изменения (см. ниже) {   char *р =
"This demonstrates the Standard Template Library"; int n = count(p, p + strlen(p),   'e'); cout « n « " occurrences of 'e' found.\n"; return 0;
}
В изначальной версии STL алгоритм count не возвращал значение, а ис¬пользовал четвертый параметр, который увеличивался на найденную ве¬личину. Это по-прежнему так для ВС 5.2.
Следующая программа подсчитывает, сколько символов из множества {'а', 'ё, 7, 'о, 'и'} (так называемые гласные) встречаются в заданной строке.
// countvwl.срр: Сосчитать, сколько раз гласные
//	а, е, i, о, и встречаются в заданной строке
//	(первая версия).
¦include <iostream>
¦include <string>
¦include <algorithm>
using namespace std;
int main() {   char *p =
"This demonstrates the Standard Template Library",
*q = p + strlen(p); int n = count(p, q,  'a') +
count(p, q,  'e') +
count(p, q,  'i') +
count(p, q,  'o') +
count(p, q,   'u'); cout « n « " vowels (a, e, i, o, u) found.\n";
// n = 13 return 0;
}
К сожалению, этот подход не слишком эффективен, так как заданная строка сканируется пять раз, а мы бы предпочли один проход. Это достигается с помощью алгоритма count_if, которому можно передать функцию, опреде¬ляющую, удовлетворяется ли требуемое условие. Число параметров функ¬ции count_if недавно уменьшилось на один, точно так же, как и у count.
 
// countvw2.срр: Сосчитать, сколько раз гласные
//	а, е, i, о, и встречаются в заданной строке
//	(улучшенная версия).
¦include <iostream>
¦include <string>
¦include <algorithm>
using namespace std;
bool found(char ch)
{   return ch == 'a'   II ch == 'e'  II ch == ' i'   II ch == 'о'  II ch == 'u';
}
int main() {   char *p =
"This demonstrates the Standard Template Library"; int n = count_if(p, p + strlen(p), found); cout « n « " vowels (a, e, i, o, u) found.\n";
// n = 13 return 0;

2.4. Функциональные объекты, определенные в STL
Напомним, что такие функции, как found (в предыдущем разделе), называ¬ются предикатами. Они возвращают true или fake в зависимости от соблюде¬ния некоторого условия. Выражение greater<int>, которое встретилось нам в разделе 1.11, также является предикатом, но определенным в STL в виде шаблона. Напомним также, что для сортировки последовательности в нисходящем порядке мы использовали это выражение в вызове
sort(a, a+N, greater<int>());
В разделе 2.1 мы применяли похожее выражение multiplies<int>() в следу¬ющем вызове, чтобы указать необходимость выполнения умножения:
int prod = accumulate(a, a+N, 1, multiplies<int>());
Ниже дан полный список таких шаблонов (определенных в заголовке functional), соответствующих стандартным бинарным операциям:
plus<T>	minus<T>
multiplies<T>	divides<T>	modulus<T>
equal_to<T>	not_equal_to<T>
greater<T>	less<T>
greater_equal<T>	less_equal<T>
logical_and<T>	logical_or<T>
Как известно, выражения типа plus<T>() являются объектами, другими словами, вышеперечисленные шаблоны, сопровожденные парой круглых скобок, стандартные функциональные объекты, определенные в библио¬теке STL. Кроме этого, существуют шаблоны, соответствующие унарным операторам - (как в выражении -х) и ! (произносится не):
negate<T>	logical_not<T>
Теперь вернемся к программе countvw2.cpp в конце предыдущего раздела. Она содержит вызов
int n = count_if(p, р + strlen(p), found);
где found - определенная нами функция, указывающая, какие символы не¬обходимо подсчитывать. Предположим, что теперь мы хотим подсчитать все символы ch >= 'к'. Очевидно, мы могли бы заменить found на следую¬щую функцию:
bool found(char ch) {   return ch >= 'k' ; }
Вместо этого возможно использовать упомянутый шаблон greater_equal<T>, но нам нужен способ связать greater_equal<char> со значением 'k. Это дости¬гается с помощью записи
bind2nd(greater_equal<char>(),  'к')
Указанное выражение может заменить имя функции found в рассматрива¬емом вызове count_if, что дает
n = count_if(p, р + strlen(p),
bind2nd(greater_equal<char>(),  'k'));
Шаблон bind2nd называется привязкой (являющейся разновидностью адаптера функции). Поскольку два выражения
ch >= 'к'     и   !(ch < 'к')
эквивалентны, нас может заинтересовать, допустимо ли использовать не¬кий аналог второго выражения в качестве третьего аргумента функции count_if. Это действительно можно сделать, если применить другой тип адаптера функции, называемый отрицателем:
n = count_if(p, р + strlen(p),
notl(bind2nd(less<char>(),  'k')));
Мы обсудим адаптеры функций (и прочие адаптеры) более подробно в главе 6.
 
2.5. Введение в ассоциативные контейнеры
Кроме массивов и списков, использующихся для реализации последова¬тельных контейнеров (массивов, векторов, двусторонних очередей и списков), которые обсуждались до сих пор, сбалансированные деревья представляют собой другую классическую структуру данных, предназна¬ченную для их эффективного хранения и извлечения. Сбалансированные деревья составляют основу для другой группы контейнеров, определенной в STL, так называемых (сортированных) ассоциативных контейнеров. Как и ранее, мы в основном сосредоточимся на том, как использовать эти кон¬тейнеры, а не на том, как они реализованы. Всего существует четыре типа этих контейнеров: множества (sets), множества с дубликатами (multisets), словари (maps), словари с дубликатами (multimaps). Перед тем как обсу¬дить их использование, посмотрим, чем они различаются.
Множества
Каждый элемент множества является собственным ключом, и эти ключи уникальны. Поэтому два различных элемента множества не могут совпа¬дать. Например, множество может состоять из следующих элементов:
123 124 800 950
Множества с дубликатами
Множество с дубликатами отличается от просто множества только тем, что способно содержать несколько совпадающих элементов. Например, до¬пустимо существование множества с дубликатами, в котором присутству¬ют следующие четыре элемента:
123 123 800 950
Словари
Каждый элемент словаря имеет несколько членов, один из которых явля¬ется ключом. В словаре не может быть двух одинаковых ключей. Приве¬дем пример словаря из четырех элементов, у каждого из которых присут¬ствует целочисленный ключ и буквенные сопутствующие данные:
123	John
124	Mary
800     Alexander 950     Jim
Словари с дубликатами
Словарь с дубликатами отличается от просто словаря тем, что в нем разре¬шены повторяющиеся ключи. Вот, к примеру, словарь с дубликатами, со¬стоящий из четырех элементов (с целочисленными ключами):
123     John 123     Магу 800     Alexander 950     Jim
В отличие от последовательных контейнеров ассоциативные контейнеры хранят свои элементы отсортированными, вне зависимости от того, каким образом они были добавлены.
Заголовки и переносимость
В изначальной версии HP STL было четыре заголовка, связанных с рассматриваемой темой: set.h, multiseth, map.h и multimap.h. В проекте стандар¬та С++ остались только два: set и тар. Они используются также для ассо¬циативных контейнеров с дубликатами.
2.6. Множества и множества с дубликатами
В этом и следующем разделе мы рассмотрим по одной простой программе для каждого из четырех ассоциативных контейнеров: эти разделы покры¬вают все возможные операции с этими контейнерами не полностью, но они поясняют наиболее важные их характеристики.
Множества
Начнем с двух множеств целых чисел. Хотя элементы добавляются разны¬ми способами, получающиеся множества идентичны.
// set.срр: Два идентичных множества,
//	созданных разными способами,
¦include <iostream> ¦include <set> using namespace std;
int main()
{   set<int, less<int> > S, T;
S.insert(10); S.insert(20); S.insert(30); S.insert(10);
T.insert(20); T.insert(30); T.insert(10);
if (S == T) cout « "Equal sets, containing:\n";
 
for (set<int, less<int> >::iterator i = T.beginO; i != T.endO ; i++) cout « *i « " "; cout « endl; return 0;
}
Программа выведет
Equal sets, containing: 10 20 30
и это показывает, что порядок 20, 30, 10, в котором были добавлены эле¬менты Т, несущественен; равным образом множество 5 не изменяет добав¬ление элемента 10 во второй раз. Напомним, что ключи уникальны во мно¬жествах, но могут повторяться во множествах с дубликатами.
Обратите внимание на запись, с помощью которой определены S и Т:
set<int, less<int> > S, Т;
Предикат
less<int>
требуется для определения значения выражения < k2, где kt и k2 являют¬ся ключами. Это выглядит странным в текущем примере, когда ключи целые числа, но стоит напомнить, что множества могут содержать ключи, тип которых определен пользователем. Пробел между двумя закрывающи¬ми угловыми скобками в
less<int> >
необходим, чтобы компилятор не обнаружил в этом фрагменте оператор ».
Хотя множества и не являются последовательностями, мы можем применять к ним итераторы и функции begin и end, как видно из этой программы. Данные итераторы являются двунаправленными (см. раздел 1.9): для
итератора i типа set<int, less<int> >::iterator выражения	—i и i—
являются допустимыми, a i + N и i - N - нет.
Множества с дубликатами
Следующая программа демонстрирует, что во множествах с дубликатами могут встречаться одинаковые ключи. Для разнообразия в ней вывод осу¬ществляется с помощью функции сору, как показано ранее в разделе 1.9:
// multiset.срр: Два множества с дубликатами, ¦include <iostream> ¦include <set> using namespace std;
int main()
{   multiset<int, less<int> > S, T;
S.insert(10); S.insert(20); S.insert(30); S.insert(10);
T.insert(20); T.insert(30); T.insert(10); if  (S == T) cout « "Equal multisets:\n"; else cout « "Unequal multisets:\n";
cout « "S:  ";
copy(S.begint) , S.endO,
ostream_iterator<int>(cout,  "  ")); cout « endl; cout « "T:  "; copy(T.begin(), T.end(),
ostream_iterator<int>(cout,  " ")); cout « endl; return 0;
}
Вывод программы показывает, что ключ 10 дважды встречается во множе¬стве с дубликатами S. Поскольку он встречается только один раз в Т, эти два множества с дубликатами неравны:
Unequal multisets: S: 10 10 20 30 Т: 10 20 30
2.7. Словари и словари с дубликатами

Словари
Происхождение термина «ассоциативный контейнер» становится ясным, как только мы начинаем рассматривать словари. Например, телефонный справочник связывает (ассоциирует) имена с номерами. Имея заданное имя или ключ, мы хотим узнать соответствующий номер. Другими слова¬ми, телефонная книга является отображением имен на числа. Если имя Johnson, J. соответствует номеру 12345, STL позволяет нам определить словарь D, так что мы можем записать следующий оператор для выраже¬ния отображения, показанного на второй строчке:
D["Johnson, J."] = 12345;
"JohnsonJ."   ->    12345 Отметим сходство с обычными массивами, например:
а[5] = 'Q';
5   ->
 
В последнем случае индексами являются значения 0,1,2,но на словари это ограничение не распространяется. Нижеприведенная программа пока¬зывает, что словарями удобно пользоваться:
// mapl.cpp: Первая программа со словарями, ¦include <iostream> ¦include <string> ¦include <map> using namespace std;
class compare { public:
bool operator()(const char *s, const char *t)const
{   return strcmp(s, t) < 0;
}
};
int main()
{   map<char*, long, compare> D;
D["Johnson, J."]    = 12345;
D["Smith, P."]        = 54321;
D["Shaw, A."]	= 99999;
D["Atherton, K."]  = 11111; char GivenName[30]; cout « "Enter a name: "; cin.get(GivenName, 30); if (D. find (GivenName)   != D.endO)
cout « "The number is " « D[GivenName]; else
cout « "Not found."; cout « endl; return 0;
}
В отличие от предыдущего примера программа тар.срр содержит опреде¬ленный нами функциональный объект (функциональные объекты рас¬смотрены в разделе 1.12). Определение
map<char*, long, compare> D;
справочника D содержит следующие параметры шаблона:
•	тип ключа char*;
•	тип сопутствующих данных long;
•	класс функционального объекта compare.
Функция-член operatorC) класса compare определяет отношение меньше для ключей.
Словари с дубликатами
Следующая программа показывает, что словари с дубликатами могут со¬держать повторяющиеся ключи:
// multimap.срр: Множество с дубликатами,
//	содержащее одинаковые ключи.
¦include <iostream>
¦include <string>
¦include <map>
using namespace std;
class compare { public:
bool operator()(const char *s, const char *t)const
{   return strcmpfs, t) < 0;
}
};
typedef multimap<char*, long, compare> mmtype; int main() {   mmtype D;
D.insert(mmtype::value_type("Johnson, J.", 12345)); D.insert(mmtype::value_type("Smith, P.", 54321)); D. insert(mmtype::value_type("Johnson, J.", 10000)); cout << "There are " << D.sizeO << " elements.\n"; return 0;
}
Программа выведет:
There are 3 elements.
Оператор доступа по индексу [] не определен для множеств с дубликата¬ми, поэтому мы не можем добавить элемент, написав, к примеру:
D["Johnson, J."] = 12345; Вместо этого напишем:
D.insert(mmtype::value_type("Johnson, J.", 12345)); где mmtype на самом деле означает
multimap<char*, long, compare>
Так как идентификатор value_type определен внутри шаблонного класса multimap, перед value Jype здесь требуется написать префикс mmtype::. Оп¬ределение идентификатора value Jype основано на шаблоне pair, который мы сейчас и обсудим.
 
2.8. Пары и сравнения
Чтобы использовать словари и словари с дубликатами более интересным способом, нам нужно познакомиться с шаблонным классом pair (пара), ко¬торый полезен также и для других целей. Этот класс использует следую¬щая программа:
// pairs.срр: Операции с парами, ¦include <iostream> ¦include <utility>
using namespace std; int main()
(   pair<int, double> P(123, 4.5), Q = P; Q = make_pair(122, 4.5);
cout « "P:  " « P.first « "  " « P.second « endl; cout << "Q:  " « Q.first << "  " << Q.second « endl; if  (P > Q) cout « "P > Q\n"; ++Q.first;
cout « "After ++Q.first:  "; if (P == Q) cout « "P == Q\n"; return 0;
}
Большинство программ, использующих STL, будут содержать строчку Mnclude для заголовка, который уже включает внутри себя utility. Напри¬мер, если в нашей программе есть строчка ^include <vector>, не нужно до¬бавлять Mnclude <utility>.
Как показывает эта программа, шаблон pair имеет два параметра, представляющих собой типы членов структуры pair: first и second. Конструк¬тор для pair, используемый для инициализации Р, получает два начальных значения для этих членов. У структуры pair нет конструктора по умолча¬нию; другими словами, нельзя написать
pair<int, double> Р; // ошибка
Вместо того чтобы явным образом передавать два значения конструктору, как это сделано для Р, мы можем использовать уже существующую пару, как показано выше при определении Q
Определив Q, можно было бы присвоить этой переменной другое зна¬чение, написав
Q = pair<int, double>(122, 4.5); Вместо этого мы воспользовались более короткой записью Q = make_pair(122, 4.5);
эквивалентной по своему действию. Для любых двух пар Р и Q значения выражений Р == Q и Р < Q и т. п. согласуются с хорошо известным лекси¬кографическим порядком, как показывают следующие примеры:
(122, 5.5) < (123, 4.5) (123, 4.5) < (123, 5.5) (123, 4.5)  ==  (123, 4.5)
В программе pairs.cpp сначала мы имеем Р> Q, но после увеличения Q.first на единицу Р и Q сравняются, как показывает вывод:
Р: 123 4.5 Q:  122 4.5
Р > Q
After ++Q.first: Р == Q
Сравнения
Когда мы пишем операторы сравнения для наших собственных типов, нам необходимо определить только == и <. Четыре остающихся оператора !=, >, <= и >= автоматически определяются в STL с помощью следующих четырех шаблонов:
template <class Tl, class T2>
inline bool operator!=(const Tl &x, const T2 &y)
{   return !(x == y);
}
template <class Tl, class T2>
inline bool operator>(const Tl &x, const T2 &y)
{   return   у < x;
}
template <class Tl, class T2>
inline bool operator<=(const Tl &x, const T2 &y)
{    return !( у < x);
}
template <class Tl, class T2>
inline bool operator>=(const Tl &x, const T2 &y)
{   return !(x < y);
}
Как видно из примера, эти четыре достаточно общих шаблона определяют !=, >, <= и >= через == и <. Нам не нужно писать эти шаблоны самостоя¬тельно, поскольку они находятся в заголовке functional, который включа¬ется по умолчанию всякий раз, когда мы используем STL.
 
2.9. Снова словари
Поскольку словарь содержит пары (k, d), где k является ключом, a d  сопутствующими данными, можно предположить, что шаблон pair будет по¬лезен при работе со словарями. Как и для последовательного контейнера, для ассоциативного контейнера мы можем использовать итератор г; в этом случае выражение *г будет обозначать пару, в которой (*i).first явля¬ется ключом, a (*i).second - сопутствующими данными. Например, с помо¬щью итератора i для словаря из раздела 2.7 напечатаем все содержимое сло¬варя (ключи в восходящем порядке), применив следующий цикла for.
for (i = D.begin(); i != D.endf); i++) cout   « setw(9)
«  (*i) . second «"  " «  (*i).first « endl;
Заметим, что здесь мы выводим (*i).second перед (*i).first, так что не нужно планировать, сколько позиций зарезервировать для имен в выводе вроде
54321 Papadimitrou, С. 12345 Smith, J.
С таким форматом также удобнее работать при вводе, поскольку в этом случае мы можем прочесть число, пробел и текст до конца строки. Но сле¬дует помнить, что этот текст является ключом, хотя и расположен в конце строки.
Приведенный выше цикл for действительно встречается в программе, которую мы сейчас собираемся рассмотреть. Она опять имеет отношение к телефонному справочнику, но на этот раз можно произвести с ним не¬сколько операций. Чтобы не усложнять программу, в ее интерфейсе мы будем использовать не самые дружественные к пользователю команд, ко¬торые показаны в следующей таблице в виде примеров.
Пример команды	Значение
?Johnson, j.	Показать телефонный номер абонента/о/гизоя,/.
/Johnson, j.	Удалить запись об абоненте Johnson, J. из книги
! 66331 Peterson, к.	Добавить абонента Peterson, К с номером 66331
*	Показать всю телефонную книгу Записать телефонную книгу в файл phone.txt
#	Выход
Когда мы запускаем программу тар2.срр, она делает попытку прочитать данные из файла phone.txt; такой файл, если он существует, должен содер¬жать строчки текста, включающие номер телефона, один пробел и имя, в перечисленном порядке. В именах могут быть пробелы (см. таб¬лицу выше). Пользователь должен вводить имена в той же форме, как они заданы, вместе с пробелами.
Программа тар2.срр основана на обработке строк в стиле языка С. Клю¬чами выступают не сами строки, а указатели на последовательности сим¬волов, хранящихся в памяти. Такой подход может удовлетворить опытных программистов на С, но он является не слишком элегантным и требует с нашей стороны внимания, чтобы не допустить ошибочного выделения либо освобождения памяти. В разделе 2.12 мы рассмотрим бо¬лее простую, хотя, возможно, не столь переносимую версию этой програм¬мы, основанную на библиотечном классе string.
11 map2.срр: Второе приложение, использующее класс
//	тар (словарь): телефонный справочник.
¦include <iostream>
¦include <fstream>
¦include <iomanip>
¦include <stdlib.h>
¦include <string>
¦include <map>
using namespace std;
const int maxlen = 200;
class compare { public:
bool operator()(const char *s, const char *t)const
{   return strcmp(s, t) < 0;
}
};
typedef map<char*, long, compare> directype;
void Readlnput(directype &D) {   if stream ifstr("phone.txt"); long nr;
char buf[maxlen], *p; if (ifstr)
{   cout « "Entries read from file phone.txt:\n"; for (;;) {   ifstr » nr;
ifstr.get(); // пропустить пробел
ifstr.getlinefbuf, maxlen);
if (!ifstr) break;
cout « setw(9) « nr « "  " « buf « endl; p = new char[strlen(buf) + 1]; strcpy(p, buf); D[p]  = nr;
}
}
ifstr.close();
}
void ShowCommands() {   cout «
"Commands:   ?name	: find phone number,\n"
/name	: delete\n"
"	Inumber name: insert (or update)\n"
list whole phonebook\n" save in file\n" exit" « endl;
#
}
void ProcessCommands(directype &D) {   ofstream ofstr; long nr;
char ch, buf[maxlen], *p; directype::iterator i; for (;;)
{   cin » ch;	// Пропустить любой непечатаемый символ
// и прочесть ch.
switch (ch){
case '?': case '/':       // найти или удалить: cin.getlinefbuf, maxlen); i = D.find(buf);
if (i == D.endO) cout « "Not found.\n";
else	// Ключ найден,
if (ch == '?')	// Команда 'Найти'
cout « "Number:  " «  (*i).second « endl;
else	// Команда 'Удалить'
{   delete[]   (*i).first; D.erase(i); }
break;
case '!':	// добавить (или обновить)
cin » nr; if (cin.failO)
{   cout « "Usage:  Inumber name\n";
cin.clearO; cin.getline(buf, maxlen); break;
}
cin.get();	// пропустить пробел;
cin.getlinefbuf, maxlen);
i = D.find(buf);
if (i == D.endf))
{   p = new char[strlen(buf)  + 1];
strcpy(p, buf);
D[p]  = nr; }    else (*i).second = nr; break; case  '*':
for (i = D.begin(); i != D.endf); i++) cout   « setw(9) « (*i).second « "  " «  (*i).first « endl;
break; case ' = ' :
ofstr.open("phone.txt"); if (ofstr)
{    for (i = D.beginf); i != D.endO; i + + ) ofstr << setw(9) «  (*i).second << " "
« (*i).first « endl; ofstr.closef); }   else cout « "Cannot open output file.\n"; break; case '#': break; default:
cout « "Use: *  (list),  ?  (find), = (save),  "
"/  (delete),  !   (insert), or #  fexit).\n"; cin.getline(buf, maxlen); break;
}
if  (ch == '#') break;
}
}
int main()
{    directype D;
Readlnput(D);
ShowCommands();
ProcessCommands(D);
for (directype: : iterator i = D.beginf); i != D.endO;
++i) delete[]   f*i).first; return 0;
}
Чтобы запустить программу на выполнение, нам не требуется наличие входного файлаphone.txt. Для нижеследующего примера работы этой про¬граммы предположим, что такой файл существует и содержит две записи для абонентов Smith, Р. и Johnson, J. Данные, которые вводит пользователь, подчеркнуты. Заметьте: в полном списке телефонной книги, который выводится с помощью команды *, имена появляются в алфавитном поряд¬ке. Помните, что имена являются ключами, хотя и следуют после номеров:
Entries read from file phone.txt:
54321 Smith, P.
12345 Johnson, J.
Commands:     ?name       :  find phone number,
/name	: delete
Inumber name:  insert  (or update)
list whole phonebook
save in file
#	: exit
119723 Shaw. A. *
12345 Johnson, J.
19723 Shaw, A.
54321 Smith, P.
/Johnson, J. *
19723 Shaw, A. 54321 Smith, P. ?Shaw, A. Number:  19723

#
Строки хранятся в памяти, размещаемой с помощью оператора
р = new char[strlen(buf)  + 1] ;
как при чтении строк из входного файла, так и при вводе пользователем. Освобождение строк с помощью
delete[]   (*i). first;
также происходит в двух случаях: когда пользователь вводит команду уда¬ления и при выходе из программы для освобождения ресурсов. Эти опера¬ции не потребуется программировать вручную в версии, которую мы об¬судим в разделе 2.12.
Выражение равенства через отношение -«меньше»
Имеется еще один интересный аспект, относящийся к использованию С-указателей в качестве ключей. Когда в словаре происходит поиск по ключу, можно ожидать, что это осуществляется с помощью оператора эк¬вивалентности —. Теперь предположим, что в нашей программе мы ищем в словаре имя "John" и существует элемент словаря, содержащий этот ключ
"John". Каждый программист на С(++) должен знать, что такой поиск не может быть произведен с помощью оператора ==, поскольку приведет к сравнению адресов, а не самих строк. Вместо == необходимо использо¬вать функцию strcmp. Например, при
char *s = "John", *t = "John";
выражения
s == t
strcmp(s, t) ==0
будут иметь значения 0 (=false) и 1 (=true) соответственно.
В нашей программе сравнение на равенство символьных ключей вы¬полнятся правильно, потому что для этой цели используется класс compare. Если бы потребовалось сравнить два числа, а и Ъ, мы могли бы выразить оператор == через <, заменив
а == Ь
на
!(а < Ь II Ь < а)
Точно так же проверка на равенство двух ключей s и t типа char* осуще¬ствляется в нашей программе следующим образом:
!(compare()(s, t)  II compare()(t, s))
Посмотрев на определение функции operatorC) в классе compare, мы уви¬дим, что это эквивалентно
!(strcmp(s, t) < 0 II strcmp(t, s) < 0)
Хотя наше выражение вычисляется медленнее, оно, в свою очередь, экви¬валентно
strcmp(s, t) ==0
2.10. Функции insert
Добавление новых записей в предыдущем разделе осуществляется с помо¬щью оператора доступа по индексу в следующем выражении
D[p]  = nr;
Вместо этого оператора присваивания мы могли бы написать выражение
D.insert(directype::value_type(р, nr)); которое основано на нашем определении
 
typedef map<char*, long, compare> directype;
и на следующем определении типа value Jype в шаблоне тар, приведен¬ном в заголовке тар:
typedef pair<const Key, Т> value_type;
где Key - тип ключа, а Т - тип сопутствующих данных. Приведенный выше довольно сложный вызов функции insert не имеет преимуществ пе¬ред более простым оператором присваивания, если нас не интересует воз¬вращаемое функцией insert значение. Это значение может дать нам инфор¬мацию о результате процесса добавления элемента в словарь. Давайте посмотрим, как определяется функция insert в заголовке тар:
pair<iterator, bool> insert(const value_type &x);
Очевидно, что insert возвращает объект типа pair, который содержит ите¬ратор, указывающий позицию добавленной (или обновленной) записи и значение типа bool, которое показывает, произошло ли добавление но¬вой записи. Это может быть полезным в некоторых приложениях, но в программе тар2.срр не имеет значения, потому что, когда пользователь вводит имя, мы начинаем с проверки, является ли это имя новым. Если нет, заменяем только телефонный номер, выполняя
(*i).second = nr;
без выделения или освобождения памяти. Напомним, что ключи, пред¬ставляющие имена, являются на самом деле указателями в стиле С.
Рассмотрим теперь другую функцию insert для словарей. Если мы зна¬ем позицию, в которой должен быть расположен новый элемент, эта ин¬формация может быть использована для того, чтобы операция вставки стала более эффективной по времени выполнения. С этой целью можно использовать функцию insert, объявленную как
iterator insert(iterator position, const value_type &x);
Она возвращает итератор, ссылающийся на элемент, который только что был добавлен в словарь; мы можем использовать это значение, если следу¬ющим добавить элемент с большим ключом. Например, если знаем, что элементы будут добавляться по возрастанию ключей, то можем использо¬вать итератор i, как это сделано в следующей программе:
// mapins.cpp: Быстрая вставка в словарь, ¦include <iostream> ¦include <map> using namespace std;
typedef map<int, double, less<int> > maptype;
int main() {   maptype S;
maptype: : iterator i = S.endO;
for (int k=l; k<=10; k++)
i = S.insert(i, maptype::value_type(k,  1.0/k));
i = S.find(4);
cout « (*i).second « endl;  // Вывод: 0.25 return 0;
}
Первый аргумент этой версии функции insert используется как подсказка, указывающая, где следует начинать поиск требуемой позиции. Вставка ускоряется, если новый элемент непосредственно следует за элементом, на который ссылается первый аргумент. В этом случае добавление элемента выполняется за постоянное время. Напротив, если первый аргумент ссыла¬ется на любой другой элемент, вставка все равно осуществляется правиль¬но, но занимает время 0(log N), где N - количество элементов множества.
2.11.	Удаление элементов словаря
Для удаления элементов словаря имеются три функции-члена erase, объявленные следующим образом:
void erase(iterator position);
void erase(iterator first, iterator last);
size_type erase(const key_type &x);
Первую из этих функций мы использовали в разделе 2.9. Вторая функция дает возможность стереть все элементы заданного диапазона. Третью фун¬кцию использовать легче всего, потому что она требует знать значение ключа, а не итератора. Она возвращает 0 или 1, что соответствует числу удаленных элементов. Иными словами, если существует элемент с задан¬ным ключом, функция вернет 1; если нет, она вернет 0.
2.12.	Более удобные строки
До сих пор мы использовали достаточно примитивный способ работы со строками. Например, в программе тар.срр нам необходимо было выпол¬нить два оператора
delete[]   (*i).first; D.erase(i);
чтобы удалить элемент множества, на который ссылался итератор г. Если мы забудем выполнить первый из этих операторов, это приведет к «утечке
 
памяти», потому что сама строка символов останется где-то в памяти (по ад¬ресу, который хранится в (*i).first) без какой-либо возможности использо¬вать эту память после того, как будет выполнен второй из этих операторов. Способ работы со строками был реализован в духе С, а не С++. Ключами наших элементов словаря являлись указатели на область памяти, которая распределялась и освобождалась вручную.
В проекте стандарта С++ определен библиотечный класс string, чтобы упростить манипуляции со строками и уменьшить возможности для со¬вершения случайных ошибок. Класс string не является частью STL и сей¬час поддерживается не всеми компиляторами. Иными словами, програм¬мы, использующие этот класс, на текущий момент не являются переносимыми. Но есть надежда, что ситуация изменится в будущем. Сей¬час мы рассмотрим некоторые свойства класса string, который поддержи¬вается как ВС5, так и VC5.
Чтобы иметь возможность определять переменные класса string, необ¬ходимо использовать следующую строку ttinclude:
¦include <string>
и на этот раз мы не вправе написать <string.h> вместо <string>. Если ваш компилятор не принимает этот заголовок, он может поддерживать заголо¬вок bstringk или cstring.h, который вы должны использовать в таком слу¬чае. Иногда эти заголовки нужно включать перед заголовками STL. После этого мы можем написать следующие операторы присваивания:
string s, t ; s = "ABC"; t = "DEFGH" ;
s = t;	// s = "DEFGH"
s = 'A' ;       // s = "A"
Как показывает приведенный фрагмент, с правой стороны этих присваи¬ваний может находиться значение одного из трех типов:
•	string (как в s = t;);
•	char* (как в s = «АБС»;);
•	char (как в s = «Л»;).
То же относится и к оператору +=, применяющемуся для добавления вто¬рого операнда к концу первого, который должен принадлежать к типу string.
string s, t("KLM"), u(t);
// s = "", t = u = "KLM"
s += t;	// s = "KLM"
S += "PQR";  // S = "KLMPQR" S +=  'A';      // S = "KLMPQRW"
Этот фрагмент, кроме того, показывает, что мы можем инициализировать строку с помощью значения типа char* либо string.
Существуют два других способа инициализации строк. Первый - ука¬зать повторитель; например, начальное значение s будет «АААА», если мы напишем
string s(5,   'А');
Второй способ - использовать два итератора, например:
string t(v.begin(), v.endO), u(a, а+3);
где v имеет тип vector<char>, а а является массивом символов, первые три элемента которого используются для инициализации и.
Класс string имеет функцию-член c_str(), возвращающую указатель типа const char*, который можно применить в выражениях со строками С. Например, после
string s("АВ"); char а[10]; strcpy(a, s.c_str());
мы имеем
а[0] = 1А1 а[1] = 'В' а[2] = "\0'
Как в случае с вектором, мы можем получить текущий размер строки с помощью функции-члена size. Например, после определения s в выше¬приведенном фрагменте имеем
s.size() = 2
Есть много интересных способов работы со строками, некоторые из них используются в следующей программе:
// strdemo.cpp: Программа, демонстрирующая возможности
//	класса string.
¦include <iostream> ¦include <string>
using namespace std;
int main()
{   string s(5,  'A'), t("BC"), u;
u = s + t;
cout « "u = s + t = " « u « endl;
cout << "u.sizeO = " « u.size() « endl;
cout « nu[6] = " « u[6] « endl;
cout « "Enter two new strings s and t:\n"
cin >> s » t;
cout « "s.sizeO = " « s.size() « endl; cout « (s < t ? "s < t"  :  "s >= t"); cout << endl; return 0;
}
Эта программа показывает, что для соединения двух строк можно исполь¬зовать оператор + (как и обсужденный выше оператор +=). Для ввода и вывода определены операторы >> и «, и ведут они себя так же, как и для обычных строк. Это справедливо и для оператора доступа по индек¬су [], как показано при выводе значения и[6]. И наконец, для сравнения строк мы можем применить операторы ==, !=, <, >, <= и >=, как показано на примере оператора <. Ниже дан пример работы этой программы, в котором подчеркнут текст, введенный пользователем:
u = s + t = АААААВС u.sizeO = 7 u[6] = С
Enter two new strings s and t: xxxxx xxy s.sizeO = 5 s < t
Несмотря на различные возможные длины строк, экземпляры класса string могут быть элементами массивов и контейнеров STL, например:
// strelem.cpp: Строки С++ в качестве элементов
//      списка L и массива а.
¦include <iostream>
¦include <string>
¦include <list>
¦include <algorithm>
using namespace std;
int main()
{ string s("One"), t("Two"), u("Three"); list<string> L L.push_back(s) L.push_back(t) L.push_back(u) string a[3];
copy (L. begin () , L.endO, а);
for (int k=0; k<3; k++) cout « a[k] « endl; return 0;
}
Как легко предсказать, вывод этой программы будет следующий:
One Two Three
Теперь давайте займемся применением класса string для второго способа решения задачи, рассмотренной в разделе 2.9. Вспомним, что программа тар2.срр сперва пыталась прочесть файл phone.txt, чтобы использовать его в качестве телефонного справочника. Если такого файла не существует, с помощью данной программы его можно создать. Программа mapla.cpp отличается тем, что она не использует операторы new и delete для строк в стиле С, а вместо этого - новый тип string. Комментарии, начинающиеся с // !, указывают, чем эта программа отличается от mapl.cpp:
II тар2а.срр:   Вторая версия телефонного справочника,
//	использующая тип 'string'.
¦include <iostream>
¦include <fstream>
¦include <iomanip>
¦include <string>
¦include <map>
using namespace std;
//  !
typedef map<string, long, less<string> > directype;
// Прочитать все символы до '\п' и сохранить их в str,
// за исключением '\п', который будет прочитан, но не сохранен.
void getaline(istream &is, string &str)
{   char ch;
str = "";	III
for  (;;)
{   is.get(ch);
if  (is.fail()   II ch == '\n') break;
str += ch;
}
}
void Readlnput(directype &D) {   ifstream ifstr("phone.txt"); long nr;
string str;	//  !
if (ifstr)
 
Более удобные строки
 

{   cout « "Entries read from file phone.txt:\n";
for (;;)
{    ifstr >> nr;
ifstr.get();  // пропустить пробел
getaline(ifstr, str);	// !
if (!ifstr) break;
cout « setw(9) « nr « " " << str << endl;
D[str]  = nr;	//  !
}
 
}
 
 
ifstr.closet);



find phone number,\n" delete\n"
insert (or update)\n" list whole phonebook\n" save in file\n" exit" « endl;
}
void ProcessCommands(directype &D) {   ofstream ofstr; long nr;
string str;	//  !
char ch;
directype::iterator i; for (;;)
{   cin >> ch;   // пропустить пустые символы //и прочитать ch
switch (ch){
case '?': case '/': // найти или удалить: getaline(cin, str);
i = D.find(str);	11 \
if (i == D.endO )
cout « "Not found.\n";
else	// Ключ найден,
if (ch == '?')     // Команда 'Найти'
cout << "Number:  " « (*i).second « endl;
else	// Команда 'Удалить'
D.erase(i);	// !
break;
case '!1:	// добавить (или обновить)
cin >> nr; if (cin.failO)
{   cout « "Usage:  'number name\n";
 
cin.clear(); getaline(cin, str) ; break;
 

// !
 

 
// пропустить пробел;
cin.get();	//
getaline(cin, str); D[str]  = nr; break;
 


//  !
 
case
for (i = D.beginf); i != D.endO; i++) cout   << setw(9) << (*i).second << << (*i).first « endl;
break; case ' =' :
ofstr.open("phone.txt"); if (ofstr)
{   for (i = D.beginf); i != D.endO; i++)
ofstr « setw(9) « (*i).second « " " « (*i).first « endl; ofstr.close(); }   else cout « "Cannot open output file.\n"; break; case '#': break; default:
cout « "Use: * (list), ? (find), = (save), "
"/  (delete),  !  (insert), or # (exit).\n";
getaline(cin, str); break;	// !
if (ch == '#') break;


int main()
{   directype D;
Readlnput(D);
ShowCommands();
ProcessCommands(D) ;
return 0;	//I

Поскольку поведение этой программы не отличается от поведения началь¬ной версии, mapl.cpp, опустим пример ее работы. Эта версия проще в том отношении, что мы оперируем с объектами класса string таким же образом, как со встроенными типами, например int, несмотря на различные длины строк. Так как память для этих строк размещается и освобождается автома¬тически, в программе не встречаются операторы new и delete.
 
 


Последовательные контейнеры

3.1. Векторы и связанные с ними типы
Когда идет речь о шаблонах вообще и STL в частности, новички бывают сбиты с толку сложным синтаксисом этих выражений. Мы начнем с об¬суждения синтаксиса, приводя примеры, которые не всегда имеют прак¬тическое значение, но полезны тем, что позволяют в нем разобраться.
Во второй главе книги мы использовали тип value Jype при работе с ассоциативными контейнерами. Он определен также для последователь¬ных контейнеров. В классе vector указанный тип определен достаточно простым способом:
typedef Т value_type;
в то время как в классе тар определение этого типа следующее:
typedef pair<const Key, Т> value_type;
В любом случае мы видим, что valuejtype означает тип элементов, содержа¬щихся в контейнере. Поскольку его определение находится внутри рассмат¬риваемого класса, при использовании в другом контексте мы должны ква¬лифицировать имя valuejtype, например таким образом:
vector<int>::value_type;
 
Из предыдущего обсуждения следует, что эта усложненная запись обозна¬чает просто тип int. Другими словами, если мы используем заголовок vector, то можем заменить строчку
int к;
на
vector<int>::value_type к;
Вряд ли эта форма более удобна, но отсюда видно, что запись vector<int>lvalue_type не содержит ничего мистического.
Перечисленные ниже типы могут быть использованы точно таким же образом, как типы, определенные одним идентификатором:
vector<int>::iterator vector<int>::reverse_iterator vector<int>::const_iterator vector<int>::const_reverse_iterator
Вспомним, что мы рассматривали первые три из этих четырех типов в разделах 1.2 и 1.3. Четвертый, очевидно, может быть использован для прохождения контейнера в обратном порядке без изменения его элемен¬тов. Например, после
typedef vector<int>::iterator VecIntlterType;
мы можем заменить
vector<int>::iterator i;
на более простое выражение
VecIntlterType i; Вот полный список вложенных типов:
value_type
reference, const_reference
iterator, const_iterator
reverse_iterator, const_reverse_iterator
difference_type
size_type
vector_allocator
Их имена хорошо объясняют их назначение. Нам потребуется большин¬ство из этих типов при обсуждении функций-членов контейнеров. Далее рассмотрим два оператора доступа по индексу для векторов, которые мо¬гут быть объявлены в шаблоне vector следующим образом: reference operator[](size_type n);
const_reference operator[](size_type n) const;
Если мы имеем дело с типом vector<int>, тип reference означает int&, или ссылку-на-целое. Тип difference type представляет собой целочисленное значение со знаком, которое может использоваться для представления раз¬ности между двумя итераторами, a size Jype отличается от difference _type только тем, что является беззнаковым типом.
Тип vector<bool>
Векторы, состоящие из элементов типа bool, представляют собой особый случай, чтобы обеспечить их эффективное размещение: выделение целого слова на каждый элемент, которому достаточно одного бита, было бы не¬экономным расходованием памяти. Очевидно, особый подход к типу bool возможен только тогда, когда он является встроенным типом, а не сино¬нимом типа int. Напомним, что эта тема затрагивалась нами в разделе 1.1.
Функция-член flipQ определена для типа vector<bool>, но не для vector<int>. Она обращает значение всех либо выбранного бита в векторе, как показывает следующий пример:
vector<bool> b(100); // 100 бит, все установлены в 0. b.flipO; // Все биты инвертированы и сейчас равны 1. Ь[73] .flipО ;
cout « b[72]  « b[73]  « b[74];  // Вывод:  101
Также существует функция-член swap для перестановки двух булевских векторов. Например:
vector<bool> u(100, true), v(50,  false); u.swap(v);
cout   << u.sizeO << " " << v.size() << "  "
« u[0];	// Вывод:  50 100 0
Следующая программа использует булевский вектор для реализации ре¬шета Эратосфена. Это хорошо известный эффективный способ нахожде¬ния простых чисел 2, 3, 5, 7, 11, 13,... Все элементы булевского вектора S, решета, сначала равны true, а впоследствии некоторые из них принимают значение false:
S[i] = true означает:       i может быть простым числом (делители пока
не найдены);
S[i] = false означает:      i не есть простое число (поскольку является
кратным меньшего простого числа).
Чтобы уменьшить объем выводимых данных, программа не показывает длинный список простых чисел. Вместо этого она подсчитывает количе¬ство простых чисел, меньших заданного значения N, а также печатает наи¬большее из них:
// erastos.cpp: Решето Эратосфена для нахождения
//	всех простых чисел, меньших заданного предела.
iinclude <iostream> iinclude <vector> iinclude <math.h>
using namespace std;
int main() {   cout «
"To generate all prime numbers < N, enter N: "; long N,  i, sqrtN, count = 0, j; cin >> N;
sqrtN = int(sqrt(N)) + 1; vector<bool> S(N, true);
// Вначале все S[i] равны true.
// S[i] = false только и когда
//мы обнаруживаем, что i не есть простое.
for  (i=2;  i < sqrtN; i++) if (S[i])
for (int j=i*i; j<N; j+=i) S[j] = false;
for (i=2; i<N; i++)
if (S[i])  {j = i; count++;}
cout   « "There are " « count
« " prime numbers less than N.\n"; cout   « "Largest prime number less than N is "
« j << "." « endl; return 0;
}
Ниже следует пример результатов работы этой программы, который пока¬зывает, что количество найденных простых чисел действительно может быть слишком большим для того, чтобы показать их все на экране:
То generate all prime numbers < N, enter N: 1000000 There are 78498 prime numbers less than N. Largest prime number less than N is 999983.
Время, которое потребовалось на выполнение примера, составило около 10 секунд на компьютере с процессором 80486; это показывает, что решето
 
Эратосфена позволяет очень быстро находить простые числа. Также этот пример показывает, что булевские векторы не только очень удобны, но и эффективны.
3.2. Функции capacity и reserve
До сих пор мы принимали как данность, что векторы имеют переменный размер, не беспокоясь о том, как это реализовано. Теперь предположим, что мы хотим добавить к вектору элемент, так что размер этого вектора вырас¬тет на 1. Если такое будет происходить часто, то неэффективно было бы каждый раз перераспределять память, потому что это может потребовать ко¬пирования всех элементов в область памяти, в которой размещается увели¬ченный вектор. Гораздо лучше выделить больше памяти, чем требуется, так что во многих случаях дополнительная память уже будет иметься в нали¬чии, когда возникнет необходимость в увеличении размера вектора. Число элементов вектора v, для которых выделена память, называется емкостью вектора и равняется значению выражения
v. capacity()
Это значение больше или равно значению vsizeQ, как показано на рисунке 3.1.




v.begin()	v.end()

	
v.size()			
v.capacityQ	


Рисунок 3.1. Размер и емкость вектора v

Следующая программа демонстрирует, что значение v.capacityQ остается постоянным относительно долго, пока вектор v постепенно растет, a vsizeQ увеличивается на единицу каждый раз, когда к v добавляется новый элемент:
// capacity.срр:   Функция-член capacity
//	для векторов.
¦include <iostream> ¦include <iomanip> ¦include <vector>
using namespace std;
int main()
{   vector<int> v;
vector<int>::size_type nO = 12345, nl;
cout << "v.size()    v.capacity()\n";
for  (long i=0L; i<100000L; i++) {   nl = v.capacity О; if (nl != nO)
{   cout   << setw(8) << v.sizeO << "	"
<< setw(8) << nl << endl; nO = nl;
}
v.push_back(123); // v.sizeO увеличивается на 1
return 0;

В этой программе размер вектора v вырастает от 0 до 99 999. Число эле¬ментов вектора, для которых выделена память, v.capacityQ показывается каждый раз, когда это значение изменяется по сравнению с прошлым ша¬гом. Значения, которые хранятся в векторе, не имеют отношения к нашей текущей задаче, все элементы вектора равны 123. В начале работы про¬граммы вектор пуст и значение vsizeQ, как и v.capacityQ, равно нулю. Пос¬ле добавления первого элемента значение vsizeQ становится равным 1, но v.capacityQ, количество элементов, для которых зарезервирована память, равно некоторому большему значению. Для ВС5 это значение 256, для не¬которых других версий STL оно равно 1024. При, казалось бы, неэффек¬тивном расходовании памяти такая схема имеет преимущество в том, что потребуется много времени, прежде чем возникнет необходимость в перераспределении памяти, поскольку емкость, равная, допустим, 256, исполь¬зуется для всех размеров вектора 1, 2, 3, 256. Только когда значение vsizeQ станет равным 257, нам потребуется перераспределить память. Для используемой здесь реализации STL емкость после этого удвоится, чтобы хватило памяти для размеров 257, 258,512. Принцип удвоения емкости соблюдается при всех перераспределениях памяти, как показывает следу¬ющий вывод программы, откомпилированной с помощью ВС5:
v.sizeO    v.capacityO
 
0 1
257 513 1025 2049 4097
0
256 512 1024 2048 4096 8192
8193 16385 32769 65537
16384 32768 65536 131072
 
Функция capacity возвращает информацию о распределении памяти; су¬ществует связанная с ней функция reserve, которая позволяет контроли¬ровать это распределение. После выполнения вызова
v.reserve(п);
значение v.capacityQ будет равно по меньшей мере п. Функция reserve мо¬жет ускорить выполнение программы, если мы знаем заранее, сколько эле¬ментов будет содержать вектор v. Например, если в программе capacity.cpp добавить строчку
v.reserve(100000);
непосредственно перед циклом for, вывод этой программы будет содержать только две следующие строчки:
v.sizeO    v.capacity!)
 
0
 
100000
 
Выделение памяти произойдет всего один раз. После этого вызова reserve в векторе хватит места для всех 100 ООО элементов, которые будут добав¬лены в операторе for.
Перераспределение памяти, значения итераторов и функция reserve
Когда в результате роста происходит перераспределение выделенной па¬мяти для вектора v, что приводит к увеличению значения v.capacityQ, то, как правило, любые итераторы, ссылающиеся на элементы вектора v, ста¬новятся недействительными. Это станет ясно, если считать итераторы ука¬зателями, которые хранят адреса элементов. Перераспределение памяти может потребовать, что весь вектор будет перемещен в другие участки па¬мяти, и мы не можем ожидать, что использовавшиеся с этим вектором ите¬раторы автоматически обновятся. Например:
vector<int> v, w;
vector<int>::iterator i; v.push_back(0); i = v.begin() ;
for  (long k=lL; k<100000L; k++)
v.push_back(k) ; cout «  (*i);    // ???
В последней строке этого фрагмента i ссылается на участок памяти, кото¬рый может уже не принадлежать вектору v. Как если бы мы захотели наве¬стить старого знакомого по адресу, где он когда-то проживал, но сейчас там живут другие люди. Однако есть исключения; если вторая строчка этого фрагмента (обозначенная тремя точками) содержит оператор
v.reserve(N);
где N > 100 ООО, тогда в цикле for не произойдет перераспределения памя¬ти и значение i останется равным v.beginC).
Как видно из раздела 1.9, мы можем использовать выражения i + nui - п, где i является итератором, an- целым, для векторов (а также для двусторон¬них очередей, но не для списков). Это дает возможность правильно запомнить позиции в векторе:
vector<int> v; vector<int>::iterator i; int k;
for (...) v.push_back(...); i =
k = i - v.begin));	// *i == v[k]
for (...) v.push_back(...);
// Расширение v может привести к перераспределению памяти,
// что сделает *i неопределенным.
i = v.begin() + к;	// *i == v[k] снова
// Итератор i ссылается на тот же элемент, что и до этого,
// хотя этот элемент, возможно, находится в другом месте
// памяти
Как отмечается в комментарии, нам нет необходимости использовать ите¬раторы для доступа к элементам вектора: оператор доступа по индексу [], который применяется к массивам, определен также и для векторов, поэто¬му в конце этого фрагмента мы можем написать v[k] вместо *i. В общем случае можно писать
v[k]   вместо    * (v.begin() + к)
Функция-член вектора erase, рассмотренная в разделе 1.3, также делает недействительными все итераторы, ссылающиеся на элементы вектора, расположенные после удаляемого, поскольку эти элементы будут передвину¬ты, чтобы заполнить пробел, возникший при выполнении операции erase.
3.3. Обзор функций-членов класса vector
Ниже перечислены все функции-члены класса vector с кратким описанием или ссылкой на соответствующий раздел. Эти объявления могут содержаться
 
в заголовке motor, хотя многие функции-члены полностью определены, а не только объявлены в этом заголовке.
iterator begin О; iterator end(); void push_back(const T& x) ; reverse_iterator rbeginO; reverse_iterator rendO;
Рассмотрены в разделе 1.2.
const_iterator begin() const; const_iterator end() const;
Рассмотрены в разделе 1.3 на примере списков.
const_reverse_iterator rbegin() const; const_reverse_iterator rend() const;
Для прохождения в обратном порядке в режиме «только для чтения».
size_type size О const; size_type capacity() const; void reserve(size_type n) ;
Рассмотрены в разделе 3.2.
size_type max_size() const;
Очень большое целое число (порядка 1 073 741 823), показывающее, до каких размеров может вырасти вектор.
bool empty() const;
Позволяет определить, пуст ли вектор.
vector();	//	(1)
vector(size_type n, const T& value = TO);	//	(2)
vector(const vector<T>& x);	//	(3)
vector(const_iterator first, const_iterator	last);    //	(4)
-vector();
Четыре конструктора и деструктор. Эти конструкторы	используются
в следующих примерах:
vector<int> v;	// (1) Конструктор по умолчанию
vector<int> w(5, -3);        // (2) Создает 5 элементов,
 
//
 
все они равны -3
 
vector<int> w(5); vector<int> wl(w);
// (2) Создает 5 элементов
 
vector<int> w2(w.begin()+1, w.begin() + 5);
//  (4) Копирует четыре элемента //        из w в w2
reference operator[](size_type n);
const_reference operator[](size_type n) const;
Операторы доступа по индексу используются в
w[3]  = 3 * w[2]  + 1;
vector<T>& operator=(const vector<T>& x);
Оператор присваивания используется в
vector<int> w(5, -3), v; v = w;
reference front(); reference back(); const_reference front() const; const_reference back() const;
Эти функции обеспечивают доступ к первому и последнему элементам вектора. Например, можно написать:
vector<int> v;
for  (int i=10; i<15;  i++) v.pushjoack(i); v.front()  = 1000;
cout << v.front()  << "  " << v.back() << "  "; cout << "Size = " << v.sizeO << endl; // Вывод: 1000 14 Size = 5
void swap(vector<T>& x);
Мы можем написать либо
v.swap(w) ; или
w.swap(v);
чтобы поменять местами векторы v и w одного типа (но необязательно одного размера).
iterator insert(iterator position, const T& x);
Служит для вставки элемента в заданной позиции. Эта и следующие функции insert занимают время 0(п), где п - количество элементов, на¬ходящихся после вставляемого элемента; напомним, что эти элементы должны быть передвинуты, чтобы освободить место для вставляемых.
Функция возвращает итератор, который ссылается на вставленный эле¬мент. Например, фрагмент кода
vector<int> v;
for (int k=10; k<15; k++) v.push_back(k) ; vector<int>::iterator i = v.begin() + 1, j; j = v.insert(i, 123);
copy (v.begin () , v.endO,        // См. раздел 1.9.
ostream_iterator<int>(cout, " ")); cout «endl; cout « "j refers to " « *j << endl;
дает следующий вывод:
10 123 11 12 13 14 j refers to 123
void insert(iterator position, const_iterator first, const_iterator last);
позволяет нам вставить более одного элемента за раз. Вставляемые эле¬менты могут быть заданы любым действительным диапазоном [first, last) элементов требуемого типа. Вот пример:
vector<int> v;
for (int k=0; k<5; k++) v.push_back(k);
int a[3] = {100, 200, 300};
v.insert(v.begin() + 1, a, a+3);
// Содержимое v: 0 100 200 300 1 2 3 4
void insert (iterator position, size_type n, const T& x);
Эта функция служит для вставки нескольких одинаковых элементов, равных третьему аргументу, х. Например:
vector<int> v;
for (int k=0; k<5; k++) v.push_back(k); int initvalue = -1;
v.insert(v.begin() +1, 4, initvalue); // Содержимое v: 0-1-1-1-11234
void pop_back();
void erase(iterator position);
См. раздел 1.3.
void erase(iterator first, iterator last);
Удаляются элементы диапазона [first, last), как показывает следующий пример: vector<int> v;
for (int k=0; k<7; k++) v.push_back(10 * k);
// Содержимое v: 0, 10, 20, 30, 40, 50, 60 v.erase(v.begin()+2, v.begin0+5);
// Содержимое v: 0, 10, 50, 60
Обе функции erase занимают время 0(n), где n - число элементов, кото¬рые следуют за удаляемыми элементами. Если нам нужно удалить не¬сколько последовательных элементов вектора, мы должны использовать один вызов последней функции erase, поскольку это значительно быстрее, чем несколько раз вызывать предпоследнюю функцию, которая удаляет по одному элементу за раз.
3.4. Двусторонние очереди
Различные типы контейнеров очень похожи в отношении способов их применения. Например, каждый из трех типов контейнеров (vector, deque и list) определяет конструктор, который использует в качестве параметров число повторений и значение, например:
vector<double> v(100, 12.34); deque<double> D(100, 12.34); list<double> L(100, 12.34) ;
Каждое из этих объявлений создает последовательность, состоящую из 100 экземпляров значения 12.34. Из примера следует, что можно сократить наше обсуждение двусторонних очередей и списков, ограничившись рас¬смотрением специфических свойств этих контейнеров и делая ссылку на векторы относительно общих аспектов.
Наше обсуждение двусторонних очередей в разделах 1.3 и 1.9 позволя¬ло сделать вывод, что эти структуры данных обладают только преимуще¬ствами перед векторами. Кроме функций-членов, определенных для век¬торов, они определяют функции-члены push_front и pop_Jront. Так как одна из существенных характеристик двусторонней очереди - это возмож¬ность расти и сокращаться с двух сторон, кажется естественным реализо¬вать двустороннюю очередь с помощью двусвязного списка. Однако в STL двусторонняя очередь реализована по-другому, поскольку, что удивитель¬но, двусторонняя очередь в STL обеспечивает произвольный доступ к элементам за постоянное время. На чем основана такая реализация? Рису¬нок 3.2 дает набросок модели реализации. Элементы двусторонней очереди размещаются в блоках фиксированного размера. Кроме этого, хра¬нится массив указателей на эти блоки. Заштрихованные области блоков действительно используются контейнером, а белые области означают вы¬деленную, но неиспользуемую память.
 
 

Рисунок 3.2. Возможная реализация двусторонней очереди D

Выполнение
D.push_front(х);
предполагает, что элемент х помещается слева от позиции, обозначенной D.beginQ. Эта вставка в начале D заставляет первую стрелку i сместиться влево. После того как эта операция выполнится несколько раз, первый из блоков, изображенных на рисунке, станет заполненным. Тогда будет разме¬щен новый блок, указатель на который будет помещен в позицию 1 массива, изображенного слева. Когда и этот блок заполнится, будет выделен следую¬щий блок, указатель на который займет место в позиции 0 массива. Может показаться, что должна возникнуть проблема, когда после нескольких до¬полнительных вставок и этот блок также заполнится. Однако с этой пробле¬мой можно справиться с достаточной эффективностью, перераспределив па¬мять для массива указателей. Когда у нас появятся пять блоков, мы выделим память под больший массив указателей, в котором будут использоваться только пять элементов в середине, что даст возможность снова расширять структуру с обоих концов. Легко видеть, что вставка в конце (а не в начале) работает по сходным механизмам.
Не существует гарантий, что после вставки элементов итераторы, кото¬рые ссылаются на двусторонние очереди, останутся действительными. На¬помним, что это утверждение справедливо и для векторов, как мы видели в разделе 3.2. Так как все блоки на рисунке 3.2 обладают одинаковой дли¬ной, адрес элемента двусторонней очереди может быть вычислен за посто¬янное время; другими словами, двусторонние очереди предоставляют про¬извольный доступ к своим элементам. Мы даже можем использовать применяемую для массивов запись
D[k]   вместо    *(D.begin() + к)
Учитывая более сложную схему распределения памяти, можно ожидать, что операции с двусторонними очередями будут выполняться несколько медленнее, чем операции с векторами. Это объясняет логику, по которой в STL имеются обе эти структуры: функции push _front и pop _Jront, выпол¬няющиеся за постоянное время, доступны для двусторонних очередей, но не для векторов, но большинство тех операций, которые определены для обоих контейнеров, вероятно, будут выполняться несколько быстрее для векторов по сравнению с двусторонними очередями.
Для двусторонних очередей не определены функции reserve и capacity (см. раздел 3.2), но есть функция-член size, и, как обычно,
D.sizeO эквивалентно  D.end - D.beginO
Большинство функций двусторонних очередей ведут себя так же, как их аналоги для векторов (см. раздел 3.3). Вот несколько объявлений функ¬ций-членов класса deque, которые отсутствуют в классе vector.
void push_front(const T& x); void pop_front(); reference front();
Например, предположим, у нас имеются вектор v и двусторонняя очередь D, оба непустые и хранящие элементы одного и того же типа. Тогда следу¬ющий фрагмент заменяет последний элемент v первым элементом D, пос¬ле чего первый элемент D стирается:
v.back() = D.front(); D.pop_front();
3.5. Списки
Как известно, преимущество списков перед векторами и двусторонними очередями заключается в том, что вставка и удаление элементов в любой
 
Списки
 
 
позиции происходит за постоянное время, а недостаток заключается в от¬сутствии произвольного доступа к элементам. Список STL может быть просто реализован в виде двусвязного списка, как показано на рисунке 3.3. Поскольку каждый узел этого списка содержит ссылку на предыдущий и последующий узлы, операции — и ++ для итераторов будут выполнять¬ся эффективно, то есть за постоянное время. Напротив, передвижение от узла к узлу, отстоящему на п позиций в списке, потребует времени 0(п).
 
Рисунок 3.3. Двусвязный список
Чтобы вставить узел в середине списка, требуется присвоить новые значе¬ния четырем указателям, содержащимся в узлах, два из них будут указы¬вать на этот узел (от правого и левого соседа), и два других из самого узла - на его соседей. Остальные узлы останутся незатронутыми, отсюда и следует, что вставка в любой позиции происходит за постоянное время. Удаление узла происходит с той же эффективностью.
Если узлы добавляются в список, все итераторы, ссылающиеся на узлы этого списка, продолжают оставаться действительными; как мы знаем, для векторов и двусторонних очередей это правило не соблюдается.
Многие функции-члены, такие как конструкторы и функции вставки, используются так же, как и функции векторов и двусторонних очередей, но, как мы только что упоминали, для списка добавление элементов зани¬мает постоянное время. У списка отсутствует оператор доступа по индек¬су [], ведь доступ по индексу связан с итераторами произвольного досту¬па, а итераторы списка только двунаправленные.
Функции-члены sort и unique
В разделе 1.4 было сказано, что алгоритм sort не работает со списками. Вме¬сто этого для списков определена функция-член sort. Другой специфичной для списка функцией-членом является unique, которая удаляет повторяю¬щиеся последовательные элементы. Эти две функции определены в клас¬се list таким образом:
void sort(); void unique();
 
Последовательные контейнеры
 

Следующая программа демонстрирует использование этих функций:
// listl.cpp: Функции-члены класса list: sort и unique, ¦include <iostream> iinclude <list> using namespace std;
void out(char *s, const list<int> &L) {   cout « s;
copy (L.beginO , L.endO,
ostream_iterator<int>(cout, " "));
cout << endl;
}
int main()
 
{   list<int> L(5, 123) ; L.pushJoack(lOO) ; L.push_back(123); L.push_back(123); out("Initial contents: L.unique();
out("After L.unique(): L.sort();
out ("After L.sortO : return 0;
}
Вывод этой программы показывает, что функция unique учитывает только последовательные элементы, в результате получается два элемента 123: один до и другой после элемента 100.
Initial contents: 123 123 123 123 123 100 123 123 After L.unique(): 123 100 123 After L.sortO:      100 123 123
Если бы мы вызвали две функции-члена в другом порядке
L.sortO; L. unique О; окончательный результат содержал бы всего два элемента
100 123 Сцепка
Другая операция, специфичная для списков,- сцепка (splicing), перемеще¬ние одного или более последовательных элементов из одного списка в другой, без освобождения либо выделения памяти для этих элементов. Существуют три функции-члена splice, которые объявлены в классе list так, как показано ниже. В сопутствующем обсуждении 1иМ означают список одного и того же типа:
void splice(iterator position, list<T>& x);
 
Если i является допустимым итератором для L, следующая операция вставляет содержимое М перед г в список L и оставляет М пустым. Эта операция не работает, если 1иМявляются одним и тем же списком:
L.splice(i, М); void splice(iterator position, list<T>& x, iterator j);
Если i является допустимым итератором для L, aj - таковым для М, сле¬дующая операция удаляет элемент, на который ссылается j, и вставляет его перед i. Эта операция работает, даже если L и М являются одним и тем же списком:
L.splice (i , М, j) ;
void splice(iterator position, list<T>& x, iterator first, iterator last);
Если i является допустимым итератором для L, а \jl,j2) является допу¬стимым диапазоном для М, следующая операция удаляет элементы это¬го диапазона и вставляет их перед i в L. Эта операция также работает, если L и М являются одним и тем же списком:
L.splice(i, М, jl, J2);
 
50   60   70   80
10
Мы покажем, как работает последняя из функций splice, изменив список так, как изображено на рисунке 3.4.

Рисунок 3.4. Сцепка

Элементы 20, 30, 40 из последовательности 10, 20, 30, 40, 50, 60, 70, 80 перемещаются на новое место между 60 и 70. Результатом является последо¬вательность
10 50 60 20 30 40 70 80
которая совпадает с выводом нижеследующей программы:
// splice.срр: Сцепка, iinclude <iostream> iinclude <list> using namespace std;
int main()
{    list<int> L;
list<int>::iterator i, jl, j2, j;
for (int k = 10; k <= 80; k += 10)
{   L.push_back(k); j = L.end();
if (k == 20) jl = --j; else if (k == 50) j2 = --j; else if  (k == 70)  i = --j;
}
L. spliced, L,  jl, j2); copy(L.begin(), L.end(),
ostream_iterator<int>(cout,  " ")); cout << endl; return 0;
}
Обратим внимание на оператор
i = —-j;
и подобные ему в этой программе. Мы не можем заменить его на
i = j - 1;
потому что операторы «плюс» и «минус» не определены для двунаправ¬ленных итераторов (см. раздел 1.9). Здесь требуется использовать опера¬тор —, так как итераторе = L.end() ссылается на позицию после последне¬го элемента, который был добавлен с помощью pushjback. Вместо решения с тремя операторами if мы могли бы использовать алгоритм find, заменив довольно сложный цикл for, приведенный выше, на следующий фрагмент:
for (int k = 10; k <= 80; k += 10)
L.push_back(k); jl = find(L.begin() , L.endO, 20); j2 = find(L.begin() , L.endO,  50); i = find(L.begin() , L.endO, 70);
Данный фрагмент вполне приемлем для короткой последовательности, ис¬пользуемой в этой программе, но решение, приведенное в полном приме¬ре, более эффективно для очень длинных последовательностей.
Стоит вспомнить, что алгоритмы, такие как find, объявлены в заголов¬ке algorithm, поэтому мы могли бы написать
iinclude <algorithm>
в начале нашей программы. Для ВС5 этот заголовок включается косвенным образом такими заголовками, как vector или list, поэтому мы опустили эту строчку, полагая, что другие современные версии STL ведут себя аналогично.
Функция-член remove класса list
Когда нам требуется удалить все элементы списка с заданным значением, ре¬шение в два этапа, использующее алгоритмы remove и erase, рассмотренное в разделе 1.13, является не самым эффективным. Гораздо лучше для этой цели подойдет функция-член remove, определенная для списков. Она объявлена в шаблонном классе list следующим образом:
void remove(const Т& value);
Эта функция специфична для списков; она не определена как член для векторов и двусторонних очередей. Следующая программа показывает, что remove довольно проста в использовании:
// remove.срр: Функция-член remove класса list, iinclude <iostream> iinclude <list> using namespace std;
void out(const char *s, const list<int> &L) {   cout « s;
copy(L.begin() , L.endO,
ostream_iterator<int>(cout,  " "));
cout « endl;
}
int main()
{   list<int> L;
list<int>::iterator new_end;
L.push_back(l); L.push_back(4); L.push_back(l); L.push_back(3); L.push_back(l); L.push_back(2); out("Initial sequence L:\n", L); L.remove(l);
out("After L.remove(1):\n", L); return 0;
}
Вывод программы:
Initial sequence L: 14 13 12 After L.remove(l): 4 3 2
Функция-член reverse класса list
Класс list определяет также функцию reverse, объявленную следующим образом:
void reverse();
Эта функция-член, определенная только для списков, но не для векторов и двусторонних очередей, использует в своих целях устройство списка. По¬этому для списка L предпочтительнее употреблять вызов функции-члена
L.reverse();
нежели вызов алгоритма reverse
reverse (L.begin() , L.endO);
Функция-член merge класса list
Объединение для списков может быть выполнено более эффективно, чем для векторов или двусторонних очередей, поскольку требуется копиро¬вать только ссылки, а не сами элементы. Класс list содержит следующее объявление функции-члена merge:
void merge(list<T>& x);
Приведенная далее программа показывает, как использовать эту функцию:
// lstmerge.cpp: Объединение списков
//	с помощью функции-члена merge.
iinclude <iostream>
iinclude <list>
using namespace std;
void out(const char *s, const list<int> &L) {   cout « s;
copy (L. begin () , L.endO, ostream_iterator<int>(cout, " ")); cout « endl; }
int main()
{    list<int> LI, L2, L3;
list<int>::iterator new_end;
Ll.pushJoack(lO); LI.push_back(20); Ll.push_back(30); L2.push_back(15); L2.pushjoack(35); out("Initial sequence Ll:\n", LI); out("Initial sequence L2:\n", L2); LI.merge(L2);
out("After LI.merge(L2):\n", LI); return 0;
}
Эта программа выводит:
Initial sequence LI: 10 20 30
 
Initial sequence L2: 15 35
After Ll.merge(L2): 10 15 20 30 35
Последняя строчка вывода показывает новый список L1, в то время как L2 становится пустым. Хотя имя функции merge совпадает с именем алгорит¬ма merge, последний работает по-другому (см. раздел 1.7).
3.6. Векторы векторов
До сих пор в наших примерах излюбленным типом был vector<int>. Впол¬не очевидно, что мы можем заменить int на другой тип и использовать vector<double>, vector<char> и т. п. А вправе ли мы использовать более сложный тип, чем int, double и char, между двумя угловыми скобками? На¬пример, можно ли написать
vector<vector<int> > А;
Да, возможно, как в следующей программе:
// vecvec.срр: Вектор векторов.
iinclude <iostream> iinclude <vector>
using namespace std;
int main()
{   vector <int>'v;
v.push_back(8); v.push_back(9);
vector<vector<int> > A;
A.push_back(v);
A.push_back(v);
A.push_back(v);
for  (int i=0;  i<3;  i++)
{    for  (int j=0;  j<2;  j++)
cout « A[i][j] « "  "; cout « endl;
}
return 0;
}
Программа использует вектор А, состоящий из трех элементов, каждый из которых является вектором, содержащим два целых числа 8 и 9. Мы мо¬жем считать вектор А двумерным массивом, или матрицей, как показыва¬ет вывод этой программы:
8 9 8 9 8 9
Однако такой подход может привести к тому, что нам потребуется больше памяти, чем действительно необходимо. Довольно часто программисты на С и С++ используют вместо двумерных массивов массивы указателей. Точ¬но так же можно использовать вектор указателей, реализованный в следую¬щей программе, вывод которой совпадает с предыдущей:
// pointers.срр: Вектор указателей, ¦include <iostream> ¦include <vector> using namespace std;
typedef vector<int> vecint;
int main()
{   vector<vecint*> A; int a[2] = {8, 9}; A.push_back(new vecint(a, a+2)); A.push_back(new vecint(a, a+2)); A.push_back(new vecint(a, a+2)); for (int i=0; i<3; i++) {    for  (int j=0; j<2; j++)
cout «  (*A[i])[j] « " cout « endl;
}
delete A[0]; delete A[l]; delete A[2]; return 0;
}
Каждый элемент вектора A, A[i] является указателем на вектор из двух
элементов целого типа, так что	является этим вектором, содержащим целые значения, доступ к которым осуществляется с помощью выра¬жения



1 Следует иметь в виду, что предложенный автором второй вариант реализации двумерного массива с помощью вектора указателей не только менее эффективен по времени выполнения и менее защищен от случайного неправильного выделения/освобождения памяти (см. раздел 3.7), но в случае плотно заполненной мат¬рицы может фактически использовать больше памяти, чем первый вариант, ис¬пользующий вектор из векторов! В реальных программах на С++ подобных приемов следует избегать. - Прим. переводчика.
 
3.7. Как избавиться от явного выделения памяти
Как было отмечено в разделе 1.14, в сложных программах к частым ошибкам приводит освобождение памяти с помощью free или delete. В данных ниже определениях функций нельзя обойтись без использования упомянутых выра¬жений. Если же мы забудем сделать это, возникнет так называемая утечка памяти, то есть динамически выделенная память не будет освобождена:
void f(int n) {   double *a;
a = (double*)malloc(n * sizeof(double));
...	// Используем a[0],	a[n-l].
free(a);	// Во избежание утечки памяти
}
либо
void f(int n) {   double *a;
a = new double[n];
...	// Используем a[0],	a[n-l].
delete[] а;       //Во избежание утечки памяти
}
Нам следует также заботиться о том, чтобы не разместить область памяти более одного раза и, если память была выделена при выполнении какого-либо условия, не пытаться освободить ее без проверки условия.
Используя STL, мы можем избежать использования malloc и new, при¬меняя контейнер vector. Преимущество этого подхода заключается в сни¬жении риска неправильного использования free или delete. Например, вме¬сто рассмотренной выше функции мы можем написать
¦include <vector> void f(int n)
{   vector<double> a(n);      // См. раздел 3.3.
...	// Используем a[0],	а[п-1].
}
Освобождение памяти теперь осуществляется деструктором контейнера. Векторы как члены классов
Векторы также можно использовать вместо определенных внутри классов массивов, которые размещаются и освобождаются явным образом. Рас¬смотрим для примера следующий код, использующий явное выделение и освобождение памяти: class Т { public:
T(int n){а = new double[n];} ~T(){delete[] a;}
double *a;
};
Здесь мы опять пишем delete[] а для предотвращения утечки памяти. Если для выделения памяти использовать конструктор вектора, то можно обойтись без явного освобождения памяти, как демонстрирует следующая программа:
// vecmem.cpp: Вектор - член класса, ¦include <iostream> ¦include <vector> ¦include <numeric> using namespace std;
template <class eltype> class objtype { public:
objtypefint n=0): a(n){}
vector<eltype> a;
};
int main() {   int n, i;
double s=0;
cout « "Enter n:  ";
cin >> n; // n is a positive integer
objtype<double> x(n);
for (i=0;  i<n; i++) x.a[i]  = i;
s = accumulate(x.a.begin(), x.a.endf), s);
cout   « s « " = " « double(n-1)*n/2 << endl;
return 0;
}
Объекта:содержит массив о из и значений типа double, где п вводится пользо¬вателем. Для заполнения этого массива мы используем значения 0,1,п - 1. Далее вычисляем сумму элементов массива, применяя алгоритм accumulate, который был рассмотрен в разделе 2.1. Другими словами, мы получим
0+1 + 2 + ... + п-1- У2я(я - 1)
Указанная сумма вычисляется двумя способами, так что легко прове¬рить результат, полученный с помощью алгоритма accumulate. Вот пример использования этой программы для нахождения значения У2х 100000 х 99999 = 4999950000 - 4.99995 х 109:
Enter п: 100000 4.99995е+09 = 4.99995е+09
Не требуется определять конструкторы копирования и операторы присваивания
Еще одним преимуществом использования вектора в качестве члена клас¬са является то, что копирование и присваивание экземпляров класса бу¬дет осуществляться правильно без необходимости определения конструк¬тора копирования и оператора присваивания. Следующая программа, основу которой составляет только что использованный класс, иллюстри¬рует это поведение:
// simple.срр: Не нужен ни конструктор копирования,
//	ни оператор присваивания,
¦include <iostream> iinclude <vector> iinclude <numeric> using namespace std;
template <class eltype> class objtype { public:
objtype(int n=0): a(n, 0){ } vector<eltype> a;
};
int main() {   int i; double s;
objtype<double> x(3), y(x);
// Или, если использовать присваивание,
// а не инициализацию:
//       objtype<double> х(3), у;
//       У = х;
x.atl] = 123;
copy(х.a.begin(), x.a.endf),
ostream_iterator<double>(cout, " ")); cout « endl;
copy (у. a. begin () , y.a.endO,
ostream_iterator<double>(cout,  "  ") ) ; cout « endl; return 0;
Вывод
0 123 0 ООО
этой программы со всей очевидностью показывает, что объекты х я у не зависят друг от друга: начальное значение у (0, 0, 0) никуда не исчезает, когда присваиваем х другое значение. Если бы мы выделили память в конструкторе objtype с помощью оператора new, проведение инициализа¬ции, как выше, с использованием «глубокого» копирования начального значения х для у потребовало бы написать конструктор копирования. Для приведенной версии программы в этом нет необходимости, поскольку ис¬пользуется конструктор копирования класса vector, определенный в STL. Точно так же нет необходимости писать свой оператор присваивания, что отмечено в комментарии к тексту программы.
 
 


Ассоциативные контейнеры

4.1. Введение
Из раздела 2.5 мы узнали, что существуют четыре типа ассоциативных кон¬тейнеров: множества, множества с дубликатами, словари и словари с дубли¬катами. Множества и множества с дубликатами характеризуются двумя па¬раметрами шаблона, а словари и словари с дубликатами - тремя:
template <class Key, class Compare>
class set { ...
};
template <class Key, class Compare>
class multiset {  ...
};
template <class Key, class T, class Compare>
class map { ...
};
template <class Key, class T, class Compare>
class multimap { ...
);
Полностью определения этих шаблонных классов помещены в заголовках set и тар.
 
О переносимости
Если вы используете старую версию HP STL, вам придется включать за¬головки set.h и map.h для множеств и словарей, а для вариантов этих кон¬тейнеров с дубликатами - соответственно multiset.h и multimap.h.
Сравнение и прочие функциональные объекты
Программисты, начинающие изучать STL, могут посчитать функциональные объекты трудными для понимания. Это отчасти вызвано применением слож¬ных конструкций языка С++, которые редко используются большинством программистов. В дополнение к нашему обсуждению в разделе 1.12 рассмот¬рим эту тему более подробно. Начнем с напоминания, что выражение
int()
имеет в качестве значения целочисленную константу 0, отсюда следует, что два нижеприведенных выражения эквивалентны:
х = 0;
х = int();
Для нестандартного типа, например Т, выражение ТС) возвращает объект типа Т, как показывает следующая программа:
// gen_t.срр: Создаем объект Т О. ¦include <iostream.h>
class Т { public:
T(){i = 123;}
int i ;
};
int main О
{   int j = T О.i;
cout « j << endl;  // Вывод: 123
return 0;
}
Вспомним, что, если за именем типа (в нашем примере это Т в функции main) следует пара круглых скобок без параметров, это приводит к вызову конструктора по умолчанию для создания объекта. Конструктор по умол¬чанию не имеет параметров, либо все его параметры имеют значение по умолчанию. В этом примере мы определяем такой конструктор для класса Т. Если бы мы этого не сделали, а также не определили бы никаких других конструкторов для Т, компилятор создал бы за нас конструктор по умол¬чанию, эквивалентный Г(){}.
По-другому обстоят дела, когда круглые скобки следуют не за именем типа, а после объекта; например, когда для объекта и типа U мы использу¬ем выражения вроде следующих:
и()
и(1, 2, 3)
Оба этих выражения разрешены только в том случае, если мы определяем соответствующие операторы вызова функции, описываемые как operatorQ, например:
// call_op.cpp: Два оператора вызова.
¦include <iostream.h>
class U { public:
char operator()()
{   return 'Q';
}
int operator()(int a, int b, int c)
{   return a + b + c;
}
};
int main() {   U u;
cout « nu() = " « u() « endl;
cout « "u(l, 2, 3) = " « u(l, 2, 3) « endl;
return 0;
}
Результат этой программы следующий: u() = Q
u(l, 2, 3) = б
В программе call_op.cpp определены два оператора вызова. Первый не име¬ет параметров и возвращает тип char, а второй принимает три параметра и возвращает тип int.
Схожесть выражений Г() и м() в двух наших последних программах об¬манчива. Поскольку Т- это тип, а и- объект, выражение Г() стоит ближе по смыслу к выражению и, когда Т сопровождается скобками, а и нет; как Т(), так и и являются объектами. Если бы мы определили для класса Г те же операторы вызова, что и для U, тогда выражения
ТОО
ТО (1, 2, 3) имели бы смысл.
В следующей программе LessThan является типом, как Т в предыдущем обсуждении, и поэтому LessThanQ представляет собой объект, a LessThanQ(2, 3) обозначает вызов функции:
// lessthan.срр: Функциональный объект LessThan. ¦include <iostream.h>
class LessThan { public:
int operator!)(int x, int y)
{   return x < y;
}
};
int main()
{   LessThan b;
cout   « "b(2, 3)  = " « b(2, 3) « endl;
cout   « "LessThan()(2, 3) = " « LessThan()(2, 3) « endl;
return 0;
}
Эта программа печатает
b(2, 3) = 1 LessThan()(2, 3) = 1
Мы использовали класс LessThan для сравнения целых чисел. Можно сде¬лать этот класс более общим, определив шаблонный класс less_than для сравнения двух объектов, принадлежащих к одному типу, для которого определен оператор <, как в следующей программе:
// lt_templ.cpp: Шаблонный класс для сравнения по условию "меньше".
¦include <iostream.h>
template <class T> class less_than { public:
int operator!)(const T &x, const T &y)
{   return x < y;
}
};
int main()
{   less_than<int> b;
cout « "b(2, 3) = " « b(2, 3) « endl; cout   « "less_than<double>()(2.1, 2.2) = "
« less_than<double>()(2.1, 2.2) « endl; return 0;
 
Результат программы: Ь(2, 3) = 1
less_than<double>()(2.1, 2.2) = 1
В последней строчке less_than<double> является типом, a less_than<double>Q -объектом этого типа. Наконец, less_than<double>Q (2.1,2.2) является вызовом функции-члена operatorQ этого объекта.
Все это облегчит понимание выражений наподобие
settype SI(less<int>()) ;
которые встретятся нам в следующем разделе. Приведенный пример явля¬ется определением переменной 51. В этом определении объект less<int>Q (типа less<int>) передается в качестве параметра конструктору класса settype.
4.2. Функции-члены множеств
У класса set имеются три конструктора, которые могут быть определены следующим образом внутри класса:
set(const Compare& comp = Compare))); // 1 (по умолчанию) set(const value_type* first, const value_type* last,
const Compare& comp = CompareO);   111
set(const set<Key, Compare>& x);	// 3  (копирования)
Идентификатор Compare в приведенных объявлениях обозначает пара¬метр шаблона, который является типом. Как мы показали в предыдущем разделе, это означает, что CompareQ является объектом. Следующая про¬грамма использует все три конструктора:
// setconst.срр: Конструкторы для множеств.
¦include <iostream> ¦include <set>
using namespace std;
typedef set<int, less<int> > settype;
void out(const char *s, const settype &S) {   cout « s;
copy(S.begin(), S.endf),
ostream_iterator<int>(cout,  " "));
cout << endl;
}
int main()
{   int a[3]  = {20, 10, 20); settype SI;
 
settype S2(а, а+3);	112
settype S3(S2);	//3
 
out("SI: out("S2: out("S3: return 0;
}
 
SI) S2) S3)
 
Несмотря на то что для конструирования 52 используется диапазон [а, а + 3) из трех элементов, в множество попадают только значения а[0] ис[1], из-за того что значение третьего элемента массива, а[2], равно а[0]. Вывод программы:
 
si
S2 S3
 

10 20 10 20
 
Аргумент, задающий функцию сравнения, нами опущен, поэтому исполь¬зуется значение по умолчанию less<int>(). Другими словами, программа имела бы то же самое действие, если бы мы написали:
settype SI(less<int>());	// 1
settype S2(a, a+3, less<int>());	// 2
Обратите внимание, что третий конструктор (помеченный комментарием // 3) является конструктором копирования, который используется не только для инициализации переменных, но и для копирования аргумен¬тов (если значения передаются не по ссылке), и в операторе return.
Следующие две функции-члена возвращают функциональный объект для сравнения элементов множества. Оба типа key compare и valuecompare яв¬ляются синонимами параметра Compare шаблонного класса set.
key_compare key_comp() const; value_compare value_comp() const;
Приведенный ниже пример, хотя и не является слишком реалистичным, показывает применение этих функций:
cout   « "settype::value_compare()(2, 3) = "
« settype::value_compare()(2, 3) « endl;
Если бы мы вставили такое непривычное выражение в функцию main про¬граммы setconst.cpp, то получили бы следующую строчку на выводе:
settype::value_compare()(2, 3) = 1
Перечисленные ниже функции-члены аналогичны по своему назначению одноименным функциям последовательных контейнеров: iterator begin!) const; iterator end() const; iterator rbeginf)  const; iterator rendO const; bool empty)) const; size_type sized const; size_type max_size() const; void swap(set<Key, Compare>& x);
В программе setconst.cpp Sl.size() = 0, a SlsizeC) = 2. Как обычно, функция maxsizeC) возвращает очень большое значение, например 3 214 748 364.
В разделе 2.10 на примере словарей мы рассматривали функцию insert, которая возвращает пару, составленную из итератора и булевского значе¬ния. Такая же функция существует и для множеств, и объявлена она так:
pair<iterator, bool> insert(const value_type& x);
Возвращаемое функцией значение содержит итератор, указывающий на позицию значения х после добавления в рассматриваемое множество, а также значение типа bool, которое равно true в том случае, если произош¬ло добавление х ко множеству, или false, если значение х уже присутство¬вало в множестве.
Вторая функция insert в качестве первого аргумента принимает итера¬тор; этот итератор используется как подсказка, указывая на позицию, пос¬ле которой следует добавить новое значение. Вставка происходит быстрее всего, если имеется возможность добавить новое значение непосредствен¬но после позиции, на которую указывает первый аргумент. Эта функция объявлена следующим образом:
iterator insert(iterator position, const value_type& x);
И наконец, существует функция insert, которая позволяет добавить сразу диапазон значений:
void insert(const value_type* first, const value_type* last);
Мы можем использовать эту функцию, когда нужно добавить в множество последовательный ряд элементов массива, как, например, в следующей программе:
// insrange.cpp: Добавление диапазона значений, ¦include <iostream> ¦include <set> using namespace std;
int main()
{   int a[3]  = {20, 10, 20};
set<int, less<int> > S;
S.insert(a, a+2) ;
copy(S.begin(), S.endf),
ostream_iterator<int>(cout, " "));
cout « endl;	// Вывод 10 20
return 0;
}
Для удаления элементов множества определены три функции:
void erase(iterator position);	// 1
size_type erasefconst key_type& x);	// 2
void erase(iterator first, iterator last);    // 3
Если мы знаем позицию удаляемого элемента, рекомендуется использо¬вать первую функцию. Если известно только значение этого элемента, мы используем вторую; эта функция возвращает количество удаленных эле¬ментов, как правило 1, но может равняться 0, если нужное значение отсут¬ствует в множестве. Последняя из трех функций удаляет диапазон значе¬ний [first, last). Можно, следовательно, удалить все элементы множества S и сделать S пустым, написав
S.erase(S.begin() , S.endO);
Поскольку элементы множества уникальны (не может быть двух равных элементов), функция count, объявленная как
size_type count(const key_type& x) const;
возвратит либо 0, либо 1. Например, если множеством целых чисел явля¬ется S, выражение S.count( 123) принимает значение 1, когда 123 входит в множество S, и 0, когда не входит.
Следующие три функции осуществляют поиск заданного значения х в множестве:
iterator find(const key_type& х) const; iterator lower_bound(const key_type& x) const; iterator upper_bound(const key_type& x) const;
Как обычно, после выполнения
i = S.find(x);
значение i равно S.endQ, если x не найдено, в противном случае *i равняет¬ся х. Чтобы найти минимальный диапазон [i,j) из множества S, содержа¬щий х, мы можем написать i = S.lower_bound(x); j = S.upperjoound(x);
Для примера предположим, что S состоит из целых чисел 30, 40 и 50. Таб¬лица ниже содержит значения i и j для разных значений х. Строки, в которых х = 25, 35, 45 и 55, показывают, что вызовы функций S.lower_bound(x) и S.upper_bound(x) возвращают равные значения итера¬торов, если S не содержит х. Напротив, значения 30, 40 и 50 показывают, что возвращаемые итераторы различны, когда S содержит хг.
х	i = S.lower_bound(x);	j - S.upper_bound(x);
25	*i = 30	*j = 30
30	*i = 30	*j = 40
35	*i = 40	*j - 40
40	*i = 40	*j = 50
45	*i = 50	*j - 50
50	*i = 50	j = S.endQ
55               i = S.endC)	j = S.end()
Функция equal range возвращает рассматриваемую пару за один вы¬зов. Объявление этой функции дано ниже:
pair<iterator, iterator> equal_range(const key_type& x) const;
Вместо того чтобы вызывать отдельно lower Jbound и upper bound, как мы делали это выше с помощью операторов
i = S.lower_bound(x); j = S.upper_bound(x);
более эффективно находить г и j с помощью equaljrange, как в приведен¬ной ниже программе:
// eqrange.cpp: Функция-член equal_range. iinclude <set> iinclude <iostream> using namespace std;
int main()
{   typedef set<int, less<int> > settype; typedef settype::iterator iterator; settype S; S.insert(30); S.insert(40); S.insert (50) ;
pair<iterator, iterator> P;
iterator i, j;
int x = 30;
P = S.equal_range(x);
i = P.first; j = P.second;
cout « *i « " " « *j « endl; // Вывод: 30 40 return 0;

4.3. Объединение и пересечение множеств
В этом разделе мы рассмотрим известные математические операции на¬хождения пересечения и объединения двух множеств, которые проиллюс¬трированы на рисунке 4.1.
 
Рисунок 4.1. Пересечение и объединение двух множеств

Для обозначения операций пересечения и объединения мы будем исполь¬зовать операторы * и +, хотя в математике обычно используются обозначе¬ния Пии. Для двух множеств S и Т пересечение S * Т определяется как множество, состоящее из элементов, входящих одновременно в оба множе¬ства S и Т, а объединение S + Т - как множество, содержащее все элементы, входящие либо в S, либо в Г, либо в оба этих множества. Следующая про¬грамма показывает, как можно определить операторы * и + для множеств:
// intuniol.срр: Пересечение и объединение множеств.
iinclude <iostream>
iinclude <set>
iinclude <algorithm>
using namespace std;
typedef set<int, less<int> > settype;
settype operator*(const settype &S, const settype &T) {   settype I;    // Пересечение.
set_intersection(S.beginO , S.endf), T.begin(), T.endf),
 
inserter(I, I.beginO));
return I;
}
settype operator+(const settype &S, const settype &T) {   settype U;    // Объединение set_union(   S.begint), S.endO,
T.begin(), T.end(),
inserter(U, U.begin()));
return U;
}
void out(const char *s, const settype &S) {   cout « s;
copy (S .begin () , S.endO,
ostream_iterator<int>(cout, " "));
cout « endl;
}
int main()
{   int aS[3]  = {10, 20, 30}, aT[4] = {20, 30, 40, 50};
settype   S(aS, aS + 3) ,
T(aT, aT + 4);
out("S =	", S);
out("T =	", T);
out("S * T = ", S * T); out("S + T = ", S + T) ; return 0;
}
В соответствии с примером на рисунке 4.1 программа выводит результаты:
S	=	10 20 30
Т	=	20 30 40 50
S	* Т = 20 30
S	+ Т = 10 20 30 40 50
Определение операторов * и + с помощью функции insert вместо алгорит¬мов set intersection и setjunion является полезным упражнением. Такие варианты этих операторов приведены ниже; если их использовать в рас¬смотренной выше программе, результат ее работы не изменится:
// Две функции, которые мы могли бы использовать, // если бы не существовало алгоритмов set_union // и set_intersection:
settype operator*(const settype &S, const settype &T) {   settype I;    // Пересечение settype::iterator
firsts = S.beginf), lasts = S.endO,
firstT = T.beginO, lastT = T.endf),
i = I.begin(); while (firsts != lasts && firstT != lastT) {   if (*firstS < *firstT)  ++firstS; else
if  (*firstT < *firstS) ++firstT; else
{   i = I.insert(i, *firstS++); ++firstT;
}
}
return I;
}
settype operator+(const settype &S, const settype &T) {   settype U;    // Объединение settype::iterator
firsts = S.beginf), lasts = S.endO, firstT = T.beginO, lastT = T.endf), i = U.begin(); while (firsts != lasts && firstT != lastT) i = U.insert(i,
(*firstS < *firstT ? *firstS++ : *firstT++)); while (firsts != lasts) i = U.insertfi, *firstS++); while (firstT != lastT) i = U.insertfi, *firstT++); return U;
}
Безусловно, предпочтительнее использовать оригинальные, более простые версии этих функций.
Для нахождения пересечения и объединения двух множеств нет необхо¬димости, разумеется, применять операторы * и +, что показывает следую¬щая программа, эквивалентная рассмотренной выше; данная версия более эффективна, так как не требует копирования возвращаемых функциями множеств:
// intunio2.срр: Пересечение и объединение множеств.
iinclude <iostream>
iinclude <set>
iinclude <algorithm>
using namespace std;
typedef set<int, less<int> > settype;
void out(const char *s, const settype &S) {   cout << s;
copy (S.beginf) , S.endO,
ostream_iterator<int>(cout, " "));
cout « endl;
 
int main()
{   int aS[3]  = {10, 20, 30}, аТ[4] = {20, 30, 40,  50}; settype   S(aS, aS + 3),
T(aT, aT + 4), prod, sum;
out("S =	", S); out("T =	", T);
set_intersection(S.begin(), S.endO,
T.beginO, T.endf), inserter (prod, prod, begin ())) ; out("S * T = ", prod); set_union(S.begin(), S.end(),
T.beginO, T.end() .inserter (sum, sum. begin ())) ; out("S + T = ", sum); return 0;
}
Алгоритмы set intersection и setjunion не ограничены в использовании кон¬тейнерами типа множеств, а могут быть применены и к другим сортиро¬ванным структурам, как показано далее в разделе 7.3.8.
4.4. Отличия множеств с дубликатами от просто множеств
Мы уже обсуждали множества и множества с дубликатами в разделе 2.6, и не мешает снова обратиться к тексту программы multiset.cpp, приведен¬ному в том разделе. Напомним, что каждый элемент множества уникален, в то время как множества с дубликатами могут содержать несколько эк¬земпляров одинаковых элементов. Из-за этого одна из функций insert для множеств с дубликатами определена проще, чем для множеств. Как видно из раздела 4.2, для множеств существует функция insert, объявленная как
pair<iterator, bool> insert(const value_type& x); // set
Вспомним, что эта функция возвращает пару, состоящую из итератора и значения типа bool, которое равно false, когда операция добавления за¬вершается неудачей из-за того, что значение х уже присутствует в множе¬стве. Напротив, добавление элемента в множество с дубликатами всегда проходит успешно, так что нет необходимости возвращать признак типа bool. Поэтому соответствующая функция для множества с дубликатами возвращает просто итератор в соответствии со следующим объявлением:
iterator insert(const value_type& x); // multiset
Все остальные функции для множеств с дубликатами объявлены точно так же, как и функции для множеств, если не считать отличием замену имени класса set в объявлении на multiset. Функция find для множеств с дубликатами в случае успеха возвращает итератор, ссылающийся на пер¬вый из элементов с искомым значением, как видно из программы:
// msfind.срр: Поиск в множестве с дубликатами, iinclude <iostream> iinclude <set>
using namespace std;
typedef multiset<int, less<int> > multisettype; typedef multisettype::iterator Iterator;
void out(Iterator first, Iterator last) {   for (Iterator i = first; i != last; ++i) cout « *i « " "; cout << endl;
}
int main()
{   int a[5] = {10, 20, 20, 20, 30}; multisettype M(a, a + 5); out (M.begin() , M.endO);
cout « "Subrange starting at element 20:\n"; out(M.find(20) , M.endO ) ; return 0;
}
Программа выводит
10 20 20 20 30
Subrange starting at element 20: 20 20 20 30
Из этого видно, что возвращаемый функцией find итератор указывает на первый найденный элемент. Если бы вызов M.find(20) завершился неуда¬чей из-за отсутствия в множестве с дубликатами М элемента со значением 20, этот вызов возвратил бы значение M.endQ.
4.5. Словари
У словарей существуют три конструктора, объявленные следующим образом:
map (const Compares comp = Compared);	// 1
map(const value_type* first, const value_type*	last,
const Compares comp = Compared);	//2
maptconst map<Key, T, Compare>& x);	// 3
Программа ниже показывает, как используется каждый из этих конструкторов:
// mapcstr.cpp: Конструкторы словаря iinclude <iostream> iinclude <map> using namespace std;
 
typedef map<int, double, less<int> > maptype; typedef pair<int, double> Pair;
int main()
{   pair<int, double> a[3] = {   Pair(20, 1.5) , Pair(800, 0.3) , Pair(3, 0.2)
//	1 (начинаем с пустого словаря)
//	2  (инициализируем массивом)
//	3 (используем MB для
//       инициализации)
//	МС[800] = МВ[800] = 0.3
};
maptype MA; maptype MB(a, a + 3) ; maptype MC(MB);
cout « MC[800] « endl; return 0;
}
Инициализация словаря MB записывается проще, чем инициализация массива пар а, который служит для нее основой. С помощью конструктора копирования (помеченного комментарием // 3 в начале этого раздела) мы определяем словарь МС как копию словаря MB.
Для словаря очень полезен оператор доступа по индексу []. Мы можем использовать его не только для извлечения данных из словаря, как в преды¬дущей программе для словаря МС, но и для добавления новых данных.
Например, вместо использования массива а в предыдущей программе мы могли бы добавить данные в MB более простым способом, как в следующей программе:
// mapsubs.cpp: Использование индекса для словаря, iinclude <iostream> iinclude <map> using namespace std;
typedef map<int, double, less<int> > maptype;
int main()
{   maptype MB;
MB[20] = 1.5;
MB[800]  = 0.3;
MB[3]  = 0.2;
cout « MB[800] « endl;  // 0.3 return 0;
}
Доступ по индексу является отображением ключей (20, 800 и 3) на свя¬занные с ними значения (1.5, 0.3 и 0.2), как показано на рисунке 4.2.
Рисунок 4.2. Отображение ключей на значения

При доступе по индексу к обычному массиву мы используем последовательные значения индекса 0,1.2 и т. д., которые нет необходимости сохранять где-либо, поскольку элементы массива размещаются непрерывно друг за другом. В противоположность этому как ключи, так и соответствующие значения словарей хранятся в сбалансированном двоичном дереве поиска (см. пример на рис. 4.3). В двоичных деревьях поиска удобно искать ключи (на рисунке 4.3 они подчеркнуты) из-за принципа построения таких деревьев: для каждого узла все ключи в левом поддереве меньше ключа в этом узле, а в правом поддереве все ключи больше.




 


 
Рисунок 4.3. Сбалансированное двоичное дерево поиска, служащее для представления словаря

Функции-члены insert для словарей
Вместо доступа по индексу мы можем добавлять элементы словарей с помощью трех функций-членов insert, объявленных как:
pair<iterator, bool> insert(const value_type& x) ; interator insert(iterator position, const value_type& x); void insert(const value_type* first, const value_type* last);
Они похожи на функции insert для множеств, о которых говорилось в раз¬деле 4.2, но в этом объявлении тип valuejtype более сложный, потому что каждый элемент является парой (ключ, значение). Как видно из программы mapcstr.cpp в предыдущем разделе, мы можем использовать конструктор класса pair<int, double> для создания такой пары. Например, вместо
МВ[800]  = 0.3;
можно написать
MB.insert(pair<int, double>(800, 0.3));
не используя значение, возвращаемое функцией insert. Однако добавления с помощью этой функции не происходит, если ключ уже присутствует в словаре.
Следующая программа показывает, как можно использовать возвращае¬мое этой функцией значение. Она создает словарь, содержащий только один элемент (800, 0.3). Попытка заменить этот элемент на элемент (800, 0.7) не приводит к успеху, потому что их ключи совпадают:
// mapins.cpp: Значение, возвращаемое функцией insert
//	класса тар.
iinclude <iostream> iinclude <тар> using namespace std;
typedef map<int, double, less<int> > maptype; typedef maptype::iterator Iterator;
void MyInsert(maptype &M, int k, double x) {   pair<Iterator, bool>
P = M.insert(make_pair(k, x));
Iterator i = P.first;
bool b = P.second;
cout   << "After attempt to insert (" << k << ", " << x
« "), returning P = (i, b):\n"; cout   « "(*i).first = " << (*i).first << endl; cout   << "(*i).second = " << (*i).second << endl; cout   << "b = " << b « endl << endl;
}
int main() {   maptype M;
MyInsert(M, 800, 0.3);
MyInsert(M,  800, 0.7);
return 0;
}
Вывод этой программы выглядит следующим образом:
After attempt to insert (800, 0.3), returning P = (i, b):
(*i).first = 800
(*i).second = 0.3 b = 1
After attempt to insert  (800, 0.7), returning P = (i, b):
(*i).first = 800
(*i).second = 0.3 b = 0
Каждая операция вставки в этой программе возвращает пару (г, Ь), где i -итератор, ссылающийся на вставленный элемент, а Ъ - значение типа bool, показывающее, успешно ли прошла операция. Две последние строчки при¬веденного выше вывода программы показывают, что элемент (800, 0.7) не был добавлен в словарь: значение С*'i).second по-прежнему 0.3, а не 0.7, а Ъ равно 0 (=false). Если мы хотим добавить элемент (k, х), заменив элемент с тем же значением к, при наличии такого в словаре, просто напишем
М[к] = х;
В функции Mylnsert мы могли бы заменить выражение
pair<int, double>(k, х)
на
maptype::value_type(k, х) Стоит отметить, что мы не использовали запись
i->first вместо
(*i).first
Эта упрощенная запись оказалась бы допустимой, если переменная i была бы указателем, однако она является итератором, для которого не опреде¬лен оператор ->.
Для удаления элементов словаря мы можем использовать три функции erase, объявленные следующим образом:
void erase(iterator position);
size_type erase(const key_type& x);
void erase(iterator first, iterator last);
Эти функции аналогичны соответствующим функциям множеств, поэто¬му мы не станем их подробно обсуждать. То же относится к функциям find, count, lower bound и upper bound.
4.6. Словари с дубликатами
Как стало ясно из раздела 2.7, словари с дубликатами отличаются от просто словарей тем, что они допускают два и более элементов с одинаковыми клю¬чами. Рисунок 4.4 показывает возможное представление словаря с дублика¬тами. Это дерево не может служить представлением словаря, потому что существуют два элемента с одним и тем же ключом, равным 3.
 
Словари с дубликатами
 
125
 

  vv   
Рисунок 4.4. Сбалансированное двоичное дерево поиска, служащее для пред¬ставления словаря с дубликатами
Конструкторы словарей с дубликатами аналогичны конструкторам сло¬варей, поэтому мы не станем их здесь рассматривать, а сосредоточимся на отличиях словарей с дубликатами от словарей. Например, мы не можем заменить строчку
D.insert(mmtype::value_type("Johnson, J.", 12345));
из программы multimap.cpp в разделе 2.7 на
D["Johnson, J."]  = 12345;  // ???
Функции insert и erase для словарей с дубликатами объявлены следующим образом:
iterator insert(const value_type& x);
iterator insert(iterator position, const value_type& x); void   insert(const value_type* first, const value_type* last);
void erase(iterator position);
size_type erase(const key_type& x);
void erase(iterator first, iterator last);
Эти функции подобны своим аналогам для словарей, за исключением пер¬вой функции insert, которая возвращает просто итератор, ссылающийся на новый элемент. Так как добавление происходит успешно, даже если уже присутствует элемент с тем же ключом, нет необходимости возвращать до¬полнительно булевское значение, свидетельствующее об успехе операции.
Обратим внимание на порядок, в котором элементы с одинаковыми ключами добавляются в словарь с дубликатами. Его демонстрирует сле¬дующая программа:
// mmapins.cpp: Добавление элементов в словарь
//	с дубликатами.
iinclude <iostream> iinclude <map>
using namespace std;
typedef multimap<int, double, less<int> > multimaptype; typedef multimaptype::iterator Iterator;
void Mylnsert(multimaptype &M, int k, double x) {   Iterator i = M.insert(make_pair(k, x));
cout <<  (*i).first « "  " «  (*i).second;
// Эквивалентно:
// cout << k << "  " « x;
cout << " inserted\n";
}
int main() {   multimaptype M;
MyInsert(M, 800, 0.3)
Mylnsert(M, 800, 0.7)
Mylnsert(M, 800, 0.5)
Mylnsert(M, 100, 1.9)
Mylnsert(M, 800, 0.6)
cout << "Multimap traversal:\n";
for (Iterator i = M.begin(); i != M.endO; + + i)
cout << (*i).first << " " « (*i).second << endl;
return 0;
}
Результат работы программы mmapins.cpp показывает, что порядок элемен¬тов с одинаковыми ключами в словаре с дубликатами совпадает с порядком, в котором они были добавлены в указанный контейнер. В противополож¬ность этому разные ключи следуют в возрастающем порядке, вне зависимо¬сти от порядка их добавления.
800, 0.3 inserted 800, 0.7 inserted 800, 0.5 inserted 100, 1.9 inserted 800, 0.6 inserted Multimap traversal: 100, 1.9 800, 0.3 800, 0.7 800, 0.5 800, 0.6
Вторая из трех функций erase (с одним аргументом, ключом) удаляет все элементы с заданным ключом и возвращает число удаленных элементов. Например, если мы в программе mmapins.cpp добавим строчки
int n = M.erase(800) ;
cout << n << " elements erased\n";
непосредственно после пяти вызовов функции Mylnsert, вывод програм¬мы будет следующий:
800, 0.3 inserted 800, 0.7 inserted 800, 0.5 inserted 100, 1.9 inserted 800, 0.6 inserted 4 elements erased Multimap traversal: 100, 1.9
4.7. Сводный указатель
В этом разделе мы создадим приложение, использующее концепции сло¬варя и множества наряду с классом string, представленным в разделе 2.12. Это будет программа сводный указатель, берущая в качестве входных дан¬ных любой текстовый файл и для каждого слова в файле показывающая номера строк, в которых встречается это слово. Если слово встречается более одного раза на строчке, для этого слова номер строчки появится только один раз; сами слова будут перечислены в алфавитном порядке. Слово определяется как последовательность букв. Заглавные буквы будут заменены строчными. Для примера в качестве входного файла выберем текст первой программы в этой книге из раздела 1.1:
// ftempi.срр: A template function, iinclude <iostream.h>
template <class T> T f(T x)
{   T x2 = 2 * x;
return x2 + (x * x + l)/x2;
}
int main()
{   cout « f(5.0) << endl « f(5) << endl; return 0;
}
Как мы видим, во входном файле могут встречаться любые символы. Для него наша программа сводный указатель выдаст следующий результат:
Enter name of input file: ftempi.CDD
a	1
class	4
cout	11
cpp	1
endl	11
f	5 11
 
ftempi
function
h
include int
iostream main return t
template
x
 
1 1 2 2
10 2
10
7 12
4	5 6 1 4
5	6 7
 
С помощью контейнера STL map (словарь) мы можем хранить все слова в сбалансированном двоичном дереве поиска (что делает поиск очень бы¬строй операцией), не программируя самостоятельно функциональность такого дерева. Каждый узел дерева содержит слово (используемое в каче¬стве ключа) вместе с множеством номеров строк. В терминологии STL каждый элемент словаря является парой {first, second), где
first      = слово; представляется типом string; second    = множество номеров строк; представляется типом set<int>.
Имя входного файла также будет содержаться в переменной типа string; полностью программа приведена ниже:
// concord.срр: Сводный указатель, использующий словари,
//	множества и строки.
iinclude <iostream>
iinclude <fstream>
iinclude <iomanip>
iinclude <ctype.h>
iinclude <string>
iinclude <set>
iinclude <map>
using namespace std;
typedef set<int, less<int> > settype;
typedef map<string, settype, less<string> > maptype;
bool wordread(ifstream kifstr, string &word,
int klinenr) {   char ch;
// найдем первую букву:
for (;;)
{   ifstr.get(ch);
if (ifstr.fail()) return false; if (isalpha(ch)) break; if  (ch == '\n')  linenr++;
word =
// найдем первый небуквенный символ: do
{   word += tolower(ch);
ifstr.get(ch); }   while (!ifstr.fail() && isalpha(ch)); if (ifstr.fail()) return false; ifstr.putback(ch);  // ch может быть '\n' return true;
}
int main() {   maptype M;
maptype::iterator im;
settype::iterator.is, isbegin, isend;
string inpfilename, word;
ifstream ifstr;
int linenr = 1;
cout << "Enter name of input file: "; cin >> inpfilename; ifstr.open(inpfilename.c_str()); if  (!ifstr)
{   cout « "Cannot open input file.\n"; exit(l); }
while (wordread(ifstr, word, linenr)) {   im = M.find(word); if (im == M.end())
im = M.insert(maptype::value_type(word, settype())).first; (*im).second.insert(linenr);
}
for (im = M.beginf); im != M.endO; im++) {   cout   « setiosflags(ios::left) « setw(15) «  (*im).first.c_str(); isbegin = (*im).second.begin(); isend =  (*im).second.end(); for (is=isbegin; is != isend; is++)
cout <<""<< *is; cout << endl;
}
return 0;
}
Функция wordread пропускает ненужные символы, увеличивает при необ¬ходимости счетчик строк, а затем читает одно слово. Хотя эта функция составляет значительную часть программы, мы не будем подробно ее об¬суждать, потому что она не имеет непосредственного отношения к STL.
Приведенный ниже фрагмент программы создает полный словарь, содер¬жащий основные данные:
while (wordread(ifstr, word, linenr)) {   im = M.find(word); if  (im == M.endO )
im = M.insert(maptype::value_type(word, settype())).first; (*im).second.insert(linenr);
}
Вызов wordread(ifstr, word, linenr) читает, если это возможно, следующее слово из потока ifstr. Он возвращает true, если слово было прочитано ус¬пешно, и false, если встретился конец файла. После этого мы с помощью функции find проверим, присутствует ли прочитанное слово в словаре. Теперь мы различаем два случая: слово найдено или не найдено. Вспом¬ним, что элемент словаря состоит из слова и множества номеров строк. Если слово найдено в словаре, текущий номер строки добавляется в мно¬жество номеров строк; каким именно образом, мы увидим ниже. Если сло¬во не найдено, возвращенный функцией итератор im равен M.endV), и сначала нам нужно добавить новый элемент словаря, состоящий из нового слова и пустого множества. Этого мы достигаем с помощью довольно сложного оператора, располагающегося на двух строках программы; он имеет следующий вид:
im = М.insert(ххх).first;
Рассматриваемый вызов возвращает пару {iterator, true), поскольку нам известно, что ключ пока отсутствует в словаре. Значение итератора из этой пары, указывающее на позицию только что добавленного элемента, при¬сваивается переменной im. В приведенной выше записи ххх заменяет со¬бой пару (k, d), где k является новым словом, ad - пустым множеством, которое записано в программе в виде выражения settype(). Напомним, что это выражение вызывает конструктор по умолчанию для типа settype, ко¬торый является типом используемых нами множеств. Для пары (k, d) = ххх мы в действительности пишем
maptype::value_type(word, settype())
(тип value Jype мы обсуждали в разделах 2.7, 2.10 и 3.1). Теперь в любом из двух упоминавшихся случаев im указывает на элемент словаря, который содержит рассматриваемое слово как (*im).first. В соответствующее множе¬ство (*im).second текущий номер строки добавляется с помощью оператора
(* im).second.insert(linenr);
 
 


Адаптеры контейнеров

5.1. Стеки
Стек (stack) представляет собой структуру данных, которая допускает только две операции, изменяющие ее размер: push (для добавления элемен¬та в конце) и pop (для удаления элемента в конце). Иными словами, стек работает по принципу «последний пришел - первый ушел» (также назы¬ваемому LIFO от английского Last In - First Out). Кроме push и pop для стека определены также функции-члены empty и size, имеющие обычное значение, и top (вместо back) для доступа к последнему элементу.
Стек может быть реализован с помощью каждого из трех последова¬тельных контейнеров STL: вектора, двусторонней очереди и списка. Сле¬довательно, стек не является новым типом контейнера, а особым вариан¬том вектора, двусторонней очереди либо списка, отсюда и происхождение термина адаптер контейнера.
В качестве примера используем стек для чтения последовательности целых чисел и отображения их в обратном порядке. Любой нецифровой символ будет признаком конца ввода. В следующей программе стек реа¬лизован вектором, но программа также будет работать, если мы заменим всюду vector на deque или list. Кроме тощ, программа показывает, как рабо¬тают функции-члены empty, top и size.
 
// stackl.cpp: Используем стек для чтения
//	последовательности целых чисел произвольной длины
//	и отображения этой последовательности
//	в обратном порядке.
¦include <iostream> ¦include <vector> ¦include <stack> using namespace std;
int main()
{   stack <int, vector<int> > S; int x; cout <<
"Enter some integers, followed by a letter:\n"; while (cin » x) S.push(x); while (!S.empty()) {   x = S.top();
cout « "Size: " << S.sizeO
« "       Element at the top:  " « x « endl;
S.popf);
}
return 0;
}
Согласно проекту стандарта С++ шаблон stack имеет два параметра, как написано в приведенной программе:
stack <int, vector<int> > S;
В версии HP STL первый из этих аргументов отсутствует, поэтому, если вы используете эту (устаревшую) версию, необходимо данную строчку программы заменить на
stack < vector<int> > S;
После того как числа, введенные пользователем, будут положены на стек, программа последовательно нужное количество раз отобразит текущий размер стека и элемент, который будет удален следующим, как в приведенном примере:
Enter some integers, followed by a letter: 10 20 30 A
Size: 3 Element at the top: 30 Size: 2 Element at the top: 20 Size: 1       Element at the top: 10
Для стеков мы не можем истолковать итераторы, а также не можем полу¬чить доступ к произвольному элементу стека без изменения его размера.
Стек определяет операторы присваивания (=) и сравнения (== и <). Отсю¬да следует (см. раздел 2.8), что для стеков можно использовать также осталь¬ные четыре оператора сравнения. Оператор < осуществляет лексикографи¬ческое сравнение, как показывает следующая программа:
// stackcmp.cpp: Сравнение и присваивание для стеков, ¦include <iostream> ¦include <vector> ¦include <stack> using namespace std;
int main()
{   stack <int, vector<int> > S, T, U; S.push(lO); S.push(20); S.push(30); cout « "Pushed onto S: 10 20 30\n"; T = S;
cout « "After T = S; we have ";
cout «  (S == T ? "S == T"  :   "S != T")  « endl;
U.push(lO); U.push(21);
cout « "Pushed onto U: 10 21\n";
cout << "We now have ";
cout « (S < U ? "S < U"  :  "S >= U") « endl; return 0;
}
Вывод программы:
Pushed onto S: 10 20 30 After T = S; we have S == T Pushed onto U: 10 21 We now have S < U
Рисунок 5.1 иллюстрирует последнее сравнение.
 
30 20

СтекБ

31 _ .КЗ-Отек U
 
Рисунок 5.1. Лексикографическое сравнение стеков
Первыми сравниваются элементы в низу стека. Поскольку оба они равны 10, происходит сравнение следующих за ними элементов 20 и 21. В нашем примере S < U, потому что 20 < 21. Это сравнение выполняется таким же образом, как и сравнение строк, только для строк мы начинаем сравнение с первых символов, а для стека - с нижних элементов.
Интересно отметить, что функция-член top возвращает ссылку, которая позволяет нам изменить непустой стек, не прибегая к помощи операций push и pop. Например, вместо
S.pop(); S.push(15);
мы можем написать
S.topO  = 15;
5.2. Очереди
Очередь (queue) является структурой данных, в которую можно добавлять элементы с одного конца, сзади, и удалять с другого конца, спереди. Мы можем узнать и изменить значения элементов спереди и сзади, как пока¬зано на рисунке 5.2.
 

Q
 

(iO)  20 (ЗО)
 
Позиция добавления с помощью Q.push(...)
 

 
Q.front()	1
удаляется при QpopO
 
-Q.back()
 
Рисунок 5.2. Очередь

В отличие от стека мы не можем представить очередь с помощью вектора, по¬скольку у вектора отсутствует операция pop_front. Например, нельзя написать
queue<int, vector<int> > Q;      // Ошибка
Но если vector заменить на deque или list, такая строчка станет допустимой. Из следующей программы видно, что функции-члены push и pop работают так, как показано на рисунке 5.2.
// queue.срр:   Использование очереди; демонстрация
//	функций-членов push, pop, back и front.
¦include <iostream> ¦include <list> ¦include <queue>
using namespace std;
int main()
{   queue <int, list<int> > Q;
Q.push(lO); Q.push(20); Q.push(30); cout << "After pushing 10, 20 and 30:\n"; cout « "Q.front()  = " « Q.front() « endl; cout « "Q.backO    = " « Q.backO « endl; Q•pop();
cout « "After Q.pop():\n";
cout « "Q.front()  = " « Q.front() « endl; return 0;
}
Вывод программы:
After pushing 10, 20 and 30: Q.front() = 10 Q.backO    = 30 After Q.pop(): Q.front О  = 20
Любопытно отметить, что при использовании очередей из HP STL необ¬ходимо включить заголовок stack.h, а согласно проекту стандарта С++ нужно включать заголовок queue (см. таблицу в разделе 1.2). Также отли¬чается количество параметров шаблона; мы не будем останавливаться на этом подробно, поскольку отличие то же, что и для стеков, о чем расска¬зано в предыдущем разделе.
Функции-члены empty и size класса queue аналогичны этим функциям для класса stack, так же как и операторы присваивания и сравнения. Срав¬нение начинается с передних элементов; если они равны, происходит срав¬нение следующих, и так далее.
5.3. Очереди с приоритетами
Очередь с приоритетами (priority queue) является структурой данных, из которой, если она не пуста, можно удалить только наибольший элемент. Как и для стеков, наиболее важными функциями-членами являются push, pop и top. Следующая программа использует эти функции:
// prqueue.cpp: Очередь с приоритетами; программа
//	демонстрирует функции-члены push, pop, empty и top.
¦include <iostream> ¦include <vector> ¦include <functional> ¦include <queue>
using namespace std;
int main О
{   priority_queue <int, vector<int>, less<int> > P;
int х;
P.push(123); P.push(51); P.push(lOOO); P.push(17); while (!P.empty()) {   x = P.top();
cout « "Retrieved element: " « x « endl;
P.popf);
}
return 0;
}
В этой программе числа следуют в нисходящем порядке:
Retrieved element:	1000
Retrieved element:	123
Retrieved element:	51
Retrieved element:	17
Поскольку требуется проводить сравнение элементов, шаблон priority_queue имеет третий параметр, как видно из определения очереди с приоритетами Р:
priority_queue <int, vector<int>, less<int> > P;
Если требуется извлекать элементы в порядке возрастания, мы можем просто заменить less<int> на greater<int>. При работе с HP STL необходи¬мо опустить первый аргумент шаблона, а также использовать заголовок stackJi вместо queue.
Чтобы продемонстрировать возможность задания любого правила упо¬рядочения элементов, приведем еще один пример, в котором элементы бу¬дут извлекаться по порядку возрастания последних цифр в десятичном представлении целых чисел, хранящихся в очереди с приоритетами:
// lastdig.cpp: Очередь с приоритетами; P.topO указывает
//	на элемент, последняя цифра которого не больше
//	последних цифр других элементов.
¦include <iostream> ¦include <vector> ¦include <queue> using namespace std;
class CompareLastDigits { public:
bool operator()(int x, int y) {    return x % 10 > у % 10; }
int main()
{   priority_queue <int, vector<int>, CompareLastDigits> P; int x;
P.push(123); P.push(51); P.push(lOOO); P.push(17); while (!P.empty()) {   x = P.top();
cout « "Retrieved element: " « x « endl;
P.popO ;
}
return 0;
}
Вывод этой программы содержит добавленные целые числа 123, 51, 1000, 17 в порядке возрастания их последних цифр (0 < 1 < 3 < 7):
Retrieved element:	1000
Retrieved element:	51
Retrieved element:	123
Retrieved element:	17
Отметим, что нам необходимо использовать функциональный объект, по¬скольку шаблон priority_диеие требует в качестве третьего параметра тип. Этот тип определяет идентификатор CompareLastDigits. Сравнение
х % 10 > у % 10
содержит оператор >, в результате чего элемент с наименьшей последней цифрой предшествует другим элементам. Аналогичным образом при ис¬пользовании greater<int> первым будет располагаться наименьший элемент.
 
 

Функциональные объекты и адаптеры

6.2. Функциональные объекты
В разделах 1.12 и 2.4 уже рассмотрены функциональные объекты, которые зачастую бывают трудны для восприятия, поэтому мы немного поэкспе¬риментируем с ними вне рамок STL. Следующая программа демонстриру¬ет класс sq, который можно использовать для вычисления значения х2 це¬лого числа х:
II funobjl.cpp: Простой функциональный объект, ¦include <iostream.h>
struct sq {
int operator()(int x)const {return x * x;}
};
int main()
{   cout « "5*5= " « sq()(5) « endl;  // 25 return 0;
}
Ключевое слово struct часто используется вместо class, когда класс имеет только открытые (public) члены. Если не считать доступ по умолчанию
 
(закрытый (private) для class и открытый для struct), эти два ключевых слова эквивалентны.
Из раздела 1.12 известно, что выражение sqQ вызывает конструктор по умолчанию класса sq, так что значение этого выражения является экзем¬пляром этого класса. Строка
int operator!)(int х)  {return х * х;}
в этом классе определяет operatorQ таким образом, что выражение sqQ(5) является разрешенным вызовом функции, результат которого равен 25. Важно понимать, чем отличаются следующие выражения:
sq	класс (тип), который мы будем называть функциональным классом;
sqQ        функциональный объект; 5|?()(5)    вызов функции.
Функциональные объекты обладают всеми свойствами обычных функций, но они имеют дополнительные возможности, как показывает следующая программа:
// funobj2.cpp: Функциональные классы как
//	параметры шаблона.
¦include <iostream.h>
struct square {
int operator()(int x)const {return x * x;}
};
struct cube {
int operator()(int x)const {return x * x * x;}
};
template <class T> class cont { public:
cont(int i): j(i){}
void print()const {cout « T()(j) « endl;} private: int j ;
};
int main()
{   cont<square> numsq(lO);
numsq.print();    // Вывод:  100 cont<cube> numcub(lO); numcub.print();  // Вывод:  1000 return 0;
В функции main этой программы функциональные классы (square и cube) используются в качестве параметров шаблона. Мы можем считать, что cont<T> является ограниченным вариантом контейнера, поскольку он мо¬жет хранить только одно число целого типа. Однако этот класс является довольно общим в том плане, что тип-параметр Г может быть любым функ¬циональным классом, функциональный вызов которого принимает цело¬численный аргумент и возвращает целочисленное значение. В нашем при¬мере такими классами являются square и cube. Хотя программа funobj2.cpp выглядит надуманной, она может помочь разобраться с более интересными случаями. Например, контейнер priority_queue также требует функциональ¬ный класс в качестве параметра, как мы видели в конце предыдущей главы.
Функции operatorQ имеют в нашем примере только один аргумент, хотя часто используются функции с двумя аргументами, как, например, в случае очередей с приоритетами. Приведем пример работы функциональных объек¬тов с двумя аргументами функции. Определим шаблонный класс PairSelect, содержащий функцию печати, которая выводит меньший элемент пары в со¬ответствии с определенным нами отношением «меньше чем», задаваемым па¬раметром шаблона. Также в виде параметра шаблона мы зададим тип элемен¬тов пары. Следующая программа использует два отношения упорядочения. Они реализованы в виде бинарных предикатов, то есть функций, которые име¬ют два аргумента и возвращают логическое значение. Наш первый бинарный предикат, LessThan, является шаблоном, поэтому он применим к любому типу, для которого определен оператор < Второй предикат, CompareLastDigits, явля¬ется обычным, не шаблонным, функциональным классом, который практичес¬ки совпадает с функциональным классом, определенным в последнем разделе предыдущей главы, только результат его вызова равен true, если последняя цифра первого аргумента меньше, чем у второго, и false - в противном случае.
// funobj3.cpp: Функция operator!) как
//	бинарный предикат,
¦include <iostream.h>
template <class T> struct LessThan {
bool operator()(const T &x, const T &y)const
{   return x < y;
}
};
struct CompareLastDigits {
bool operator()(int x, int y)const
{    return x % 10 < у % 10;
}
};
template <class Т, class Compare> class PairSelect { public:
PairSelect(const T &x, const T &y): a(x), b(y){} void PrintSmaller()const
{   cout «  (Compare()(a, b)  ? a : b) « endl; }
private: Та, b;
};
int main()
{   PairSelect<double, LessThan<double> > P(123.4, 98.7); P.PrintSmaller(); // Вывод: 98.7
PairSelect<int, CompareLastDigits> Q(123, 98); Q.PrintSmaller(); // Вывод: 123 return 0;
}
Эта программа сначала выводит значение 98.7, потому что оно меньше дру¬гого элемента объекта Q - 123.4. После этого она выводит 123, поскольку последняя цифра этого числа - 3 - меньше, чем последняя цифра числа 98.
Шаблон less<T>, определенный в STL, очень похож на шаблонный класс LessThan<T> из программы funobj3.cpp. В заголовке functional мож¬но найти следующее определение:
template <class Т>
struct less: binary_function<T, T, bool> {
bool operator()(const T& x, const T& y) const
{   return x < y;
}
};
Единственное отличие этого класса из STL от нашего класса LessThan заклю¬чается в том, что класс less наследует от базового класса binary Junction. Этот класс не содержит никаких членов, за исключением нескольких определений типов с помощью typedef, то же относится к унарному аналогу unary Junction. Следующие определения этих классов также находятся в заголовке functional:
template <class Arg, class Result> struct unary_function {
typedef Arg argument_type;
typedef Result result_type;
};
template <class Argl, class Arg2, class Result> struct binary_function {
typedef Argl first_argument_type;
typedef Arg2 second_argument_type; typedef Result result_type;
};
Для наших теперешних целей мы не используем типы, определенные в этих базовых классах, но они нужны для работы привязок и отрицате¬лей, которые рассмотрены далее.
Как можно легко предположить, программа funobj3.cpp будет работать точно так же, если мы заменим наш собственный шаблонный класс LessThan<T> на шаблонный класс STL less<T>. Для этого можно изменить программу следующим образом:
1.	В начале текста программы добавить две строки #include <functional> (или ^include <algorithm>) и using namespace std.
2.	Убрать определение класса LessThan.
3.	Заменить LessThan на less во второй строке функции main.
6.2. Унарные предикаты и привязки
В математике мы можем превратить функцию двух аргументов в функцию одного аргумента, если один из аргументов сделаем константой. Напри¬мер, мы можем определить функцию g как
g(x) = f(x, с)
где с является константой. Предположим, что мы хотим использовать шаб¬лон STL less<T> для того, чтобы сосчитать, сколько значений, меньших 100, содержится в целочисленном массиве а из десяти элементов. В разделе 2.3 мы видели, что для решения таких задач существует алго¬ритм count_if, но он использует унарный предикат, а не бинарный. Это логично, ведь мы имеем дело с условием
х< 100
в котором присутствует только одна переменная. Это условие, очевидно, является частным случаем выражения
х<у
Мы говорим, что хотим привязать (bind) второй аргумент less<T> к значению 100. В STL это достигается с помощью использования привязки, которая яв¬ляется одним из видов адаптера функции. Чтобы превратить бинарный пре¬дикат в унарный, привязав его второй аргумент, мы используем привязку bind2nd. В нашем примере требуется использовать выражение
bind2nd(less<int>(), 100)
чтобы указать, что мы хотим считать только значения, меньшие 100. Сле¬дующая программа показывает, как это все работает:
// binder.срр: Использование адаптера bind2nd для подсчета,
//	сколько из элементов массива меньше, чем 100.
¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
int main()
{    int     a[10] = {800, 3, 4, 600, 5, 6, 800, 71, 100, 2}, n = 0;
n = count_if(a, a + 10, bind2nd(less<int>(), 100)); cout << n « endl;  // Вывод:  6 return 0;
}
Для привязывания первого аргумента существует привязка bindist. К примеру, заменим условие х < 100 эквивалентным условием
100 >х
Этого можно добиться, привязав первый операнд у выражения у > х
к значению 100. Следовательно, программа binder.срр выдаст тот же ре¬зультат, если мы заменим вызов count_if на следующий:
n = count_if(a, а + 10, bindlst(greater<int>(),  100));
Мы не будем подробно обсуждать реализации адаптеров bindlst и bind2nd, потому что их определения сложнее, чем использование в программах.
6.3. Отрицатели
Программисты часто используют унарный оператор ! (не). Например, вы¬ражение
!(х < у)
эквивалентно
х >= у
Подобным же образом на функции двух аргументов действует отрицатель not2. Отрицатель является еще одной разновидностью адаптера функции; он реализуется в виде шаблонной функции, которая принимает в качестве аргумента объект, являющийся бинарным предикатом, например less<int>. Мы, следовательно, можем написать
not2(less<int>()) вместо
greater_equal<int>
Это выражение используется в следующей программе. Она сортирует мас¬сив из пяти элементов в нисходящем порядке:
// not2demo.cpp: Пример использования адаптера not2. ¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
int main()
{    int a[5] = {50, 30, 10, 40, 20}; sort(a, a+5, not2(less<int>())); for (int i=0; i<5; i++) cout « a[i] « " "; // Вывод:  50 40 30 20 10 cout « endl; return 0;
}
Приведенный выше вызов алгоритма sort можно заменить на
sort(а, a+5, greater_equal<int>()); или просто
sort(a, a+5, greater<int>());
Адаптер функции not\ изменяет унарные предикаты. Так как адаптеры bindist и bindlnd возвращают унарный предикат, выражение типа
bind2nd(less<int>(), 100)
является приемлемым аргументом для адаптера notl, как показывает сле¬дующая программа:
// notldemo.срр: Пример использования адаптера notl. ¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
int main()
{   int     a[10] = {800, 3, 4, 600, 5, 6, 800, 71, 100, 2}, n = 0;
// Подсчитаем, сколько имеется элементов не меньше 100: n = count_if(a, а + 10,
notl(bind2nd(less<int>(), 100)));
 
cout « n « endl;  // Вывод: 4 return 0;
}
Отметим, что подсчет числа элементов массива, равных или превышаю¬щих 100, может быть произведен с помощью более простого вызова алго¬ритма count_if:
n = count_if(a, а + 10,
bind2nd(greater_equal<int>(), 100) ) ;
В любом случае будет выведено число 4, поскольку ровно четыре элемен¬та (800, 600, 800, 100) массива а не меньше 100.
6.4. Два полезных базовых класса STL
Могли ли мы найти более простой пример для обсуждения адаптера notl, чем
sort(a, a+5, not2(less<int>()));
встречающийся в программе not2demo.cpp в предыдущем разделе? В част¬ности, можем ли мы применить not2 к написанному нами функционально¬му объекту, например, таким образом:
sort(a, a+5, not2(iLessThen())) ;
если iLessThen — функциональный класс, определенный как
struct iLessThen {	// ???
bool operator()(int x, int у)const {return x < y;}
};
Однако нам не удастся откомпилировать этот код. Адаптер notl требует, чтобы его параметр шаблона был классом, производным от шаблонного класса binary Junction, который упоминался в разделе 6.1. Этого легко до¬биться, добавив
: binary_function<int,  int, bool>
сразу после имени класса iLessThen в приведенном выше объявлении это¬го класса. Три параметра шаблона int, int и bool соответствуют типам двух аргументов и результата, которые можно было бы использовать при объяв¬лении обычной функции для тех же целей, такой как
bool lessthan(int х, int у)   {return х < у;}
Используя binary_function<int, int, bool> в качестве базового класса для iLessThen, можно написать следующую программу, эквивалентную про¬грамме not2demo.cpp из предыдущего раздела:
// not2own.cpp: Использование адаптера not2 с нашим
//	собственным функциональным объектом,
¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
struct iLessThan: binary_function<int,  int, bool> { bool operator()(int x, int у)const {return x < y;} };
int main()
{   int a[5] = {50, 30, 10, 40, 20}; sort(a, a+5, not2(iLessThan())); for  (int i=0;  i<5;  i++)  cout « a[i] « "  "; // Вывод:  50 40 30 20 10 cout « endl; return 0;
}
Адаптер notl также можно использовать с нашим функциональным объек¬том. В предыдущем разделе был использован notl в выражении
notl(bind2nd(less<int>(), 100))
из программы notldemo.cpp, чтобы сосчитать, сколько элементов массива не меньше 100. В этом выражении мы заменим
bind2nd(less<int>(), 100)
более простой формой
LessThanlOOO
где LessThanlOO - определенный нами класс, как показано в следующей программе:
// notlown.cpp: Использование адаптера notl с нашим
//	собственным функциональным объектом.
¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
struct LessThanlOO: unary_function<int, bool> { bool operator()(int x)const {return x < 100;} };
int main()
{   int     a[10] = {800, 3, 4, 600, 5,  6, 800, 71,  100, 2}, n = 0;
 
// Подсчитаем количество элементов, не меньших 100: n = count_if(a, а+10, notl(LessThanlOO())) ; cout « n « endl; // Вывод: 4 return 0;
}
В этой программе фрагмент
: unary_function<int, bool>
определяет базовый класс, наследником которого является класс LessThanlOO. Мы пишем unary_Junction<int, bool>, потому что адаптер notl работает с унарным предикатом, который принимает в качестве параметра целое значение и возвращает значение типа bool. Напомним, что опреде¬ление класса unary ^function было приведено в разделе 6.1.
6.5. Функциональные объекты и алгоритм transform
Как видно из раздела 2.4, STL определяет следующие шаблонные классы, которые мы можем использовать как функциональные объекты, сопрово¬див их парой скобок:
plus<T>	minus<T>
multiplies<T>	divides<T>	modulus<T>
equal_to<T>	not_equal_to<T>
greater<T>	less<T>
greater_equal<T>	less_equal<T>
logical_and<T>	logical_or<T>
liegate<T>	logical_not<T>
Чтобы проиллюстрировать работу некоторых функциональных объектов этого списка (не рассмотренных ранее), для начала обсудим алгоритмы transform. Этих алгоритмов в STL два - для унарной и для бинарной опе¬раций. Они нужны для преобразования всех элементов в диапазоне. Пред¬положим, например, что нам требуется использовать элементы a[i] цело¬численного массива а для присваивания значений b[i] = -a[i] другому массиву Ь. Один из способов достичь этого состоит в применении алгорит¬ма transform для унарной операции совместно с шаблоном negate<T>, как показывает следующая программа:
// negate.срр: Алгоритм transform и negate<T>. ¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
int main()
{   int а[5] = {10, 20, -18, 40, 50}, b[5]; transform(a, a + 5, b, negate<int>()); for (int i=0;  i<5; i++) cout « b[i] « " // Вывод:  -10    -20    18    -40    -50 cout « endl; return 0;
}
Функциональный объект logical_not<T>() очень похож на negate<T>(). Если мы напишем
transform(а, а + 5, b, logical_not<int>());
массиву b будут присвоены значения b[i] = ! a[i]. Напомним, что мы можем вместо bool, true и false писать int, 1 и 0. А в качестве источника и приемника допустимо использовать один и тот же массив. Например, вызов
transform(а, а + 5, a, negate<int>());
будет равнозначен умножению пяти элементов массива а на -1.
Перейдем теперь к знакомству с бинарной версией алгоритма transform. Этот вариант использует два контейнера-источника вместо одного, а также бинарный функциональный объект. Для примера предположим, что мы хотим использовать массивы а и b для вычисления следующей суммы в массиве s:
s[i] = a[i] + b[i]
Следующая программа показывает, как этого можно достичь с помощью шаблона plus<int>:
II plus.срр: Алгоритм transform и plus<T>. iinclude <iostream> iinclude <algorithm> iinclude <functional> using namespace std;
int main()
{   int     a[5] = {10, 20, -18, 40, 50},
b[5] = { 2,    2,     5,    3,    1}, s[5]; transform(a, a + 5, b, s, plus<int>()); for (int i=0;  i<5;  i++)  cout « s[i]  « "    "; // Вывод: 12   22    -13    43   51 cout « endl; return 0;
}
Если необходимо, можно вместо отдельного массива s при вызове transform использовать один из источников а или Ь.
Точно так же, как шаблон plus применяется для операции +), следующие бинарные функциональные объекты minus, multiplies, divides и modulus ис¬пользуются для операций -, *, / и % соответственно. То же самое относится к бинарным функциональным объектам equal Jo, not_equaljo, greater, less, greater equal, less_equal, logical_and и logical_or, которые соответствуют опе¬рациям ==, !=, >, <, >==, <=, && и 11, возвращающим булевское значение. Два последних функциональных объекта (logicaljind и logical_ог) также обычно применяются к аргументам типа bool. Хотя этот список выглядит внуши¬тельно, нам часто для функции transform требуются операции, которые в нем отсутствуют. Тогда мы можем использовать свои собственные функ¬циональные объекты, определив класс, который наследует от шаблона binaryJunction либо unary Junction, как было показано в предыдущем раз¬деле. Например, предположим, что нам опять даны два массива целых чи¬сел а и b и мы хотим вычислить значения массива result таким образом:
result[i] = a[i] + 2 * b[i] ;
(скажем, для значений i = 0,1,4). Следующая программа показывает, как решить эту задачу с помощью специально написанного класса compute:
II compute.срр: Алгоритм transform
//	и наш собственный функциональный объект,
¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
struct compute: binary_function<int, int, int> {
int operator()(int x, int у)const{return x + 2 * y;}
};
int main()
{   int     a[5]  = {10, 20, -18, 40,  50},
b[5]  = { 2,    2,      5,    3,    1}, result[5]; transform(a, a + 5, b, result, computet)); for (int i=0;  i<5; i++) cout « result[i] « "
// Вывод:  14    24    -8    46    52 cout « endl; return 0;
}
To же относится и к версии transform, которая использует унарный функ¬циональный объект. Например, если мы хотим заменить пять элементов a[i] целочисленного массива а на значение 1.0/(а[г] * a[i] + 1), используя массив а в качестве источника и приемника одновременно, можно достичь этого, применяя класс, производный от шаблона unaryJunction1, как по¬казывает следующая программа:
// computel.срр: Заменим a[i] на
//	1.0/(a[i] * a[i] + 1) .
¦include <iostream>
¦include <algorithm>
¦include <functional>
using namespace std;
struct computel: unary_function<int, double> { double operator()(int x)const {   return 1.0/(x * x + 1);}
};
int main()
{   int a[5] = {2, 0, 1, 3, 7}; double b[5];
transform(a, a + 5, b, computelО) ;
for (int i=0; i<5; i++) cout « b[i] « "  ";
// Вывод: 0.2 1 0.5 0.1 0.02
cout « endl;
return 0;
}
6.6. Адаптеры итераторов
Для итераторов существуют два типа адаптеров: итераторы вставки (insert) и обратные (reverse) итераторы. В этом разделе мы встретим несколько типов итераторов из тех, что уже были рассмотрены, а также некоторые другие типы.
Итераторы вставки
Как видно из программы сору2.срр раздела 1.6, алгоритмы наподобие сору будут работать в режиме вставки, если мы напишем, например:
copy(v.begin(), v.endO, inserter(L, i)) ;

1 На самом деле в программах compute.срр и computel.срр нет необходимости в наследовании классов от шаблонов binary Junction и unaryJunction, так как мы не используем наши функциональные объекты совместно с адаптерами. Более того, мы можем заменить функциональные объекты на просто функции, написав вмес¬то определения класса compute следующее:
int compute(int х, int у)  {return х + 2 * у;} и убрав пару скобок, следующих за идентификатором compute в вызове transform. -Прим. переводчика.
 
Итератор вставки inserter является общим в том смысле, что мы указыва¬ем позицию, в данном примере i, в которой будет происходить вставка эле¬ментов. Если вставка в контейнер L должна происходить в конце, мы мо¬жем написать L.endQ, как в следующей программе:
// соруЗ.срр: Копирование вектора с помощью итератора
//	вставки.
¦include <iostream>
¦include <vector>
¦include <list>
using namespace std;
int main()
{    int a[4] = {10, 20, 30, 40}; vector<int> v(a, a+4); list<int> L(2, 123);
copy (v.begin () , v.endf), inserter(L, L.endO));
list<int>::iterator i;
for (i=L.begin(); i != L.endO; ++i)
cout « *i « "  ";  // Вывод:  123 123 10 20 30 40 cout « endl; return 0;
}
Поскольку вставка в конце контейнера является часто встречающейся операцией, для нее существует специальный итератор вставки, называе¬мый back_inserter. Приведенная выше программа работает точно так же, если мы заменим вызов алгоритма сору на вызов:
copy (v.begin () , v.endO, back_inserter (L)) ;
Так как backinserter всегда добавляет элементы в конец, он требует в качестве единственного аргумента контейнер.
Еще один итератор вставки, frontjmerter, работает специфическим обра¬зом: каждый вставляемый элемент помещается в начале контейнера, что приводит к тому, что значения следуют в обратном порядке. Например, если мы заменим вызов алгоритма сору в программе соруЪ.срр строчкой
сору (v.begin () , v.endO, front_inserter (L)) ;
программа выведет следующие значения:
40 30 20 10 123 123
До сих пор мы применяли итераторы вставки только в качестве аргумен¬тов алгоритмов типа сору и merge. Мы можем использовать их другими способами. Например, вместо
L.push_front(111); L.push_back(999); можно написать
*front_inserter(L)=111; *back_inserter(L)=999; Обратные итераторы
Как мы видели в разделе 3.1, для типа vector<int> определены следующие типы итераторов, и легко догадаться, что подобные итераторы имеются и для других типов, например list<double>:
vector<int>::iterator vector<int>::reverse_iterator vector<int>::const_iterator vector<int>::const_reverse_iterator
В разделе 1.2 обратный итератор использовался в следующем фрагменте для вывода всех элементов вектора v в обратном порядке:
vector<int>::reverse_iterator i; for (i=v.rbegin; i != v.rendf); ++i) cout « * i « " ";
Типы итераторов, имена которых начинаются с const, нужны, когда контей¬нер сам имеет атрибут const, как в следующей программе, где функция showlist является вариантом функции с тем же именем из раздела 1.3:
// c_iter.cpp: const_iterator и
//	const_reverse_iterator
iinclude <iostream>
iinclude <list>
using namespace std;
void showlist(const list<int> &x) {   // Вперед:
list<int>::const_iterator i;
for (i=x.begin(); i != x.endO; + + i) cout « *i « " " ;
cout « endl;      //   Вывод: 10 20 30
// Назад:
list<int>::const_reverse_iterator j; for (j=x.rbegin(); j != x.rendf); ++j)
cout « *j « " "; cout « endl;      //   Вывод: 30 20 10
}
int main()
{   list<int> L;
L.push_back(10); L.push_back(20); L.push_back(30);
showlist(L); return 0;
}
Чтобы удалить префикс const_, встречающийся два раза в функции showlist, мы должны также удалить ключевое слово const, имеющееся в первой строке этой функции. Поскольку функция не модифицирует спи¬сок, передаваемый ей в качестве параметра, хороший стиль программиро¬вания требует наличия const в этом примере.
Потоковые итераторы
Мы использовали потоковые итераторы в разделе 1.9 и в других местах совместно с алгоритмом сору. Существует возможность работать с этими итераторами более элементарным способом; кроме того, вторым аргумен¬том конструктора класса ostream_iterator не обязана быть строка, состоя¬щая лишь из пробелов, что демонстрирует следующая программа:
// outiter.cpp: Потоковый итератор вывода; запись в файл
//	с помощью операции присваивания,
iinclude <iostream> iinclude <vector> iinclude <iterator> using namespace std;
int main() {
ostream_iterator<int> ifcout, "abc\n"); *i++ = 123; *i++ = 456; cout « endl; return 0;
}
Эта программа выведет:
123abc 456abc
Поскольку здесь из всей STL мы используем только шаблон ostreamiterator, программа будет работать, если напишем ^include <iterator> вместо ^include <vector>.
С вводом дела обстоят несколько сложнее, потому что требуется обна¬ружить конец входного потока. Вспомним обсуждение конца файла в разделе 1.9. Ниже приведено нетривиальное решение задачи, которая заключается в том, чтобы прочитать все числа из файла num.txt, содержа¬щего только целые числа в обычном формате.
 
итератор ввода; чтение файла операторов присваивания.
// initer.cpp: Потоковый
//	с помощью
iinclude <iostream> iinclude <fstream> iinclude <vector> iinclude <iterator> using namespace std;
int main() {   ifstream file("num.txt"); if (file)
{   istream_iterator<int> i(file), eof; int x;
while (i != eof) {   x = *i++;
cout << x « "  ";
}
}   else cout << "Cannot open file num.txt."; cout << endl; return 0;
}
Например, если файл num.txt содержит две строчки
10 20 30
программа выведет на экран:
10 20 30
 
 


Обобщенные алгоритмы
Эта глава дает обзор всех алгоритмов STL, называемых также обобщенны¬ми алгоритмами. Для уже рассмотренных алгоритмов мы будем ссылаться на предыдущее обсуждение, подробнее останавливаясь на не изученных нами алгоритмах.
Алгоритмы STL делятся на четыре категории, которые рассмотрены в сле¬дующем порядке:
•	немодифицирующие последовательные алгоритмы;
•	модифицирующие последовательные алгоритмы;
•	алгоритмы, связанные с сортировкой;
•	обобщенные численные алгоритмы.
Хотя алгоритмы в STL определены в виде шаблонов, мы обычно представ¬ляем их себе как функции, поскольку их использование практически не от¬личается от использования обычных функций. В примерах, где требуются последовательные контейнеры, мы будем использовать массивы целых чи¬сел. Вместо них мы могли бы использовать и другие контейнеры в зависимо¬сти от категории итераторов их аргументов. Например, поскольку алгоритм sort требует в качестве аргументов итераторы произвольного доступа, он не будет работать с контейнером list, как уже упоминалось в разделе 1.3. Поэто¬му каждый раздел этой главы начинается с краткого обзора рассматривае¬мых алгоритмов; при этом указаны категории итераторов, используемые
 
в качестве аргументов. Это перечисление приводится в виде списка прото¬типов деклараций шаблонов, но в этих прототипах для краткости опущены ключевое слово template и список параметров в угловых скобках. Имена ал¬горитмов выделены курсивом в конце строки, чтобы их было легче найти.
При первом чтении эти прототипы могут показаться скучными из-за их однообразия и длинных имен типов (которые являются параметрами шаб¬лона) наподобие RandomAccesslterator. Однако, когда вы немного освоитесь с рассмотренными алгоритмами, эти прототипы помогут быстро находить нужную информацию. Возьмем, к примеру, параметры алгоритма sort, запи¬санные в прототипе как RandomAccessIteratorfirst, RandomAccessIterator last. Поскольку список не определяет итераторы произвольного доступа (random access), из этого прототипа видно, что для списков мы не можем применять алгоритм sort. Если вы забыли, какие итераторы используются с контейне¬рами различных типов, то будет полезно перечитать раздел 1.9. Особенно важно помнить иерархию итераторов. Чем выше находится тип параметра алгоритма в иерархии итераторов, тем более ограничено использование это¬го алгоритма. Итераторы произвольного доступа, относящиеся к более вы¬сокому уровню, разрешают операции вроде i + п, что делает невозможным применение алгоритмов для списков, использующих такие итераторы.
7.1. Немодифицирующие последовательные алгоритмы
Алгоритмы в этом разделе «просматривают» последовательности, не из¬меняя их.
7.1.1. Алгоритмы find, count, foreach, findJirstof и find end
Ссылки в комментариях показывают, что мы уже обсуждали большую часть следующих алгоритмов:
Inputlterator find	II Обсуждался в разделе 1.5
(Inputlterator first,	Inputlterator last,
const T&   value);
Inputlterator find_if	II Обсуждался в разделе 1.13
(Inputlterator first,	Inputlterator last,
Predicate   pred);
void for_each	II Обсуждался в разделе 2.2
(Inputlterator first,	Inputlterator last,
Function   f);
difference_type count	// Обсуждался в разделе 2.3
(Inputlterator first,	Inputlterator last,
const T&   value);
difference_type count_if	// Обсуждался в разделе 2.3
(Inputlterator first,	Inputlterator last,
Predicate   pred);
Forwardlteratorl   find_first_of
(Forwardlteratorl   firstl,	Forwardlteratorl   lastl,
ForwardIterator2   first2,	ForwardIterator2   last2);
Forwardlteratorl   find_first_of
(Forwardlteratorl   firstl,	Forwardlteratorl   lastl,
ForwardIterator2   first2,	ForwardIterator2   last2,
BinaryPredicate pred);
Forwardlteratorl   find_end
(Forwardlteratorl   firstl,	Forwardlteratorl   lastl,
ForwardIterator2   first2,	ForwardIterator2   last2);
Forwardlteratorl   find_end
(Forwardlteratorl   firstl,	Forwardlteratorl   lastl,
ForwardIterator2   first2,	ForwardIterator2   last2,
BinaryPredicate pred);
Мы не будем повторять предыдущее обсуждение алгоритмов find, find_if, for_each, count и count_if
Алгоритм findJirst_pf похож на find, но вместо поиска элемента с задан¬ным значением он ищет в первом диапазоне элемент, значение которого рав¬но какому-либо элементу из второго диапазона. Если такие элементы присут¬ствуют в диапазоне, он возвращает итератор, ссылающийся на первый из них. Алгоритм findjend, напротив, возвращает итератор, указывающий на начало последнего полного вхождения второго диапазона в первый. (Если нужно найти первое вхождение, используйте алгоритм search, который рассмотрен далее в разделе 7.1.5.) В случае неудачи findJirst_of и findend возвращают lastl. Следующая программа демонстрирует работу обоих алгоритмов:
// find_end: Алгоритмы find_first_of и find_end. iinclude <iostream> iinclude <algorithm>
using namespace std; int main()
{   int     a[10]  = {3, 2, 5, 7, 5, 8, 7, 5, 8, 5}, b[2] = {5, 8}, *pl, *p2; pi = find_first_of(a, a+7, b, b+3); p2 = find_end(a, a+10, b, b+2); cout « pi - a « " " « p2 - a « endl; return 0;
}
Вывод этой программы:
2 7
объясняется тем, что а[2] (=5) является первым элементом а, который вхо¬дит также и в Ъ, а а[7] (=5) является начальным элементом последней пол¬ной последовательности 5,8 (заданной массивом Ь), которая встречается в а.
В STL определены также версии find_first_of и findend, принимающие в качестве дополнительного параметра для проведения сравнений бинарный предикат. Мы можем использовать этот предикат для замены проверки на равенство другим условием; подробнее применение этого предиката рас¬смотрено в следующем разделе на примере алгоритма adjacent_find.
7.1.2. Алгоритм adjacent Jind
Forwardlterator adjacent_find
(Forwardlteratorfirst, Forwardlteratorlast, const T&   value); Forwardlterator adjacent_find
(Forwardlteratorfirst, Forwardlteratorlast, Predicate   pred);
Для поиска в последовательном контейнере определены два алгоритма
adjacent_find (найти рядом). Первый ищет соседние элементы a[k]
и	которые равны друг другу; второй ищет соседние элементы, которые удовлетворяют заданному условию. В следующей программе пока¬зано, как работают оба варианта. Программа adjacent.cpp осуществляет по¬иск в массиве а четыре раза:
двух элементов, a[k] и	которые равны между собой;
двух элементов, a[k] и	удовлетворяющих условию a[k] > a[k+l];
двух элементов, a[k] и	удовлетворяющих условию a[k]2 = a[k+l];
двух элементов, a[k] и	удовлетворяющих условию a[k]3 = a[k+l].
Если искомые соседние элементы не найдены, функция adjacent_find воз¬вращает, как обычно, итератор, следующий за итератором, указывающим на последний элемент. Так, если бы мы вместо массива а использовали вектор v, это значение совпало бы со значением v.endQ. Значения в масси¬ве а подобраны таким образом, что первые три поиска происходят удачно, а последний - нет:
// adjacent.cpp: Алгоритмы adjacent_find.
iinclude <iostream>
iinclude <iomanip>
iinclude <algorithm>
iinclude <functional>
using namespace std;
bool is_square(int x, int y){return x * x == y;} bool is_cube(int x, int у){return x * x * x == y;}
int main()
{   int a[10] =
{5, 10, 28, 20, 10, 5, 25, 10, 10, 90}, *p, k;
for (к=0; к<10; к++) cout « setw(3) « к; cout << endl;
for (k=0; k<10; k++) cout << setw(3) « a[k]; cout « endl;
p = adjacent_find(a, a+10); к = p - a; if  (k != 10)
cout   « "a[k] = a[k+l], found at к = " « к « endl;
p = adjacent_find(a, a+10, greater<int>()); к = p - a; if (k != 10)
cout   « "a[k] > a[k+l], found at к = " « к « endl;
p = adjacent_find(a, a+10, is_square); к = p - a; if  (k != 10)
cout   « "a[k]*a[k] == a[k+l], found at к = " « к « endl;
p = adjacent_find(a, a+10, is_cube); к = p - a; if  (k != 10)
cout   « "a[k]*a[k]*a[k] == a[k+l], found at к = " « к « endl; else cout    « "If not found: к = " << к « endl; return 0;
}
Программа выведет:
0123456789
5 10 28 20 10   5 25 10 10 90 a[k] = a[k+l], found at к = 7 a[k] > a[k+l], found at к = 2 a[k]*a[k] == a[k+l], found at к = 5 If not found: к = 10
Предикаты в этой программе записаны как функции. Из предыдущего об¬суждения (см., например, главу 6) очевидно, что мы можем использовать вместо функций функциональные объекты. Например, мы можем заме¬нить функцию issquare следующим определением класса:
struct sq{
bool operator!)(int x, int у){return x * x == y;} };
если также заменим
р = adjacent_find(a, a+10, is_square);
на
p = adjacent_find(a, a+10, sq()); Этот подход применим и к другим предикатам в настоящей главе.
7.1.3. Отличие
pair<InputIteratorl, InputIterator2> mismatch (Inputlterator1 firstl, Inputlteratorl lastl, InputIterator2 first2); pair<InputIteratorl, InputIterator2> mismatch (Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, BinaryPredicate binary_pred);
Существуют два варианта алгоритма mismatch. Первый ищет одновремен¬но в двух последовательных контейнерах несовпадающие элементы, сто¬ящие в одной позиции. Другими словами, если мы обозначим эти элемен¬ты как х и у, будет выполнено условие \(х == у). Второй вариант использует передаваемый дополнительно предикат вместо оператора ==. Следующая программа демонстрирует оба варианта:
// mismatch.срр: Алгоритмы mismatch, iinclude <iostream> iinclude <iomanip> iinclude <algorithm> using namespace std;
bool smalldiffint a, int b){return abs(a - b) < 25;} int main()
{   int     a[4]  = {50, 80, 30, 90},
b[5]  = {50, 80, 10, 40, 20},  *pa,  *pb, k; pair<int*, int*> difpos(0, 0); for  (k=0; k<5; k++) cout « setw(3) << k; cout << endl;
for (k=0; k<4; k++) cout « setw(3) << a[k]; cout << endl;
for (k=0; k<5; k++) cout « setw(3) « b[k]; cout « endl;
difpos = mismatchfa, a+4, b); pa = difpos.first; pb = difpos.second; cout   « "Different elements " << *pa << " and " << *pb
<< " found at position " << pa - a << endl; difpos = mismatchfa, a+4, b, smalldif); pa = difpos.first;
pb = difpos.second;
cout   « "Difference of at least 25 found between\n" << *pa << " and " << *pb << " at position " << pa - a << endl;
return 0;

В обоих случаях отличия находятся, как видно из вывода этой программы:
0    12   3   4
50 80 30 90
50 80 10 40 20 Different elements 30 and 10 found at position 2 Difference of at least 25 found between 90 and 40 at position 3
Обратите внимание, что вторая последовательность должна быть не коро¬че первой. Если бы отличий найти не удалось (например, при замене в тексте программы 25 на 250), возвращаемая пара итераторов соответ¬ствовала бы позиции 4 во входных массивах.
7.1.4. Сравнение на равенство
bool equal
(Inputlteratorl	firstl, Inputlteratorl lastl,
InputIterator2	first2);
bool equal
(Inputlteratorl	firstl, Inputlteratorl lastl,
InputIterator2	first2, BinaryPredicate binary_pred);
Алгоритмов equal также два. Первый определяет равенство двух последовательностей (в указанных диапазонах); второй работает аналогично перво¬му, но использует передаваемый дополнительным параметром бинарный предикат вместо оператора сравнения на равенство ==. Нижеприведенная программа демонстрирует обе версии:
// equal.срр: Алгоритмы equal, iinclude <iostream> iinclude <iomanip> iinclude <algorithm> using namespace std;
bool approxfint a, int b){return abs(a - b) <= 1;}
 
int main() {   int     a
 
{50, 80, 30, 90}, {50, 80, 30, 90, 20}, {50, 79, 30, 90};
 
cout « equal(a, a+4, b) << endl;	111
cout « equal(a, a+4, c) << endl;	// 0
cout << equal(a, a+4, c, approx) << endl; // 1 return 0;
}
Функция возвращает булевское значение true (= 1) или false (= 0), как показано в комментариях. Поскольку четыре элемента а совпадают с пер¬выми четырьмя элементами Ь, первый вызов equal возвращает true. Второй вызов возвращает false, потому что а[1] = 80, в то время как с[1] = 79. В третьем вызове разница 80 - 79 является достаточно малой (в соответ¬ствии с определением функции approx), чтобы функция equal вернула true. Обратите внимание, что функция equal не возвращает информацию о по¬зиции, в которой последовательности не совпадают. Если нужна такая информация, следует пользоваться алгоритмом mismatch.
7.1.5. Поиск подпоследовательности
Forwardlteratorl search
(Forwardlteratorl firstl,	Forwardlteratorl lastl,
ForwardIterator2 first2,	ForwardIterator2 last2);
Forwardlteratorl search
(Forwardlteratorl firstl,	Forwardlteratorl lastl,
ForwardIterator2 first2,	ForwardIterator2 last2,
BinaryPredicate   predicate)  ;
Первый вариант алгоритма search является обобщением известной функции поиска из библиотеки С, которая используется в следующем фрагменте:
#include <string.h>
char *р = strstr("ABCDEF",   "CD");  /* *p == "C  */
Библиотечная функция strstr возвращает NULL, если второй аргумент не является подстрокой первого.
Первый вариант search используется для поиска (меньшей) подпоследовательности в (большей) последовательности, использует два первых парамет¬ра для задания большей последовательности (в которой ищут) и два следую¬щих для меньшей (которую ищут). Второй вариант использует передаваемый пятым параметром бинарный предикат вместо оператора сравнения на равен¬ство ==. Следующая программа показывает работу обоих алгоритмов search:
II search.срр: Алгоритмы search. #include <iostream> ¦include <algorithm> using namespace std;
bool difl(int х,  int у){return х + 1 == у;} int main()
{   int     а[б]  = {10, 20, 50, 30, 60, 40}, b[2] = {50, 30},
с[3] = {51, 31, 61}, *pl,  *р2, *рЗ; pi = searchfa, а+6, b, b+2); cout << pi - а << " "; р2 = search(а, а+6, с, с+3); cout « р2 - а << " "; рЗ = search(а, а+6, с, с+3, difl); cout « рЗ - а
<< endl;  // Вывод: 2 6 2 return 0;
}
При первом вызове элементы Ь[0] и Ь[1] были найдены как а[2] и а[3], поэтому функция search возвратила адрес элемента а[2], который был со¬хранен в указателе pi. Поскольку три элемента массива с отсутствуют в а, указатель р2 получает значение, ссылающееся на элемент, непосредствен¬но следующий за последним элементом массива а. И наконец, рЗ присваи¬вается адрес а[2], потому что элементы 50, 30 и 60 массива а соответству¬ют элементам 51, 31 и 61 массива с согласно предикату difl.
7.2. Модифицирующие последовательные алгоритмы
Алгоритмы в этом разделе изменяют последовательность, с которой работают. 7.2.1. Преобразовать
Outputlterator transform
(Inputlterator first, Inputlterator last, Outputlterator result, UnaryOperation unary_op); Outputlterator transform
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, Outputlterator result, BinaryOperation binary_op);
Мы обсуждали алгоритмы transform в разделе 6.5, когда рассматривали функциональные объекты. Вспомним, что существуют два алгоритма transform: первый преобразует одну последовательность, а второй - две. Следующая программа использует оба алгоритма другим способом, неже¬ли в примерах раздела 6.5: мы теперь применяем обычные функции вмес¬то функциональных объектов. Так как вектор result изначально пуст, пер¬вый вызов transform работает в режиме вставки (с помощью адаптера inserter), как рассмотрено в разделе 1.6. После этого вектор result содержит пять элементов, поэтому во втором вызове transform мы можем использовать режим замещения и заменить эти элементы.
// transfor.cpp: Два алгоритма transform, ¦include <iostream> ¦include <vector> ¦include <algorithm> using namespace std;
int pluslfint x){return x + 1;}
int largersq(int x, int у){return x > у ? x*x : y*y;} int main()
{   int     a[5] = {2,  -4, 3, 5, 1}, b[5]  = {1,  -3, 5, 2, 4}; vector<int> result; transformfa, a+5,
inserter(result, result.begin()), plusl); copy(result.begin(), result.end(),
ostream_iterator<int>(cout,  "  ")); cout << endl;    // Вывод: 3-3462 transformfa, a+5, b, result.begin(), largersq); copy(result.begin(), result.end(),
ostream_iterator<int>(cout, " ")); cout « endl; // Вывод: 4 9 25 25 16 return 0;
}
Как указано в комментариях, первый результат получается добавлением единицы ко всем элементам массива а. Второй вызов transform вычисляет квадрат большего из соответствующих элементов массивов а и Ь. К приме¬ру, result[0] = 4, потому что это квадрат большего значения (2) из а[0] и Ь[0].
7.2.2. Копировать
Outputlterator сору
(Inputlterator first, Inputlterator last, Outputlterator result); BidirectionalIterator2 copy_backward (Bidirectionallteratorl firstl, Bidirectionallteratorl lastl, BidirectionalIterator2 last2);
Алгоритм copy рассматривался в разделе 1.6. В примерах этого раздела источник и приемник копирования никогда не перекрывались. Если же они перекрываются, необходимо правильно выбрать, какой из алгоритмов использовать: сору, который копирует элементы в прямом порядке, либо copy jbackword, копирующий в обратном порядке. Например, если мы хо¬тим сдвинуть элементы а[1], а[2] и а[3] массива а на одну позицию влево, самый элементарный способ достичь этого следующий:
for  (i=l;  i<4;  i++)  a[i-l]  = a[i];
Алгоритм сору делает то же самое, как показывает следующая программа:
// сору1.срр: Сдвиг элементов массива влево, ¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{   int a[4]  = {10, 20, 30, 40}, i; cout « "Before shifting left:  "; for (i=0; i<4; i++) cout << a[i] << "  "  ; copy(a+1, a+4, a); cout << "\nAfter shifting left: for (i=0; i<4; i++) cout << a[i] << "  "  ; cout << endl; return 0;
}
Напомним, что первые два параметра сору задают источник, а третий - прием¬ник. Программа сдвигает три элемента массива влево, как видно из ее вывода:
Before shifting left: 10 20 30 40 After shifting left:    20 30 40 40
Противоположная операция - сдвиг элементов а[0], а[1] и а[2] массива, содержащего четыре элемента, вправо - может быть проведена следую¬щим образом:
for (i=2;  i>=0;  i--) a[i+l]  = a[i];
Обратите внимание, что мы должны двигаться назад, уменьшая i. Про¬грамма, приведенная ниже, показывает, что алгоритм copyjbackward дела¬ет то же самое:
// сору2.срр: Сдвиг элементов массива вправо, ¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{   int a[4]  = {10, 20, 30, 40}, i; cout << "Before shifting right:  "; for (i=0;  i<4;  i++) cout « a[i]  « "  "  ; copy_backward(a, a+3, a+4); cout << "\nAfter shifting right:    "; for  (i=0;  i<4;  i++) cout << a[i]  « "  "  ; cout << endl; return 0;
Как и для сору, первые два аргумента copy jbackward указывают источник. Однако третий аргумент указывает позицию за последним элементом при¬емника; другими словами, это значение будет уменьшаться перед каждым шагом алгоритма, включая первый шаг. Вывод этой программы следующий:
Before shifting right: 10 20 30 40 After shifting right:    10 10 20 30
В рассмотренных программах несколько раз встречается строчка:
for  (i=0;  i<4;  i++) cout « a[i]  « "  "  ;
Вместо нее мы можем использовать тот же алгоритм сору, как рассказано ранее в разделе 1.9:
copyfa, a+4, ostream_iterator<int>(cout, " "));
В некоторых дальнейших примерах нами будет использован также и этот метод.
7.2.3. Переместить по кругу
void rotate
(Forwardlterator first, Forwardlterator middle,
Forwardlterator last); Outputlterator rotate_copy
(Forwardlterator first, Forwardlterator middle,
Forwardlterator last, Outputlterator result);
Иногда возникает необходимость вместо сдвига на несколько позиций влево или вправо переместить элементы последовательного контейнера по кругу. Например, преобразовать
10 20 30 40
в следующую последовательность
20 30 40 10
Это преобразование может считаться циклическим сдвигом влево на одну позицию. Однако с таким же успехом мы можем считать его циклическим сдвигом вправо на три позиции. Поэтому существует только один алгоритм rotate. Вместо того чтобы указывать количество позиций и направление сдвига, мы просто задаем элемент, который должен стать первым. Аргумент функции, используемый для этой цели, следует вторым, а первый и третий аргументы определяют диапазон, к которому применяется циклический сдвиг. Чтобы осуществить сдвиг в приведенном выше примере для массива из четырех элементов, требуется, следовательно, вызвать алгоритм rotate следующим образом:
rotatefa, а+1, а+4);
Параметр а+1 показывает, что элемент а[1] = 20 должен стать первым в новой последовательности. Целиком программа приведена ниже:
// rotate.срр: Циклический сдвиг. #include <iostream> #include <algorithm> using namespace std;
int main()
{   int a[4] = {10, 20, 30, 40};
cout << "Initial contents of array a:
copyfa, a+4, ostream_iterator<int>(cout, " "));
rotatela, a+1, a+4);
cout « "\nAfter rotate(a, a+1, a+4):     "; copyfa, a+4, ostream_iterator<int>(cout, " ")); cout << endl; return 0;
}
Программа выводит следующий текст:
Initial contents of array a: 10 20 30 40 After rotatefa, a+1, a+4):     20 30 40 10
Если после имеющегося в программе вызова rotate добавить следующий вызов:
rotatefa, а+3 а+4);
элемент а[3] = 10 снова станет а[0], что восстановит в результате первона¬чальную последовательность 10, 20, 30, 40.
В STL определена также функция rotate_copy, которая помещает ре¬зультат циклического сдвига в другой контейнер, так что источник остает¬ся неизменным. Контейнер-приемник задается четвертым аргументом функции, как в следующей программе:
// rotсору.срр: Алгоритм rotate_copy. #include <iostream> #include <algorithm> using namespace std;
int mainf)
{   int a[4] = {10, 20, 30, 40}, b[4]; rotate_copy(a, a+1, a+4, b);
copy(b, b+4, ostream_iterator<int>(cout,  " "));
cout « endl;  // Вывод: 20 30 40 10 return 0;
}
7.2.4. Обменять
void swap
(T& x, T& у) ; void iter_swap
(ForwardIteratorl& a, ForwardIteratorl& b) ; ForwardIterator2 swap_ranges
(Forwardlteratorl firstl, Forwardlteratorl lastl,
ForwardIterator2 first2);
Алгоритм swap меняет значения двух объектов одного и того же типа, как показывает следующая программа:
// swap.срр: Поменять два значения, ¦include <iostream> ¦include <algorithm> using namespace std;
int mainO
{   double    a = 3.14159, b = 2.71828; swap(a, b);
cout << a << "  " << b << endl; //     2.71828        3.14159 return 0;
}
Если мы имеем два итератора, то можем использовать алгоритм iter_swap для обмена местами значений, на которые ссылаются эти итераторы, например:
// it_swap.cpp: Алгоритм iter_swap. ¦include <iostream> ¦include <list> ¦include <algorithm> using namespace std;
int main()
{    list<int> L;
list<int>::iterator i, j;
L.push_back(123) ;
L.push_back(456);
copy (L. begin () , L.endO,
ostream_iterator<int>(cout,  "  "));
cout « endl;    // Вывод:  123 456
i = L.begin();
j = i; ++j;
iter_swap(i, j);
copy (L. begin () , L.endO,
ostream_iterator<int> (cout,  " ")); cout « endl;    // Вывод: 456 123 return 0;
}
Алгоритм swap_ranges меняет местами два диапазона значений. Эти кон¬тейнеры не должны перекрываться, и они могут относиться к разным ти¬пам, как показывает следующая программа:
// swranges.срр: Поменять местами диапазоны значений. #include <iostream> #include <vector> #include <algorithm>
using namespace std;
int main()
{    int a[3] = {10, 20, 30}; vector<int> v;
v.push_back(100); v.push_back(200); v.push_back(300); swap_ranges(v.begin(), v.endf), a); cout << "After swap_ranges:\n"; cout << "i     a[i]     v[i]\n"; for (int i=0; i<3; i++)
cout   « i << "      " << a[i] « " « v[i] << endl;
return 0;
}
Вывод программы:
After swap_ranges: i     a[i]     v[i]
0	100        10
1	200	20
2	300	30
Как видно из рассмотренного примера программы, первые два аргумента функции swap_ranges задают один диапазон, а третий аргумент задает на¬чало второго диапазона. Поскольку операция обмена симметрична по от¬ношению к своим аргументам, программа будет работать точно так же, если мы заменим вызов
swap_ranges(v.begin(), v.endf), а);
на
swap_ranges(а, а+3, v.begin О);
7.2.5. Заменить
void replace
(Forwardlterator first, Forwardlterator last, const T& old_value, const T& new_value); void replace_if
(Forwardlterator first, Forwardlterator last, Predicate pred, const T& new_value); Outputlterator replace_copy
(Inputlterator first, Inputlterator last, Outputlterator result,
const T& old_value, const T& new_value); Outputlterator repJace_copy_if
(Inputlterator first, Inputlterator last, Outputlterator result, Predicate pred, const T& new_value);
В разделе 1.10 нами уже обсуждался алгоритм replace. Напомним, что мы можем в имеющемся целочисленном массиве а, определенном как
int а[5] = {8, 8, 8, 0, 8}; заменить все элементы со значением 8 на 1, выполнив
replacefa, а+5, 8, 1);
что даст в результате массив, содержащий 1, 1, 1, 0, 1.
В STL также определена функция replace_if, которая имеет отличаю¬щийся третий аргумент - унарный предикат, задающий некоторое усло¬вие. Все элементы, удовлетворяющие этому условию, будут заменены на значение, заданное четвертым аргументом функции. Алгоритм replace_if демонстрирует следующая программа:
// repl_if.срр: Заменить все ненулевые элементы массива
//	на 1.
#include <iostream> #include <algorithm> using namespace std;
bool nonzero(int x)  {return x != 0;}
int main()
{   int a[5]  = {10, 20, 30, 0, 40}; replace_if(a, a+5, nonzero, 1); cout « "After replace_if:\n"; copyfa, a+5, ostream_iterator<int>(cout, " ")); cout << endl; return 0;
Все ненулевые элементы в массиве {10, 20, 30, 0, 40} заменяются на 1, по¬этому программа выводит:
After replace_if: 1110 1
Два алгоритма replace_сору и replace_copy_if очень похожи на replace и replace jf. Вместо того чтобы производить замену в исходном контейнере, они сначала копируют этот контейнер в другой, а затем заменяют элементы в новом контейнере, не модифицируя источник. Третий аргумент этих фун¬кций задает начало контейнера, в котором будет храниться результат копи¬рования и замены, что мы покажем в следующей программе:
// replcopy.срр: replace_copy и replace_copy_if. #include <iostream> #include <vector> #include <algorithm> using namespace std;
bool not_ten(int x)   {return x != 10;} int main()
{   int a[5] = {10, 20, 20, 10, 40}; cout « "Array a:\n";
copyfa, a+5, ostream_iterator<int>(cout, " ")); vector<int> v; vector<int>::iterator i;
replace_copy(a, a+5, inserterfv, v.beginf)), 20, 49);
cout « "\n\nAfter the execution of\n     replace_copy"
"(a, a+5, inserterfv, v.beginf)), 20, 49);"
"\nvector v has the following contents:\n"; copy(v.begin(), v.endf),
ostream_iterator<int>(cout, " ")); replace_copy_if(a, a+5, v.beginf), not_ten, 99); cout « "\n\nAfter the execution of\n"
"     replace_if_copy(a, a+5, v.beginf),  "
"not_ten, 99);"
"\nvector v has the following contents:\n"; copy(v.begin(), v.endf),
ostream_iterator<int>(cout,  " ")); cout « endl; return 0;
}
В приведенной программе вектор v сначала пуст, поэтому мы используем режим вставки при первом вызове алгоритма replace_copy. Он копирует массив а в вектор v, заменяя значения 20 на 49. После этого алгоритм replace_copy_if делает такую же операцию, но заменяя все значения, отлич¬ные от 10, на 99 в режиме замещения. Все это ясно видно из вывода, кото¬рый создает эта программа:
Array а:
10 20 20 10 40
After the execution of
replace_copy (a, a+5, inserterfv, v.beginf)), 20, 49); vector v has the following contents: 10 49 49 10 40
After the execution of
replace_if_copy(a, a+5, v.beginf), not_ten, 99); vector v has the following contents: 10 99 99 10 99
7.2.6.	Удалить
Forwardlterator remove
(Forwardlterator first, Forwardlterator last, const T& value); Forwardlterator remove_if
(Forwardlterator first, Forwardlterator last, Predicate pred); Outputlterator remove_copy
(Inputlterator first, Inputlterator last, Outputlterator result, const T& value); Outputlterator re/nove_copy_if
(Inputlterator first, Inputlterator last, Outputlterator result, Predicate pred);
Алгоритмы remove и remove_if мы обсуждали в разделе 1.13. Как видно из названий remove_сору и remove_copy_if двух других вариантов, они рабо¬тают с копией, а не с исходным контейнером. Поскольку принцип дей¬ствия здесь тот же, что и у только что рассмотренных нами функций replace сору и replace _copy_if мы не будем подробно обсуждать эти вари¬анты алгоритма remove.
7.2.7.	Заполнить
void fill
(Forwardlterator first, Forwardlterator last, const T& value); void fill_n
(Outputlterator first, Size n, const T& value);
Алгоритм fill (заполнить) присваивает заданное значение всем элементам диапазона. Как обычно, диапазон задается с помощью двух итераторов. Алгоритм fill_n работает так же, как и fill, но в этой функции диапазон задается с помощью одного итератора и количества элементов. Следующая программа использует оба алгоритма:
// fill.срр: Алгоритмы fill и fill_n. ¦include <iostream> ¦include <algorithm> using namespace std;
int main() {   int a[5] ;
fill(a, a+5, 123);
copyfa, a+5, ostream_iterator<int>(cout,  " ")); cout << endl; fill_n(a, 2, 456);
copyfa, a+5,    ostream_iterator<int>(cout, " ")); cout « endl; return 0;
}
Сначала программа присваивает значение 123 первым пяти элементам массива а. Затем два первых элемента заменяются на 456, что и показано в выводе программы:
123 123 123 123 123 456 456 123 123 123
Для векторов, массивов и двусторонних очередей вторая версия не нужна, поскольку эти контейнеры работают с итераторами произвольного досту¬па, так что мы можем заменить
fill_n(i, п, х);
на
fill(i, i+n, х);
когда имеем дело с этими контейнерами. Не так обстоит дело со списками: если i является итератором для списка, выражение i + п недопустимо.
7.2.8. Породить
void generate
(Forwardlterator first, Forwardlterator last, Generator gen); void generate_n
(Outputlterator first, Size n, Generator gen);
Вместо того чтобы использовать постоянное значение для заполнения контейнера, иногда желательно вычислить свое значение для каждого эле¬мента. Это можно сделать с помощью алгоритма generate (породить).
В качестве третьего параметра этого алгоритма выступает функция или функциональный объект. Следующая программа помещает значения 10, 12, 14, 16 и 18 в массив а:
II generate.срр: Алгоритм generate, ¦include <iostream> ¦include <algorithm> using namespace std;
struct funobj  { int i ;
funobj(): i(8){}
int operator()(){return i += 2;}
};
int main() {   int a[5];
generate(a, a+5, funobj());
copyfa, a+5, ostream_iterator<int>(cout, " ")); cout « endl;    // Вывод: 10 12 14 16 18 return 0;
}
Обратите внимание, что мы используем функциональный объект, который содержит кроме определения функции operatorV) также определение конст¬руктора и переменную-член i целого типа. Эта переменная при инициализа¬ции объекта получает значение 8 и увеличивает свое значение на 2 каждый раз, когда происходит вызов функции operatorQ, вследствие чего эта функ¬ция последовательно возвращает значения 10, 12, 14, 16 и 18.
Мы могли бы заполнить массив а теми же значениями, используя функцию
int fun()
{   static int i=8; return i += 2;
}
вместо класса funobj и изменив вызов generate следующим образом:
generate(a, a+5,  fun);
Однако имеется тонкое различие: если бы мы вызывали generate в програм¬ме два раза и использовали функцию fun вместо функционального объекта, то во втором вызове generate переменная i не получит значение 8; когда же мы используем функциональный объект funobj, каждый вызов алгоритма generate будет начинаться с присваивания 8 этой переменной.
Если а определен как вектор или двусторонняя очередь, содержащая, по крайней мере, 5 элементов, мы можем использовать вызов
generate(a.begin(), a.begin()+5, fun);
Однако со списком мы не можем поступить подобным образом, поскольку оператор сложения не определен для двунаправленных итераторов. К сча¬стью, существует функция generate_n, которая работает в том числе и со списком. Следующая программа отличается от предыдущей двумя аспек¬тами: она использует функцию fun вместо функционального объекта funobjC), а также использует алгоритм generate_п, чтобы мы могли задать диапазон из пяти элементов для списка.
// gen_n.cpp: Алгоритм generate_n. ¦include <iostream> ¦include <algorithm> ¦include <list> using namespace std;
int fun()
{   static int i=8; return i += 2;
}
int main()
{   list<int> a(5);
generate_n(a.begin(), 5, fun);
copy(a.begin(), a.end(),
ostream_iterator<int>(cout, " "));
cout « endl;    // Вывод: 10 12 14 16 18
return 0;
}
7.2.9. Убрать повторы
Forwardlterator unigue
(Forwardlterator first, Forwardlterator last); Forwardlterator unigue
(Forwardlterator first, Forwardlterator last, BinaryPredicate binary_pred); Outputlterator unigue_copy
(Inputlterator first, Inputlterator last, Outputlterator result); Outputlterator unigue_copy
(Inputlterator first, Inputlterator last, Outputlterator result, BinaryPredicate binary_pred);
Алгоритм unique удаляет стоящие рядом одинаковые элементы в задан¬ном диапазоне. Этот алгоритм напоминает remove тем, что не изменяет размер контейнера. Размер массива мы все равно не можем изменить, но ал¬горитм не изменяет размеры и любых других контейнеров, будь то вектор, двусторонняя очередь или список. Кстати, если возникает необходимость использовать этот алгоритм для списков, лучше воспользоваться функци¬ей-членом unique класса list, поскольку она более эффективна. Напомним, что эту функцию-член мы рассматривали в разделе 3.5. Алгоритм unique возвращает новый логический конец данных, как показывает следующая программа:
// uniquel.срр: Первый из алгоритмов unique, ¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{   int a[10] = {3, 4, 3, 3, 4, 4, 5, 3, 3, 3}, *p; p = unique(a, a+10);
cout << "New logical contents of array a:\n"; copy(a, p, ostream_iterator<int>(cout,  "  ")); cout « endl; return 0;
}
Программа выводит следующий текст:
New logical contents of array a: 3 4 3 4 5 3
Вместо использования операции сравнения на равенство мы можем задать любой бинарный предикат, воспользовавшись вторым вариантом алгорит¬ма с тем же именем, который принимает предикат в качестве третьего ар¬гумента. Следующая программа использует этот вариант алгоритма unique, чтобы удалить каждый из элементов вектора, который больше пре¬дыдущего на единицу:
// unique2.cpp: Второй из алгоритмов unique. //       Удалить v[i+l], если он равен v[i]  + 1. ¦include <iostream> ¦include <vector> ¦include <algorithm> using namespace std;
bool onehigher(int x, int у){return x + 1 == y;} int main()
{   int a[10] = {3, 4, 3, 1,  6, 7, 7, 7, 8, 4}; vector<int> v; vector<int>::iterator i;
for (int k=0; k<10; k++) v.push_back(a[k]);
i = unique(v.beginf), v.endf), onehigher); cout << "Logical contents of v:\n";
copy(v.begin(), i, ostream_iterator<int>(cout, " ")); cout << "\nv.size()  = " << v.sizeO << endl; return 0;
}
Программа начинает свою работу с помещения значений в вектор v.
3431677784
Поскольку v[l] (= 4) на единицу больше предшествующего элемента v[0], этот элемент будет удален из результата. Та же участь постигнет элемент v[5] (= 7), потому что его предшественник v[4] равен 6. Хотя на первый взгляд может показаться, что значение 8 также не попадет в результат, потому что следует за 7, это не так: после удаления всех элементов, равных 7, 8 окажет¬ся после 6 и останется нетронутым, как показывает вывод программы:
Logical contents of v: 3 3 1 6 8 4 v.sizeO = 10
Заметим, что размер вектора по-прежнему остается равен 10, но логичес¬кое содержание составляет только поддиапазон [v.beginQ, i). Ситуация похожа на массив символов, в котором обычно используется только на¬чальная часть, заканчивающаяся символом '\0'.
Если после вызова unique мы захотим изменить размер вектора, равный usizeQ = 10, в соответствии с его новым логическим размером i - v.beginQ = 6, то можем это сделать с помощью функции-члена erase:
v.erased, v.endf));
Существуют также две функции unique_сору, которые похожи на функции unique, за исключением того, что результат их работы копируется в другой контейнер. Мы могли бы использовать эти функции в программе uniquel.cpp следующим образом. Фрагмент
vector<int> v; vector<int>::iterator i;
for (int k=0; k<10; k++) v.push_back(a[k]); i = unique (v.beginf) , v.endO, onehigher);
можно заменить на более короткий
vector<int> v(10,0); vector<int>::iterator i;
i = unique_copy(a, a+10, v.beginf), onehigher);
После такой замены программа будет работать так же, как и приведенная выше версия.
Другой вариант функции unique сору похож на первую версию unique. Он проверяет последовательные элементы на равенство. Мы можем ис¬пользовать эту версию в выражении
i = unique_copy(a, a+10, v.beginf));
7.2.10.	Расположить в обратном порядке
void reverse
(Bidirectionallterator first, Bidirectionallterator last); Outputlterator reverse_copy
(Bidirectionallterator first,
Bidirectionallterator last, Outputlterator result);
Напомним, что алгоритм reverse мы обсуждали в разделе 1.10. Алгоритм reversecopy не изменяет заданный диапазон, а помещает элементы в обрат¬ном порядке в другой контейнер, как показано в следующей программе:
// гсору.срр: Алгоритм reverse_copy помещает
//	результат в другой контейнер,
¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{   int a[3]  = {10, 20, 30}, b[3] ; reverse_copy(a, a+3, b);
copy(b, b+3, ostream_iterator<int>(cout,  " ")); cout « endl;  // Вывод: 30 20 10 return 0;
}
7.2.11.	Перетасовать
void random_shuffle
(RandomAccessIterator	first,
RandomAccessIterator	last);
void random_shuffle
(RandomAccessIterator	first,
RandomAccessIterator	last,
RandomNumberGeneratorSc rand) ;
Алгоритм random shuffle размещает элементы контейнера в случайном порядке, как показывает следующая программа:
// rshuffle.срр: Тасование, ¦include <iostream>
¦include <algorithm> using namespace std;
int main()
{   int a[6] = {10, 20, 30, 40, 50, 60}; random_shuffle(a, a+6);
copyfa, a+6, ostream_iterator<int>(cout, " ")); cout « endl; return 0;
}
Когда мы запустили эту программу в первый раз, она напечатала
40 10 60 30 20 50
Мы запускали эту программу несколько раз, но результат оставался тем же самым. Это объясняется тем, что алгоритм random_shujcfle основан на гене¬раторе псевдослучайных чисел, который работает одинаково (использует одну и ту же «затравку») каждый раз, когда мы запускаем программу.
Вторая версия randomjshuffle в STL принимает в качестве третьего аргу¬мента генератор случайных чисел. Это позволит получать разные результа¬ты при разных запусках программы. Функция-генератор случайных чисел должна получать аргумент п типа int и возвращать случайным образом выб¬ранное целое значение в диапазоне [0, п). Генератор случайных чисел также может быть функциональным объектом, как в следующей программе:
// rshuffl.cpp: Тасование; используем свой генератор.
¦include <iostream>
¦include <stdlib.h>
¦include <time.h>
¦include <algorithm>
using namespace std;
struct myrandom { myrandom()
{   srand((unsigned int)time(NULL)); }
int operator()(int n){return rand() % n;}
};
int main()
{   int a[6] = {10, 20, 30, 40, 50, 60}; random_shuf f le (a, a+6, myrandomO); copyfa, a+6, ostream_iterator<int>(cout, " ")); cout « endl; return 0;
При первом запуске эта программа напечатала
50 10 30 20 40 60 Когда мы запустили ее еще раз, результат был отличный:
10 30 60 40 20 50
Кстати, вместо класса myrandom мы можем использовать функцию
int randfun(int n) {    static int first = 1; if (first)
{    srand((unsigned int)time(NULL)); first = 0;
}
return rand() % n;
}
если мы также заменим вызов random_shuj"fie на следующий:
random_shuffie(a, a+6, randfun);
7.2.12. Разделить
Bidirectionallterator partition (Bidirectionallterator first, Bidirectionallterator last, Predicate pred); Bidirectionallterator stable_partition (Bidirectionallterator first, Bidirectionallterator last, Predicate pred);
Алгоритм partition образует два раздела в заданном диапазоне. Он разме¬щает элементы, удовлетворяющие заданному условию, перед теми, кото¬рые этому условию не соответствуют. В следующей программе массив а содержит целые числа, часть из них меньше 50. Мы используем алгоритм partition, которому передаем предикат «меньше 50» для перестановки эле¬ментов массива а таким образом, что все элементы, удовлетворяющие ука¬занному условию, будут предшествовать элементам, чье значение больше или равно 50. Алгоритм возвращает значение итератора, ссылающееся на первый элемент во втором разделе:
// partitio.cpp: Алгоритм partition, ¦include <iostream> ¦include <algorithm> using namespace std;
bool below50(int x){return x < 50;}
 
int main()
{   int а[8]  = {70, 40, 80, 20, 50,  60, 50, 10}; int *р = partitionfa, а+8, below50); copyfa, р, ostream_iterator<int>(cout,  "  ")); cout « "    ";
copy(p, a+8, ostream_iterator<int>(cout,  "  ")); cout << endl; return 0;
}
Массив а содержит три элемента (40, 20 и 10), которые меньше, чем 50. После вызова partition эти элементы группируются в начале массива, как показывает вывод программы:
10 40 20     80 50 60 50 70
Значение р - а равно длине (3) первого раздела. Один из двух разделов может оказаться пустым. Например, если в функции below5Q мы заменим 50 на 1000, получим р - а = 8, а если в этой функции заменим 50 на 0,р - а станет равным 0.
Обратите внимание, что элементы 40, 20 и 10, меньшие 50, не сохра¬няют свой первоначальный относительный порядок, как не сохраняют его и остальные элементы (70, 80, 50, 60, 50). Если мы хотим, чтобы от¬носительный порядок элементов в каждом из разделов остался прежним, нам достаточно заменить вызов partition на stable jpartition, написав
int *р = stable_partition(а, а+8, below50);
В результате мы получим следующий вывод программы, где элементы в каждом из разделов сохраняют тот же порядок, что и в исходной после¬довательности:
40 20 10     70 80 50 60 50
Алгоритм stable jpartition обычно требует большего времени для выполне¬ния, чем алгоритм partition; если бы это было не так, разработчики STL, без сомнения, сохранили бы только алгоритм, осуществляющий стабиль¬ное разделение последовательности.
Кстати, на разделении последовательности основан известный метод быстрой сортировки (quicksort).
7.3. Алгоритмы, связанные с сортировкой
В этом разделе собраны алгоритмы, имеющие отношение к сортировке. Для каждого из них существуют две версии: одна использует оператор <, а другая - любую заданную функцию сравнения.
7.3.1.	«Меньше» и другие операции сравнения
Алгоритмы, связанные с сортировкой, зависят от операции отношения, для которой мы часто используем оператор <. Вместо этого мы могли бы исполь¬зовать оператор «больше» или другой бинарный предикат сравнения. Одна¬ко такой предикат нужно выбирать внимательно. Он должен быть похож на оператор < в плане соответствия следующим требованиям.
Если х < у и у < z, то х < z.
Если х < у, то выражение у < х ложно.
Заметим, что оба эти утверждения справедливы для операции >, но не для >=, <=, == или !=.
7.3.2.	Сортировка
void sort
(RandomAccessIterator first, RandomAccessIterator last); void sort
(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
Мы обсуждали алгоритм sort, использующий оператор сравнения <, в раз¬деле 1.4 и более общий вариант, использующий передаваемый в качестве параметра предикат сравнения, в разделах 1.11 и 1.12. Вспомним, что мож¬но отсортировать массив N целых чисел а в порядке возрастания, написав
sort(a, a+N);
тогда как для сортировки в порядке убывания мы напишем
sort(a, a+N, greater<int>());
7.3.3.	Стабильная сортировка
void stable_sort
(RandomAccessIterator	first,
RandomAccessIterator	last);
void stable_sort
(RandomAccessIterator	first,
RandomAccessIterator	last, Compare comp);
Чтобы обсудить концепцию стабильной сортировки, лучше сортировать структуры, а не целые числа. Следующая программа сортирует массив из 20 записей, каждая из которых содержит строку и целое число. В качестве ключей будут использованы строки, поэтому после сортировки они раз¬местятся в лексикографическом порядке. Мы реализуем это, определяя оператор < таким образом, что a[i] < a[j], если a[i].s лексикографически предшествует a\j].s. До сортировки в переменных-членах пит структур, хранящихся в элементах массива а[0], а[1],а[19], содержатся значения 10, 11,..., 29.
// sortree.срр: Сортировка структур, ¦include <iostream> ¦include <string> ¦include <algorithm> using namespace std;
struct rectype
{   string s; int num;
bool operator<(const rectype &b)const
{   return s < b.s;
}
};
int mainO
{   const int N = 20; string t[20] =
{"Judy", "John", "John",  "Judy", "John",
"Judy", "Paul", "Judy", "Paul", "Mary",
"Mary", "John", "Judy", "Paul", "John",
"Paul", "Judy", "John", "Judy", "Judy"}; int k;
rectype a[N];
for (k=0; k<N; k++)
{   a[k].s = t[k]; a[k].num = 10 + k;
}
sort(a, a+N);
for (k=0; k<N; k++)
{   cout   « a[k].s « " "
« a[k].num «  (k % 5 == 4 ? "\n"  :  "    ");
}
return 0;
}
Программа создает следующий вывод:
John 11	John 12	John 14	John	27	John	24
John 21	Judy 29	Judy 28	Judy	26	Judy	22
Judy 17	Judy 15	Judy 13	Judy	10	Mary	20
Mary 19	Paul 18	Paul 23	Paul	25	Paul	16
В этом отсортированном списке имена следуют в лексикографическом по¬рядке. Как вы можете заметить уже в первой из четырех выведенных строк, номера, связанные с одним и тем же ключом, следуют не по возрастанию.
Поскольку до сортировки они шли в порядке возрастания, мы видим, что относительный порядок при сортировке не сохранен. Например, в сортиро¬ванном массиве записи (John, 27) и (John, 24) появляются перечислением, хотя изначально запись (John, 24) была расположена раньше, чем (John, 27). Это происходит из-за того, что алгоритм sort нестабилен. Однако для него есть и стабильная версия. Чтобы использовать ее, мы просто заменим вызов алгоритма sort на следующий:
stable_sort(a, a+N);
После этой модификации программа напечатает:
John 11	John	12	John	14	John	21	John 24
John 27	Judy	10	Judy	13	Judy	15	Judy 17
Judy 22	Judy	26	Judy	28	Judy	29	Mary 19
Mary 20	Paul	16	Paul	18	Paul	23	Paul 25
Записи с равными ключами (как те, которые содержат имя John) теперь располагаются в порядке возрастания чисел; другими словами, относи¬тельный порядок этих записей сохраняется.
Как и для алгоритма sort, для stablejsort существует версия, которая в качестве третьего аргумента принимает предикат.
7.3.4. Частичная сортировка
void partial_sort
(RandomAccessIterator	first,
RandomAccessIterator	middle,
RandomAccessIterator	last);
void partial_sort
(RandomAccessIterator	first,
RandomAccessIterator	middle,
RandomAccessIterator	last, Compare comp);
RandomAccessIterator partial_sort_copy
(Inputlterator first,	Inputlterator last,
RandomAccessIterator	result_first,
RandomAccessIterator	result_last);
RandomAccessIterator partial_sort_copy
(Inputlterator first,	Inputlterator last,
RandomAccessIterator	result_first,
RandomAccessIterator	result_last, Compare comp);
Если нас интересуют только первые п элементов полностью отсортирован¬ной последовательности, где п меньше длины последовательности, то нет необходимости полностью сортировать эту последовательность. В следую¬щей программе элементы а[0], а[1], а[2] и а[3] получают те же значения, которые они имели бы в полностью отсортированном массиве:
// partsort.срр: Частичная сортировка, ¦include <iostream> ¦include <string> ¦include <algorithm> using namespace std;
int main()
{   int a[10]  = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}; partial_sort(a, a+4, a+10); for  (int k=0; k<10; k++)
cout « a[k] «  (k == 3 ? "      "  :  "  "); cout « endl; return 0;
}
Программа выводит следующую строку:
0123     987654
Элементы после первых четырех могут появляться в любом порядке; хотя в этом примере они располагаются в том же относительном порядке, в ка¬ком были изначально, мы не должны рассчитывать на такое поведение.
Другая версия алгоритма partialjsort принимает в качестве четвертого аргумента предикат для сравнения, как аналогичная версия алгоритма sort.
Если мы хотим разместить результаты в диапазоне, отличном от исход¬ного, то можем использовать алгоритмы partial_sort_copy. Снова один из этих двух алгоритмов использует для сравнения оператор «меньше», а дру¬гой - предикат, который передается дополнительным аргументом. Первый вариант, использующий <, встречается в следующей программе:
// partsrt1.срр: partial_sort_copy. ¦include <iostream> ¦include <algorithm> using namespace std;
int mainO
{   int a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}, b[40] , *p;
p = partial_sort_copy(a, a+10, b, b+4); copy(b, p, ostream_iterator<int>(cout,  "  ")); cout << endl;
p = partial_sort_copy(a, a+10, b, b+40); copy(b, p, ostream_iterator<int>(cout,  "  ")); cout << endl; return 0;
}
Алгоритм partial'_sort_copy принимает два диапазона, один задает источник, а другой - приемник. Меньший из этих диапазонов определяет, сколько отсортированных элементов появится в выходном диапазоне-приемнике; в любом случае функция возвращает итератор, ссылающийся на элемент, расположенный сразу за отсортированным поддиапазоном. Приведенная выше программа демонстрирует две ситуации. После первого вызова partialjsortcopy мы имеем р - Ъ = mm( 10, 4) = 4, а после второго вызова р - Ъ = тпгп( 10,40) = 10, как показывает следующий вывод программы:
0 12 3
0234456789
7.3.5. N-й элемент
void nth_element
(RandomAccessIterator first, RandomAccessIterator position, RandomAccessIterator last); void ntn_element
(RandomAccessIterator first, RandomAccessIterator position, RandomAccessIterator last, Compare comp);
После вызова алгоритма nthelement с итератором р в качестве второго аргу¬мента значение *р принимает то же значение, какое будет после полной сор¬тировки этого диапазона. Следующая программа иллюстрирует это:
// nth_elt.cpp: Алгоритм nth_element. ¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{   int a[10] = {4, 12, 9, 5, 6, 6, 6, 4, 8, 10}; nth_element(a, a+2, a+10);
copyfa, a+10,   ostream_iterator<int>(cout,  " ")); cout « endl; return 0;
}
Вывод
4456669 12 8 10
этой программы показывает, что элемент а[2] содержит значение 5. Этот эле¬мент будет иметь такое же значение в полностью отсортированном массиве:
44566689 10 12
Если не считать порядка, содержание массива не меняется. Кроме того, все элементы, предшествующие выбранному элементу, не превышают по значе¬нию этот элемент, а все элементы, следующие за ним, не меньше его.
Три аргумента функции nthjelement являются итераторами произволь¬ного доступа. Вторая версия алгоритма имеет четвертый аргумент, кото¬рый является предикатом для сравнения. Например, если мы заменим вызов nth_element в вышеприведенной программе на
nth_element(a, a+2, a+10, greater<int>());
то получим следующий вывод:
10 12 98666454
Следует обратить внимание, что а[2] = 9, как и в случае, если этот массив будет полностью отсортирован в нисходящем порядке. Элементы, предшествующие а[2], по своему значению не меньше, а те, которые следуют после, по значению не больше этого элемента.
7.3.6. Двоичный поиск
Forwardlterator lower_bound
(Forwardlterator first, Forwardlterator last, const T& value); Forwardlterator lower_bound
(Forwardlterator first, Forwardlterator last, const T& value, Compare comp); Forwardlterator upper_bound
(Forwardlterator first, Forwardlterator last, const T& value); Forwardlterator upper_bound
(Forwardlterator first, Forwardlterator last, const T& value, Compare comp); pair<ForwardIterator, ForwardIterator> egual_range (Forwardlterator first, Forwardlterator last, const T& value); pair<ForwardIterator, ForwardIterator> egual_range (Forwardlterator first, Forwardlterator last, const T& value, Compare comp); bool binary_search
(Forwardlterator first, Forwardlterator last, const T& value); bool binary_search
(Forwardlterator first, Forwardlterator last, const T& value, Compare comp);
В этом разделе мы обсудим четыре алгоритма - lower jbound, upper jbound, equaljronge и binaryjsearch. В нашей программе встретятся только версии, которые используют оператор сравнения <. Для каждого из этих четырех алгоритмов существует также версия, имеющая дополнительный аргумент, предикат сравнения. Все алгоритмы предполагают, что используемый диапазон отсортирован. Программа ниже использует версии четырех ал¬горитмов без дополнительного аргумента-предиката:
// bsearch.cpp: Двоичный поиск и родственные алгоритмы, ¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{   int a[10]  = {3, 3, 5, 5, 5, 5, 5, 7, 8, 9},  *p, k; cout << "Array a:\n";
for  (k=0; k<10; k++)  cout « k « "  "; cout << endl;
for (k=0; k<10; k++)  cout « a[k]  « " cout « endl;
p = lower_bound(a, a+10, 5); cout   « "p - a = " << p - a
« " after p = lower_bound(a, a+10,  5);\n";
p = lower_bound(a, a+10, 4); cout   « "p - a = " « p - a
<< " after p = lower_bound(a, a+10, 4);\n";
p = upper_bound(a, a+10, 5); cout   << "p - a = " << p - a
« " after p = upper_bound(a, a+10, 5);\n";
pair<int*,  int*> P(0, 0); P = equal_range(a, a+10, 5); cout   «
"After P = equal_range(a, a+10, 5) we have:\n"; cout   « "    P.first    - a = " << P.first   - a << endl; cout   « "    P.second - a = " << P.second - a << endl;
bool b = binary_search(a, a+10, 5); cout   << "Results of binary_search:\n"; cout   « "5 " «  (b ? ""   :   "not ")
<< "found in array a.\n"; b = binary_search(a, a+10, 4); cout   « "4 " « (b ? ""  :  "not ")
<< "found in array a.\n"; return 0;
)
В результате мы получаем такой вывод:
Array а:
0123456789 3355555789 р - а = 2 after р = lower_bound(a,	а+10, 5);
р - а = 2 after р = lower_bound(a,	а+10, 4);
р - а = 7 after р = upper_bound(a,	а+10, 5);
After Р = equal_range(а, а+10, 5) we have:
P.first    - a = 2
P.second - a = 7 Results of binary_search: 5 found in array a. 4 not found in array a.
Как показывает этот вывод, алгоритм lowerbound возвращает итератор, ссылающийся на первую позицию, куда можно вставить заданный элемент без нарушения порядка сортировки. Для значений 4 и 5 это позиция а[2]. Аналогично вызов upperbound возвращает значение, указывающее, что а[7] является последней позицией, куда может быть поставлено значение 5 без нарушения сортировки.
Вызов equaljrange сообщает нам, что [2, 7) является диапазоном позиций, куда может быть вставлено значение 5. Если бы мы использовали вызов
Р = equal_range(а, а+10, 4);
тогда значения обоих выражений P.first - а и Rsecond - а были бы равны 2, поскольку а[2] - единственная позиция, куда может быть добавлено значение 4.
Алгоритм binaryjsearch информирует нас, найдено ли искомое значение в диапазоне, но не сообщает, в какой позиции находится это значение, ни в какую позицию его можно добавить, если оно не найдено.
7.3.7. Объединение
Outputlterator merge
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result); Outputlterator merge
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result, Compare comp); void inplace_merge
(Bidirectionallterator first, Bidirectionallterator middle, Bidirectionallterator last); void inplace_merge
(Bidirectionallterator first, Bidirectionallterator middle, Bidirectionallterator last, Compare comp);
Существуют две версии алгоритма merge (объединить), одну из которых мы обсуждали в разделе 1.7. Другая версия имеет шестой аргумент, явля¬ющийся предикатом. Она может быть использована для объединения двух диапазонов, отсортированных в порядке убывания, как показывает следу¬ющая программа:
// merge 1.срр: Объединение двух диапазонов,
//	отсортированных в нисходящем порядке.
¦include <iostream>
¦include <algorithm>
¦include <functional>
using namespace std;
int main()
{   int     a[5] = {30, 28, 15, 13, 11}, b[4]  = {25, 24, 15, 12}, c[9];
merge(a, a+5, b, b+4, c, greater<int>()); copy(c, c+9, ostream_iterator<int>(cout, " ")); cout « endl; return 0;
}
Эта программа выводит:
30 28 25 24 15 15 13 12 11
Напомним, что мы можем опустить последний аргумент в вызове merge, если массивы а и Ъ отсортированы в восходящем порядке.
Если две отсортированные в восходящем порядке последовательности находятся в одном диапазоне [first, last), причем одна из них - [first, middle), а другая - [middle, last), мы можем использовать следующий вызов, чтобы объединить эти последовательности, так что диапазон [first, last) будет полностью отсортирован:
inplace_merge(first, middle, last);
Приведенная ниже программа демонстрирует работу алгоритма inplacejnerge.
II inplace.cpp: Объединение двух
//	отсортированных поддиапазонов.
¦include <iostream>
¦include <algorithm>
using namespace std;
int main()
{   int a[7] =   {2, 5, 8, /* Второй диапазон:  */ 3, 4,  5, 9};
inplace_merge(а, а+3, а+7); сору(а, а+7,
ostream_iterator<int>(cout,  "  ")); cout « endl; return 0;
}
Программа выводит отсортированный полный диапазон:
2 3 4 5 5 8 9
Существует также версия алгоритма inplacejnerge, принимающая в каче¬стве дополнительного аргумента предикат, так что мы можем использовать нашу собственную операцию сравнения, как в программе merge!.
7.3.8. Операции над множествами для сортированных контейнеров
bool includes
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2); bool includes
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Compare comp); Outputlterator set_union
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result); Outputlterator set_union
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result, Compare comp); Outputlterator set_intersect ion
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result); Outputlterator set_intersection
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result, Compare comp); Outputlterator set_difference
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result); Outputlterator set_difference
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result, Compare comp);
Outputlterator set_symmetric_difference
(Inputlteratorl firstl,  Inputlteratorl lastl, InputIterator2 first2,  InputIterator2 last2, Outputlterator result); Outputlterator set_symmetric_difference
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Outputlterator result, Compare comp);
Мы использовали алгоритмы set intersection и setunion для множеств в разделе 4.3. Однако они работают не только с множествами, но и с сорти¬рованными последовательными контейнерами. К сортированным структу¬рам применимы следующие операции над множествами: includes, setjunion, set intersection, set dif}"erence и set_symmetric_difj"erence. Каждый из этих алгоритмов существует в двух версиях: одна использует для сравнения оператор <, а другая - передаваемый в качестве аргумента предикат. Сле¬дующая программа демонстрирует эти пять алгоритмов в варианте, осно¬ванном на операторе «меньше»:
// setopstr.срр: Операции над множествами
//	для сортированных контейнеров.
iinclude <iostream>
iinclude <algorithm>
using namespace std;
void show ( const char *s, const int *begin,
const int *end) {    cout << s << "  ";
copy(begin, end, ostream_iterator<int>(cout,  "  "));
cout << endl;
}
int main()
{    int     a[4]  = {1, 5, 7, 8}, b[3] = {2, 5, 8},
sum[7], *pSumEnd,
prod[4],  *pProdEnd,
dif[3],  *pDifEnd,
symdif[7], *pSymDifEnd; pSumEnd = set_union(a, a+4, b, b+3, sum); pProdEnd = set_intersection(a, a+4, b, b+3, prod); pDifEnd = set_difference(a, a+4, b, b+3, dif); pSymDifEnd = set_symmetric_difference(a, a+4, b, b+3,
symdif);
show("a:	", a, a+4);
show("b:	", b, b+3);
show("sum:      ", sum, pSumEnd); show("prod:    ", prod, pProdEnd);
 
show("dif:     ", dif, pDifEnd);
show("symdif:", symdif, pSymDifEnd);
if (includes(a, a+4, b, b+3))
cout « "a includes b.\n"; else cout << "a does not include b.\n"; if (includes(sum, pSumEnd, b, b+3))
cout « "sum includes b.\n"; else cout « "sum does not include b.\n"; return 0;

Эта программа выводит следующий текст:
 
а: Ь:
 
15 7 8 2 5 8
 
sum:        12 5 7 8
prod:      5 8
dif:        1 7
symdif:  12 7
a does not include b.
sum includes   b.
Переменная sum используется для объединений множеств а и Ь, а перемен¬ная prod - для их пересечения. Любой элемент, входящий в а и Ь, также входит и в sum; в противоположность этому в prod вошли только те эле¬менты, которые входят в оба контейнера. Разность dif множеств а и b со¬стоит из всех элементов, которые входят в а, но не в Ь. Наконец симмет¬ричная разность symdif состоит из всех элементов, принадлежащих только к одному из множеств а или Ь, но не к обоим сразу.
Говорят, что множество S содержит (include) множество Т, если все эле¬менты Г входят также и в 5. В нашем примере а не содержит Ь, потому что элемент 2 множества b не принадлежит а. Объединение (union) двух мно¬жеств всегда содержит каждое из этих множеств, поэтому в нашем приме¬ре sum содержит Ь.
1 Обратите внимание на отличие поведения операции объединения множеств (setjunion) от операции объединения сортированных контейнеров (merge). Для пос¬ледней количество повторений элемента в результате будет равно сумме количеств повторений элемента в каждом из исходных контейнеров. - Прим. переводчика.
Мы можем использовать последовательные контейнеры, такие как мас¬сивы а и b из нашего примера, для представления «множеств с дубликата¬ми» и также применять к ним алгоритмы типа setjmion и др. Получающе¬еся объединение будет контейнером, который содержит максимум повторений каждого элемента в любом из двух множеств1, пересечение
 
7 —
 
858
 
будет содержать минимум повторений. Давайте заменим в только что рас¬смотренной программе инициализацию переменной а, в результате чего вторая строчка функции main будет выглядеть вот так:
{    int а[4] = {1, 1, 7, 8}, Ь[3]  = {2, 5, 8},
После такого изменения мы получим следующий вывод:
а:	117 8
Ь:	2 5 8
sum:        112 5 7 8
prod:      8
dif:        117
symdif: 112 5 7
a does not include b.
sum includes b.
7.3.9. Операции над пирамидами
void push_heap
(RandomAccessIterator	first,
RandomAccessIterator	last);
void push_heap
(RandomAccessIterator	first,
RandomAccessIterator	last, Compare comp);
void pop_heap
(RandomAccessIterator	first,
RandomAccessIterator	last);
void pop_heap
(RandomAccessIterator	first,
RandomAccessIterator	last, Compare comp);
void make_heap
(RandomAccessIterator	first,
RandomAccessIterator	last);
void make_heap
(RandomAccessIterator	first,
RandomAccessIterator	last, Compare comp);
void sort_heap
(RandomAccessIterator	first,
RandomAccessIterator	last);
void sort_heap
(RandomAccessIterator	first,
RandomAccessIterator	last, Compare comp);
Пирамида (heap) - это особый способ организации элементов в диапазоне [start, end), где start и end - итераторы произвольного доступа. Рассмот¬рим следующий пример пирамиды:
i ->	9123456789
a[i]  -> 80 70 60 40 50 45 30 25 20 10
В этом примере, как и в любой пирамиде из десяти элементов, у нас:
а[0] не меньше, чем а[1] и а[2], а[\] не меньше, чем а[3] и а[4], а[2] не меньше, чем а[5] и а[6], а[3] не меньше, чем а[7] и а[8], а[А] не меньше, чем а[9].
Вообще говорят, что контейнер а с элементами а[0], а[1],а[п - 1] удов¬летворяет условию пирамидалъности, если
а[г\ >a[2*i+ 1] аЩ >a[2*i + 2]
для всех элементов, принадлежащих контейнеру. Отсюда следует, что пер¬вый элемент (я[0]) пирамиды является наибольшим. Пирамиды удобно использовать для реализации очередей с приоритетами, рассмотренных в разделе 5.3, поскольку существуют операции эффективного извлечения первого элемента и добавления нового элемента с сохранением условия пирамидальное™. Извлечение первого элемента пирамиды в STL реали¬зовано следующим образом: сначала мы копируем первый элемент как обычно, а затем вызываем алгоритм popjieap. Например, для массива а мы можем написать
х = *а; pop_heap(a, а+10);
а для вектора или двусторонней очереди v.
х = *v.begin(); pop_heap (v.beginf) , v.endO);
Функция popjieap логически удаляет первый элемент контейнера, а за¬тем восстанавливает условие пирамидальности.
Добавляем новый элемент в пирамиду мы также с помощью двух опе¬раций: сперва помещаем новый элемент в конце пирамиды, а затем вызы¬ваем алгоритм pushjieap. Например:
а[9] = х; push_heap(a, а+10); или
v.push_back(х); push_heap(v.begin(), v.endf));
Алгоритм pushjieap восстанавливает условие пирамидальности, если только последний элемент последовательности нарушает это условие.
т
Существует более мощная (но требующая больше времени для выполне¬ния) функция make_heap, которая превращает последовательный контей¬нер с произвольным доступом в пирамиду. И наконец, мы можем исполь¬зовать алгоритм sort_heap для превращения пирамиды в отсортированную последовательность. Обратите внимание, что этот алгоритм помещает эле¬менты в восходящем порядке, так что они перестают удовлетворять усло¬вию пирамидальности. Упомянутые выше алгоритмы работы с пирамида¬ми используются в следующей программе:
// heapdemo.срр: Демонстрация операций с пирамидами. #include <iostream> iinclude <algorithm> using namespace std;
void show(   const char *s, const int *begin,
const int *end) {   cout « s << endl << "
copy(begin, end,    ostream_iterator<int>(cout,  "  "));
cout << endl;
}
 
i<10;  i++)  cout « "    " << i;
int main() {   cout << "
for (int i=0;
cout << endl;
int a[10] = {20, 50, 40,  60, 80,  10, 30, 70, 25, 45}; show("Initial contents of a:", a, a+10); random_shuffle(a, a+10);
show("After random_shuffle(a, a+10):", a, a+10); make_heap(a, a+10);
show("After make_heap(a, a+10):", a, a+10);
int x = *a; pop_heap(a, a+10);
show("After x = *a and pop_heap(a, a+10):", a, a+9); a[9]  = x;
push_heap(a, a+10);
show("After a[9] = x and push_heap(a, a+10):",
a, a+10); sort_heap(a, a+10);
show("After sort_heap(a, a+10):", a, a+10); return 0;
 

Эта программа выводит на экран следующие результаты, которые являют¬ся иллюстрацией к нашему обсуждению:
0123456789 Initial contents of а:
20 50 40 60 80 10 30 70 25 45 After random_shuffle(a, a+10):
80 10 45 25 50 60 30 20 40 70 After make_heap(a, a+10):
80 70 60 40 50 45 30 20 25 10 After x = *a and pop_heap(a, a+10):
70 50 60 40 10 45 30 20 25 After a[9]  = x and push_heap(a, a+10):
80 70 60 40 50 45 30 20 25 10 After sort_heap(a, a+10):
10 20 25 30 40 45 50 60 70 80
После вызова make_heap первый элемент наибольший, но последователь¬ность не является отсортированной в нисходящем порядке; например, 40 предшествует 50. Однако она является пирамидой, поэтому, после копи¬рования первого элемента (80) в переменную х, мы можем использовать алгоритм popjieap, чтобы получить пирамиду из девяти элементов. Это значение (80) снова добавляется в пирамиду: сначала мы помещаем его в конец последовательности, а затем вызываем алгоритм pushjeap для восстановления условия пирамидальности. Кроме всего, пирамида сорти¬руется с помощью специального алгоритма sortjeap, который использует свойства пирамиды и поэтому работает быстрее, чем алгоритм общего на¬значения sort.
7.3.10. Минимум и максимум
const Т& min
(const Т& a, const Т& Ь); const Т& min
(const Т& a, const Т& b, Compare comp); const Т& max
(const T& a, const T& b); const T& max
(const T& a, const T& b, Compare comp); Forwardlterator min_element
(Forwardlterator first, Forwardlterator last); Forwardlterator min_element
(Forwardlterator first, Forwardlterator last, Compare comp); Forwardlterator max_element
(Forwardlterator first, Forwardlterator last); Forwardlterator max_element
(Forwardlterator first, Forwardlterator last, Compare comp);
Если мы хотим найти минимум или максимум двух объектов, для которых определен оператор <, то можем использовать алгоритмы min и max, реализо¬вать которые можно, например, следующим хорошо известным способом:
#define min(x, у) ((х) < (у) ? (х) : (у)) ¦define max(x, у)   ((х) <  (у)  ?  (у)   :   (х))
Существуют также версии алгоритмов min и max с третьим аргументом, задающим операцию сравнения. Следующая программа использует min с двумя и max с тремя элементами:
// miranax.cpp: Алгоритмы min и max. ¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
bool CompareLastDigit(int x,  int y)
{    return x % 10 < у % 10;
}
int main()
{   int x = 123, у = 75, minimum, MaxLastDigit; minimum = min(x, y);
MaxLastDigit = max(x, y, CompareLastDigit); cout << minimum << "  " << MaxLastDigit << endl; return 0;      // Вывод: 75 7 5
}
В этой программе вызов min возвращает 75, меньшее из чисел 123 и 75. Вызов max также возвращает 75, потому что последняя цифра (5) этого числа больше, чем последняя цифра числа 123.
Чтобы найти позицию наименьшего элемента в последовательности, мы можем использовать алгоритм min_element. В следующей программе этот алгоритм используется для массива и для списка:
// min_elt.cpp: Наименьший элемент последовательности, ¦include <iostream> ¦include <list> ¦include <algorithm> using namespace std;
int main()
{   int a[5]  = {10, 30,  5, 40, 20},  *p; list<int> L;
L.insert(L.begin(), a, a+5); list<int>::iterator i; p = min_element(a, a+5);
i = min_element (L. begin () , L.endO); cout « *p « "  " « *i << endl; // Вывод: 5 5 return 0;
}
Существует также версия алгоритма min_element, которая имеет третий аргумент для передачи ему операции сравнения аналогично тому, как это сделано для алгоритмов min и max. Если мы хотим найти позицию макси¬мального элемента в последовательности, можно использовать алгоритм max_element, который имеет те же два варианта, что и min_element.
7.3.11. Лексикографическое сравнение
bool lexicographical_compare
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2); bool lexicographical_compare
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, InputIterator2 last2, Compare comp);
Мы можем проводить лексикографическое сравнение последовательнос¬тей аналогично тому, как мы сравниваем строки текста: если первые эле¬менты различны, они определяют результат сравнения, в противном слу¬чае мы сравниваем вторые элементы и т. д. Существуют два алгоритма lexicographical_сотраге: один с четырьмя параметрами использует для сравнения элементов операцию <, другой же принимает операцию сравне¬ния в качестве дополнительного аргумента. Пример работы этих алгорит¬мов приведен в следующей программе:
// lexcomp.cpp: Лексикографическое сравнение, ¦include <iostream> ¦include <algorithm> ¦include <functional> using namespace std;
int main()
{   int    a[4] = {1, 3, 8, 2}, b[4] = {1, 3, 9, 1};
cout «	"a:  ";
copyfa,	a+4, ostream_iterator<int>(cout, " "));
cout «	"\nb:  ";
copy(b,	b+4, ostream_iterator<int>(cout, " "));
cout <<	endl;
if  (lexicographical_compare(а, а+4, b, b+4))
cout << "Lexicographically, a precedes b.\n";
if (lexicographical_compare(b, b+4, a, a+4, greater<int>())) cout <<
"Using the greater-than relation, we find:\n" "b lexicographically precedes a.\n"; return 0;
}
Результат работы программы показан ниже:
а: 1 3 8 2 b:  1 3 9 1
Lexicographically, a precedes b.
Using the greater-than relation, we find:
b lexicographically precedes a.
Если последовательности имеют разную длину, отсутствующий в последовательности элемент предшествует любому присутствующему элемен¬ту второй последовательности; например: {1,2} лексикографически пред¬шествует {1,2, -5}, вне зависимости от оператора сравнения.
7.3.12. Генераторы перестановок
bool next_permutation
(Bidirectionallterator first, Bidirectionallterator last); bool next_permutation
(Bidirectionallterator first, Bidirectionallterator last, Compare comp); bool prev__permutation
(Bidirectionallterator first, Bidirectionallterator last); bool prev_per/nutation
(Bidirectionallterator first, Bidirectionallterator last, Compare comp);
Алгоритм next_permutation порождает очередную перестановку последова¬тельности. Последовательность вызовов этого алгоритма порождает, если это возможно, перестановки в лексикографическом порядке. Возвращае¬мое значение типа bool показывает, существует ли следующая перестанов¬ка. Это поведение алгоритма становится ясным из следующей программы; она также показывает, как алгоритм prevjpermutation порождает предше¬ствующую перестановку:
// permgen.срр: Генератор перестановок порождает все
//	перестановки последовательности 12 3.
¦include <iostream> ¦include <algorithm> using namespace std;
int main()
{    int a[3]  = {1, 2,  3}, k;
cout << "Six successive calls to next_permutation.\n"
"Situation before call and value returned by "
"call:\n"; for  (k=0; k<6; k++)
{   copyfa, a+3, ostream_iterator<int>(cout,  " ")); bool b = next_permutation(a, a+3); cout «  (b ? " true"  :  " false") << endl;
};
cout <<
"Three successive calls to prev_permutation.\n" "Situation before call and value returned by " "call:\n"; for (k=0; k<3; k++)
{   copyfa, a+3, ostream_iterator<int>(cout, " ")); bool b = prev_permutation(a, a+3); cout « (b ? " true" : " false") « endl;
};
return 0;
}
Начиная с последовательности {1,2,3}, программа выводит содержимое мас¬сива а непосредственно перед вызовом функции next_permutation. Всего про¬ходит шесть таких вызовов. Первый вызов возвращает true и изменяет пос¬ледовательность, содержащуюся в а, на {1, 3, 2}, второй вызов также возвращает true и порождает последовательность {2,1,3} и т. д. Как видно из приведенного ниже вывода, перестановки появляются в лексикографичес¬ком порядке. Когда а = {3,2,1}, шестой вызов функции next_permutation воз¬вращает false и помещает в массив исходную последовательность {1, 2, 3}. Функция prev_permutation работает в обратном порядке. Она возвращает false, когда изменяет содержимое массива с {1, 2,3} на {3, 2,1}, и true при пе¬реходе от {3, 2, 1} к {3,1, 2}, от {3,1, 2} к {2, 3, 1} и т. д.:
Six successive calls to next_permutation. Situation before call and value returned by call:
12	3   true
13	2 true 2 13 true 2 3 1   true
3 12   true 3 2 1    false
Three successive calls to prev_permutation. Situation before call and value returned by call: 12 3    false 3 2 1   true 3 12   true
Кроме рассмотренных нами существуют версии функций nextjperrnutation и prev_permutation, которые имеют дополнительный параметр для задания операции сравнения.
7.4. Обобщенные численные алгоритмы
Чтобы использовать алгоритмы, обсуждаемые в этом разделе, мы должны написать в программе
¦include <numeric>
если работаем с версией STL, соответствующей проекту стандарта С++. Для HP STL необходимо заменить эту строчку на следующую:
¦include <algo.h>
7.4.1.	Накопление
Т accumulate
(Inputlterator first, Inputlterator last, T init); T accumulate
(Inputlterator first, Inputlterator last, T init, BinaryFunction binary_op);
В разделе 2.1 мы обсуждали алгоритм accumulate (суммировать, накопить), ис¬пользуя в качестве примера программы accuml.cpp, accuml.cpp и асситЗ.срр. Вспомним, что можно использовать этот алгоритм не только для вычисления суммы последовательности, но и для другого «накопления» значений элемен¬тов, как показано в программах accuml.cpp и асситЗ.срр. Стоит также помнить, что накопленное значение добавляется к значению третьего аргумента.
7.4.2.	Скалярное произведение
Т inner_product
(Inputlteratorl firstl, Inputlteratorl lastl, InputIterator2 first2, T init); T inner_product
(Inputlteratorl firstl,  Inputlteratorl lastl, InputIterator2 first2, T init, BinaryFunctionl binary_opl, BinaryFunction2 binary_op2);
 
Значение выражения апЬ. + а.Ъ. + ... + а ,Ь ,
0  0	11	л-1   пЛ
называется скалярным произведением последовательностей {aQ, av апЛ} и {bQ, bv bni). Простейшая версия алгоритма inner_product добавляет вычисленное таким образом скалярное произведение к значению четвер¬того аргумента, что демонстрирует следующая программа:
// inprodl.срр: Обычное скалярное произведение.
¦include <iostream> ¦include <numeric> using namespace std;
int main()
{   int a[3] = {2, 20, 4},
b[3] = {5, 2, 10}, inprod = 100; inprod = inner_product(a, a+3, b, inprod); cout << inprod << endl; // 100 + 2 * 5 + 20 * 2 + 4 * 10 = 190 return 0;
}
Как указывает комментарий в конце программы, для вычисления значения используются два арифметических оператора - + и *. В другом варианте алгоритма innerjproduct мы пятым и шестым аргументом задаем наши соб¬ственные операции вместо + и * соответственно. В следующей программе эта версия алгоритма используется для вычисления произведения степеней.
// inprod2.cpp: Произведение степеней, вычисляемое
//	с помощью алгоритма inner_product.
¦include <iostream> ¦include <numeric> ¦include <functional> using namespace std;
double power(int x, int n) {    double у = 1;
for  (int k=0; k<n; k++) у *= x;
return у;    // x в степени n
}
int main()
{    int a[3] = {2, 3, 5}, b[3]  = {4, 1, 2}, products-product = inner_product(a, a+3, b, product,
multiplies<double>(), power); cout << product << endl;
// 1 * power(2, 4)  * power(3,  1)  * power(5, 2) = // 1 * 16 * 3 * 25 = 1200 return 0;
}
7.4.3. Частичная сумма
Outputlterator partial_sum
(Inputlterator first,  Inputlterator last,
Outputlterator result); Outputlterator partial_sum
(Inputlterator first, Inputlterator last,
Outputlterator result, BinaryOperation binary_op);
Алгоритм partialjsum практически рассчитывает суммы элементов с на¬коплением. Например, из последовательности {2, 3, 4, 8} мы получим {2, 5, 9, 17}, копируя первое значение, 2, и вычисляя три других элемента следу¬ющим образом:
2 + 3 = 5 5 + 4 = 9 9 + 8= 17
Приведенная ниже программа использует алгоритм partialjsum для вычис¬ления значений в рассмотренном примере:
// partsum.срр: Частичная сумма, ¦include <iostream> ¦include <numeric> ¦include <algorithm> using namespace std;
int main()
{   int a[4]  = {2, 3, 4, 8}, b[4],  *iEnd; iEnd = partial_sum(a, a+4, b);
copy(b,  iEnd, ostream_iterator<int>(cout,  "  ") ) ; cout << endl;  // Вывод 2 5 9 17 return 0;
}
Алгоритм partialjsum возвращает итератор, который ссылается на элемент, следующий за концом результирующей последовательности. Другими сло¬вами, iEnd равно значению Ъ + 4 в этой программе. Результирующие сум¬мы могут быть помещены в исходном контейнере, поэтому нам не потре¬буются два различных массива а и Ь, если мы хотим получить результат в массиве а; для этого достаточно написать
iEnd = partial_sum(a, а+4, а);
Существует другая версия partialjsum, которая принимает дополнитель¬ный параметр, позволяющий заменить оператор + на другую операцию. Например, мы можем написать
iEnd = partial_sum(a, а+4, b, multiplies<int>());
вместо вызова partialjsum в приведенной выше программе, чтобы полу¬чить в результате 2 6 24 192, поскольку
2x3= 6 6x4= 24 24x8 = 192
7.4.4. Разность между смежными элементами
Outputlterator adjacent_difference
(Inputlterator first, Inputlterator last, Outputlterator result); Outputlterator adjacent_difference
(Inputlterator first, Inputlterator last, Outputlterator result, BinaryFunction binary_op);
Алгоритм adjacent_dij"ference (смежная разность) вычисляет разности
d = а. - а.,
для i > 0 и d0 = а0. Например, для массива а = {2,3, 4, 8} мы получим разно¬сти d = {2, 1, 1, 4}, потому что 3-2=1,4-3=1и8-4 = 4. Алгоритм возвращает значение итератора «за концом результата», что демонстриру¬ется в следующей программе:
// adjdif.срр: Разность между смежными элементами.
¦include <iostream> ¦include <numeric> ¦include <algorithm> using namespace std;
int main()
{    int a[4] = {2, 3, 4, 8}, d[4],  *iEnd; iEnd = adjacent_difference(a, a+4,.d); copy(d, iEnd, ostream_iterator<int>(cout,  " ")); cout « endl;  // Вывод 2 114 return 0;
}
Чтобы результат был сохранен в исходной последовательности, мы можем написать
iEnd = adjacent_difference(а, а+4, а);
 
Существует другая версия алгоритма, принимающая дополнительный па¬раметр, чтобы можно было указать операцию, отличную от вычитания. Например, после выполнения
int а[4]  = {2, 20,  150,  700}, b[4],  *iEnd;
iEnd = adjacent_difference(a, a+4, b, divides<int>());
мы получим b = {2, 15, 5, 4}, так как 30/2 = 15, 150/30 = 5 и 700/150 = 4.
7.5. Прикладная программа: метод наименьших квадратов
Теперь мы применим алгоритмы accumulate и inner jjroduct для решения из¬вестной практической задачи. Предположим, что имеется набор из п пар чи¬сел (х, у), где каждая пара соответствует точке на плоскости ху, и мы хотим найти прямую линию, которая является достаточно разумным приближени¬ем зависимости, представленной этими точками, как показано на рисунке 7.1.

 

















Рисунок 7.1. Восемь точек и вычисленная линия регрессии
Количество точек произвольно, но не может быть меньше 2. Расположе¬ние точек должно быть таким, чтобы получающаяся линия не оказалась вертикальной; в частности недопустимо, если все точки имеют одну и ту же координату х.
Координаты п точек будут находиться во входном файле, имя которого вводится пользователем. Например, восемь точек, изображенных в виде крестиков на рисунке 7.1, находятся в следующем файле data.txt:
20.5	118.1
20.6	118.25 20.65 118.2
 
20.75 118.4
20.8	118.4 20.85 118.5
20.9	118.45 21.0   118.5
Получающаяся линия, называемая линией регрессии, будет представлена уравнением
у = а + Ъх
где коэффициенты а и Ъ вычислены таким образом, что сумма % - У(г)У (где у(г) = а + Ьх)
квадратов отклонений будет иметь наименьшее из возможных значений. Метод наименьших квадратов обязан своим происхождением Гауссу, по этому методу неизвестные коэффициенты а и b могут быть найдены путем решения следующей системы линейных уравнений:
an   + b X х! = X yi Й1Х+ЯХ.2 = Xх и
Программирование решения этой задачи с помощью STL представляется удобным, потому что:
•	алгоритм accumulate позволит просто вычислить значения X х и X у;,
•	алгоритм inner_product позволит просто вычислить I х2 и I х у:,
•	последовательные контейнеры позволяют хранить переменное количе¬ство значений х и у.
Что касается последнего пункта: на самом деле нет необходимости хранить все эти числа, обычно это и не делалось в раннюю эпоху компьютерных вычислений, когда память компьютеров была ограничена. Мы предполо¬жим, что располагаем достаточным количеством памяти для хранения всех чисел; более того, это позволит нам выводить не только искомые коэффи¬циенты а и Ь, но и список отклонений


где, как уже упоминалось, y(i) = а + Ьхг Если бы мы не сохраняли все значе¬ния, нам пришлось бы дважды читать входной файл. Используя тип vector<double> для хранения значений х и у, получаем следующую программу:
// leastsq.cpp: Метод наименьших квадратов, ¦include <iostream>
 
¦include <fstream>
¦include <iomanip>
¦include <vector>
¦include <numeric>
¦include <string>
using namespace std;
typedef vector<double> array;
int ReadPoints(ifstream &file, array &x, array &y) {    double xl, yl;
while  (file >> xl » yl)
{   x.push_back(xl); y.push_back(yl),-
}
return x.size();
}
int CpmputeCoeff(const array &x, const array &y,
double &a, double &b) {   double sx=0, sx2 = 0, sy=0, sxy=0;
sx = accumulate(x.begin(), x.end(), sx) ; sy = accumulate(y.begin(), y.end(), sy) ; sx2 = innerjproduct(x.begin(), x.end(),
x.begin(), sx2) ; sxy = inner_product(x.begin(), x.end(),
y.begin(), sxy); int n = x.size(); double D = n * sx2 - sx * sx; if (D != 0)
{   a = (sy * sx2 - sx * sxy)/D;
b = (n * sxy - sx * sy)/D;
return 1; }   else return 0;
}
void ShowComputedPoints(const array &x, const array &y,
double a, double b)
{   cout « "\n	x        yGiven   yComputed\n\n"
« setiosflags(ios::fixed); int n = x.size(); for  (int i=0;  i<n;  i++)
cout « setw(10) << setprecision(2)<< x[i] « " " « setw(10) « y[i]
« " " « setw(10) « a + b * x[i] « endl;
}
int main()
{   array x, y;
 
double а, Ь; string FileName,-cout « "Input file: cin >> FileName;
ifstream file(FileName.c_str()); if  (!file)
{   cout << "Cannot open input file.Xn"; return 1;
}
int n = ReadPoints(file, x, y); cout << "n = " << n « endl; if (n < 2)
{   cout « "Too few points.\n"; return 1;
}
if  (ComputeCoeff(x, y, a, b) == 0) {   cout « "Vertical line not allowed.\n"; return 1;
}
cout « "Regression line is у = a + bx, where\n"
« "a = " << a << " and b = " << b « endl; ShowComputedPoints(x, y, a, b) ; return 0;
}
Для файла data.txt, содержание которого приведено раньше, мы получаем показанные ниже результаты. Первые два столбца содержат заданные точ¬ки (х, yGiven), в то время как первый и третий столбцы представляют вы¬численные точки (х, yComputed), которые принадлежат линии регрессии, изображенной на рисунке 7.1:
Input file: data.txt n = 8
Regression line is у = a + bx, where a = 100.8 and b = 0.845528

	X	yGiven	yComputed
20.	.50	118	.10	118.13
20.	.60	118	.25	118.22
20.	.65	118	.20	118.26
20,	.75	118	.40	118.34
20.	.80	118	.40	118.39
20.	.85	118	.50	118.43
20.	.90	118	.45	118.47
21.	.00	118	.50	118.56
8 — 858
 
Типы начальных значений
Обратим внимание на то, что начальные значения, например третий аргу¬мент при вызове
sx = accumulate(х.begin(), x.end(), sx) ;
задаются в программе с помощью инициализированных переменных, хотя мы могли бы написать вместо этого
sx = accumulate(х.begin(), x.endf), 0.0);
и не инициализировать переменную sx нулем. Последний вызов алгорит¬ма accumulate является правильным, потому что константа 0.0 принадле¬жит к типу double. Но стоит отметить, что программа дает неверный ре¬зультат, если в этом вызове мы заменим 0.0 на значение 0 типа int. Простой способ избежать таких проблем с неверным типом константы - использо¬вать для начального значения ту же переменную, в которой сохраняется результат работы алгоритма. Этот принцип относится как к алгоритму accumulate, так и к алгоритму innerjproduct.
 
 

Прикладная программа: очень большие числа

8.1. Введение
Эта глава сильно отличается от предыдущих. В ней мы рассмотрим полез¬ный на практике класс large, реализующий операции с очень большими числами, для чего он использует контейнеры и алгоритмы STL. Кроме до¬статочно сложного файла определения, large.cpp, для этого класса имеется соответствующий заголовок - large.h. Класс large используется двумя при¬кладными программами. Программа la.rgedem.cpp демонстрирует все до¬ступные операции. После этого мы рассмотрим более интересное приложе¬ние, программу largepi.cpp, которая вычисляет математическую константу к с любым заданным количеством знаков после запятой.
Тема настоящей главы была рассмотрена в предыдущей книге Algorithms and Data Structures in С+ + (см. библиографию), но без использования STL. Приведенный здесь вариант решения получился проще и элегантнее бла¬годаря использованию вектора STL. Как мы упоминали в разделе 3.7, та¬кая реализация позволяет обойтись без определения конструктора копи¬рования и оператора присваивания. В текстах программ этой главы не используются операторы new и delete, тогда как версия из предыдущей
 
книги использовала оператор new восемь раз в файле large.cpp и один раз в largepi.cpp.
Представление чисел
Наши целые числа неограниченного размера будут представлены в виде двоичных чисел. Их удобно представлять записанными в системе счисле¬ния с основанием В = 2", где п - длина машинного слова. Мы будем груп¬пировать вместе последовательности п бит. Это напоминает обычный при¬ем группировки четырех бит для записи битовых последовательностей в виде шестнадцатеричных чисел. Количество бит, используемое для пред¬ставления числа в классе large, всегда будет кратным п. Для 32-битных целых чисел (то есть когда п = 32 и sizeof(int) = 4) «цифры» будут нахо¬диться в диапазоне от 0 до 232 - 1 = 4 294 967 295.
Если мы увеличим последнее значение на 1, то не сможем хранить ре¬зультат в одной «цифре» - нам потребуются уже две цифры или 64 бита. Каждое число у нас будет представлено вектором, содержащим значения типа unsigned int вместе с флагом neg типа bool, который равен true, если данное число отрицательно, и false, если оно положительно или равно 0. Каждый элемент вектора будет содержать одну «цифру» в диапазоне от 0 до 2пЛ. Для 32-битных целых чисел размер вектора в зависимости от зна¬чения представленного числа х будет следующим:
0, если х = 0, 1,еслиО<М< 232,
2,	если 232 < И < 2е4,
3,	если 2е4 < W < 296,
4,	если 296 < W< 2128.
и так далее. Класс large будет определять много операций, большая часть которых доступна и для обычных арифметических типов:
•	арифметические операции +, -, *, /, % (и функцию divide, объединяю¬щую / и %);
•	операции битового сдвига « и »;
•	все перечисленные выше операции с одновременным присваиванием, что дает +=, -=, *=, /=, %=, «= и »=;
•	обычные перегруженные операторы ввода и вывода « и »;
•	присваивание =;
•	сравнение ==, !=, <, >, <=, >=;
•	унарная операция изменения знака -;
•	функции abs для получения абсолютной величины числа, sqrt для вы¬числения квадратного корня и power для возведения в степень;
•	преобразование каждого из типов int, unsigned int, long и unsigned long к типу large. Кроме этого, определяется преобразование в тип large обычных строк в стиле С, char* (если эти строки содержат только деся¬тичные цифры, которым может предшествовать знак минус);
•	функция num2char для преобразования числа типа large в символьное представление, записанное в экземпляре класса vector<char> в обрат¬ном порядке (см. замечание о переносимости в конце этого раздела).
Большая часть этих операций используется в демонстрационной програм¬ме largedem.cpp, которая приведена ниже.
// largedem.cpp: Используем тип large, ¦include "large.h" int main()
{   large a = -10000, b = 10000U, с = 2000000L,
d = "100000000000000000000",  // 20 нулей
x, у,  z, u;
x =  (a * b * b + 1)  * c;
x -= c;	//x=a*b*b*c
x /= a * b;     // x = b * с
у = large("1234567890123")  % large("1234567890000"); if (x == b * с ScSc у == large(123)) cout << "Arithmetic OK" « endl;
z = power(d, 100);    // d в степени 100
// = 10 в степени 2000
u = sqrt(z);	// 10 в степени 1000
if (u == power(large(10), 1000))
cout   << "u = '10 raised to the power 1000'" << endl;
if (u < power(large(11), 1000) && u > power(large(9), 1000)) cout << "Comparisons OK" << endl;
vector<char> s; u.num2char(s);
cout   << "First character in output of u: "
<< *(s.end() - 1) << endl; cout   << "u consists of " << s.sizeO
<< " decimal digits." « endl;
z = d « 100; // z = d *  (2в степени 100)
if (z == d * power(large(2), 100) && (z » 100) == d)
cout << "Shift operations OK" << endl;
cout << -d << endl;
cout << "Enter a large number x: "; cin   >> x;
cout << "2 * х = " «2 * х << endl;
а = "123456789123456789"; b = "999888777666";
large q, г;
a.dividefb, q, r, true); if (q != a/b II r != a%b)
cout « "Function 'divide' incorrect." << endl; return 0;
}
Вот вывод этой программы:
Arithmetic OK
u = '10 raised to the power 100 0 Comparisons OK
First character in output of u: 1 u consists of 1001 decimal digits. Shift operations OK -100000000000000000000
Enter a large number x: 999888777666555444333222111 2 * x = 1999777555333110888666444222
Рассмотренная программа показывает, что класс large упрощает работу с большими числами. Например, целое число d = 1020 используется для вы¬числения
2 = ^/ЮО = 1Q2000
u = VJ= 101000
После проверки следующих условий выводится сообщение Comparisons OK:
и = 101000 и< 111000 и > 91000
Для демонстрации операций сдвига число d = 1020 сдвигается на 100 дво¬ичных позиций влево, что дает
2 = 1020 х 2100
Этот результат проверяется с помощью функции power для вычисления значения 2100 и сдвигом 2 на 100 позиций вправо, чтобы проверить, что результат снова оказывается равен d.
Переносимость
Программы в этом разделе были успешно протестированы со следующи¬ми версиями STL, упоминавшимися в разделе 1.2:
 
(1)	Visual С++ (версия 5.0).
(2)	Адаптация SGI STL для Visual С++ 5.0 от Учида.
(3)	Borland С++ (версия 5.2).
Поскольку алгоритмы min и max вызывали проблемы с версией, помечен¬ной (1), мы добавляем следующую строчку, чтобы проверить, использует¬ся ли эта версия:
#if (defined(_MSC_VER) && !defined(_SGI_MSVC))
8.2. Реализация класса large
Только что упомянутая строка препроцессора находится в следующем файле заголовка largeh, который мы использовали в программе largedem.cpp:
II large.h: Многоразрядная целочисленная арифметика, ¦include <iostream> ¦include <vector> ¦include <iterator> using namespace std;
typedef unsigned int uint; typedef vector<uint> vec;
class large { public:
large(const char *str);
large(int i);
large(uint i=0);
large(long i);
large operator-()const;
large &operator+=(const large &y);
large &operator-=(const large &y);
large &operator*=(int y);
large &operator*=(uint y);
large &operator*=(large y);
large &operator/=(const large &divisor);
large &operator%=(const large kdivisor);
large &operator<<=(uint k);
large &operator»= (uint k) ;
void divide(large denom,
large &quot, large &rem, bool RemDesired)const;
// Функция num2char преобразует объект x класса large //в его символьное представление s в обратном порядке: void num2char(vector<char> &s) const; int compare(const large &y)const; private:
vec Р; bool neg;
void SetLenfint n); void reduce();
void DDproduct(uint A, uint B, uint &Hi,
uint &Lo)const; uint DDquotient(uint A, uint B, uint d)const; void subtractmul(uint *a, uint *b, int n,
uint &q)const;
bool normalize(large &denom, large &num,
int &x)const; void unnormalize(large &rem, int x,
bool SecondDone)const;
};
large operator+(large x, const large &y); large operator-(large x, const large &y); large operator*(large x, const large &y); large operator/(large x, const large &y); large operator%(large x, const large &y); large operator«(large u, uint k); large operator»(large u, uint k) ; ostream &operator<<(ostream &os, const large &x); istream &operator»(istream &os, large &x);
bool operator==(const large &x, const large &y);
bool operator<(const large &x, const large &y);
bool operator!=(const large &x, const large &y);
bool operator>(const large &x, const large &y);
large abs(large x);
large sqrt(const large &a);
large powerdarge x, uint n) ;
#if (defined(_MSC_VER) && !defined(_SGI_MSVC)) template <class T>
inline const T& min(const T& a, const T& b)
{   return a < b ? a : b;
}
template <class T>
inline const T& max(const T& a, const T& b)
{   return a < b ? b : a;
}
#endif
Значение большинства открытых (public) членов этого класса должно быть понятно из нашего обсуждения программы largedem.cpp. Обратите внимание, что мы определяем только два оператора сравнения - == и <.
Четыре остальных оператора (!=, >, <=, >=) определяются шаблонами STL, как объяснено в разделе 2.8.
В классе large присутствуют всего две переменные-члена - Р и neg, оп¬ределенные после ключевого слова private как
vec Р; bool neg;
Взглянув на определение typedef выше в файле, мы увидим, что тип vec означает vector<unsigned int>. Мы уже упоминали, что Р представляет аб¬солютное значение большого числа, тогда как neg показывает, является ли число отрицательным.
Ранняя версия класса large, не использующая STL, содержала указатель типа uint* вместо vec Р, и в ней имелись еще две переменных-члена класса, len и Len, которые указывали логическую и физическую длину. Они соот¬ветствуют функциям-членам STL size и capacity (см. раздел 3.2). Теперь эти две длины полностью обрабатываются STL.
Мы не будем обсуждать все подробности реализации класса large; в от¬дельных местах текста присутствуют поясняющие комментарии, помога¬ющие разобраться, как устроена эта реализация. После компиляции сле¬дующий файл должен быть скомпонован (link) с программой, которая использует класс large:
II large.срр: Многоразрядная целочисленная арифметика,
//	значения 10, 20, 30 и 40 использующая STL.
iinclude <iostream>
iinclude <strstream>
iinclude <iomanip>
iinclude <stdlib.h>
iinclude <limits.h>
iinclude <string>
iinclude <ctype.h>
iinclude "large.h"
const	uint uintmax = UINT_MAX;
const	int wLen = sizeof(uint) * 8;    // Количество бит
const	int hLen = wLen/2;
const	uint rMask = (1 « hLen) - 1;
const	uint lMask = uintmax - rMask;
const	uint IBit = uintmax - (uintmax » 1);
// Добавить нули или удалить элементы в конце, //то есть в позициях старших разрядов, void large::SetLen(int LenNew) {   int LenOld = P.sizeO; if (LenNew > LenOld)
 
P.insert(P.end(), LenNew - LenOld, 0); else if (LenNew < LenOld)
P.erase(P.begin()+LenNew, P.end());
}
// Удалить все старшие нули (в конце вектора Р): void large::reduce() {   int L = P.size();
while  (L > 0 && P[L-1]  == 0) L--;
P. erase (P. begin () + L, P.endO);
if (L == 0) neg = 0;
)
// Разные конструкторы: large::large(const char *str) {   bool Neg = *str ==
int i = (Neg ? 1 : 0) ;
*this = 0;
while (str[i])
*this = *this * 10 +  (str[i + + ]  -  ' 0' ) ;
neg = Neg;
reduce();
}
large::large(int i)
{   if (i > 0) P.push_back(i); else
if (i < 0)  P.push_back(-i);
neg = i < 0;
}
large::large(long L) {   neg = L < 0;
unsigned long UL = neg ? -L : L;
if (UL != 0)
{
#if LONG_MAX == INT_MAX
// sizeof(long) == sizeof(int): P.push_back(uint(UL));
#else
// sizeof(long) > sizeof(int): while (UL != 0)
{   P.push_back(uint(UL & UINT_MAX)); UL >>= wLen;
}
#endif }
}
large::large(uint i) {   neg = 0;
if (i) P.pkush_back(i) ;
}
// Operator + определяется через += и т. п.:
large operator+(large x, const	large &y){return x+=y;}
large operator-(large x, const	large &y){return x-=y;}
large operator*(large x, const	large &y){return x*=y;}
large operator/(large x, const	large &y){return x/=y;}
large operator%(large x, const	large &y){return x%=y;}
large operator<<(large u, uint	k){return u <<= k;}
large operator» (large u, uint	k) {return u »= k;}
large large::operator-()const {   large v = *this;
if (v.P.sizef)) v.neg = Iv.neg;
return v;
}
large &large::operator+=(const large &y) {   if (neg != y.neg) return *this -= -y;
int i, Ly = y.P.sizet);
uint d, carry = 0; // Длина результата = max. длин операндов + 1:
SetLen(max(Ly,  (int)P.size()) + 1);
int L = P.size();
for  (i=0;  i<L;  i++)
{   if (i >= Ly ScSc carry == 0) break; d = P[i] + carry;
// Сбросить признак переноса 'carry' в 0, если
// последнее сложение не привело
// к дополнительному переносу:
carry = d < carry;
if (i < Ly)
{   P[i] = d + y.P[i];
// Последнее сложение может привести к переносу,
// только если текущий перенос 'carry' равен 0
//  (и d > 0):
if (P[i] < d) carry = 1; }   else P[i] = d;
}
reduce(); return *this;
}
large &large::operator-=(const large &y) {   if (neg != y.neg) return *this += -y;
if (!neg && у > *this |I neg && у < *this) return *this = -(y - *this);
int i, borrow = 0, Ly = y.P.sizet), L = P.sizeO;
uint d;
for (i=0;  i<L;  i++)
{   if  (i >= Ly ScSc borrow == 0) break; d = P[i]  - borrow; borrow = d > P [ i ] ; if  (i < Ly) {   P[i]  = d - y.Pfi];
if (P[i]  > d) borrow = 1; }   else P[i]  = d;
}
reduce(); return *this;
}
large &large::operator*=(int y) {   bool Neg = у < 0;
if  (Neg) у = -у;
*this *= uint(y);
if  (Neg)
neg = !neg;
return *this;
}
large &large::operator*= (uint y) {   int lenO = P.sizeO, i;
uint Hi, Lo, dig = P[0], nextdig = 0;
SetLendenO + 1) ;
for (i=0; i<len0; i++)
{   // Вычислим произведение двух цифр dig * у; // результатом является (Hi, Lo): DDproduct(dig, у, Hi, Lo); P[i]  = Lo + nextdig; dig = P[i+1];
nextdig = Hi +  (P[i]  < Lo) ;
}
P[i] = nextdig; reduce(); return *this;
}
large &large::operator*=(large y)
{   int L = P.sizeO, Ly = y.P.sizet);
if  (L == 0  II  Ly == 0) return *this = 0;
bool DifSigns = neg != y.neg;
if  (L + Ly == 2)
// L = Ly = 1: Произведение длиной в одну или две цифры: {   uint а = Р[0], b = у.Р[0];
Р[0] =а*Ь;   // Предположим произведение длиной //в одну цифру:
if (Р[0] / а != b) {   P.push_back(0);
DDproductfa, b, P[l], P[0]);
reduce();
}
neg = DifSigns;• return *this;
}
if  (L == 1)    //   && Ly > 1
{   uint digit = P[0] ;
*this = у;	// Поменять местами операнды
*this *= digit;    // и вызвать operator*=(uint у)
}   else
if (Ly == 1) //   && L > 1
{   *this *= y.P[0]; // Вызвать operator*=(uint y) }   else
// Длины обоих операндов L и Ly больше 1: {   int lenProd = L + Ly, i, jA, jB;
uint sumHi = 0, sumLo, Hi, Lo,
sumLoOld, sumHiOld, carry=0;
large x = *this;
SetLen(lenProd);   // Установить длину *this
// равной lenProd for (i=0; i<lenProd; i++)
{   sumLo = sumHi; sumHi = carry; carry = 0,-int max_jA = min(i, L-l); // jA <= i гарантирует jB >= 0
// jA < L, поскольку в *this имеется лишь L цифр
for (jA=max(0, i+l-Ly); jA<=max_jA; JA++)
// jA > i - Ly гарантирует jB < Ly
{   jB = i - jA;
// Другое произведение цифр, влияющее на // позицию i (= jA + jB) произведения // всего числа:
DDproduct(х.Р[jA], y.PtjB], Hi, Lo); sumLoOld = sumLo; sumHiOld = sumHi; sumLo += Lo; if (sumLo < sumLoOld)
sumHi++; sumHi += Hi;
carry += (sumHi < sumHiOld);
}
P[i] = sumLo;
}
}
reduce();
neg = DifSigns;
return *this;
}
large &large::operator/=(const large &divisor) {    large r;
// Разделить *this на делитель, сохраняя результат // в *this; 0 означает, что остаток в г //не обязан быть правильным: divide(divisor,  *this, г, 0) ; return *this;
}
large &large::operator%=(const large &divisor) {   large q;
// Разделить *this на делитель, сохраняя результат // в *this; 1 означает, что остаток в г // должен быть правильным: divide(divisor, q,  *this, 1); return *this;
}
large &large::operator<<=(uint k) {   int q = k / wLen; // Количество полных слов, if  (q)
{   int i;	// Увеличить длину на q:
SetLen(P.size()  + q) ;
// Сдвинуть *this на q слов влево:
for (i=P.size()-1;  i>=0;  i--)
P[i]  =  (i < q ? 0  :  P[i - q] ) ;
k %= wLen;	// Теперь k содержит оставшиеся
}	// позиции сдвига.
if  (k)    // 0 < k < wLen: {   int kl = wLen - k;
uint mask =  (1 « k)  - 1;
// маска: 00..Oil..1  (k единичных бит)
SetLen(P.size()  + 1);
// Каждый из P[i] сдвигается на к позиций влево, // а затем комбинируется по "или" с к самыми левыми // битами правого соседа P[i-1]: for  (int i=P.size()-1;  i>=0;  i--) {    P[i] «= k; if  (i > 0)
P[i]   |= (P[i-1] » kl) & mask;
}
}
reduce(); return *this;
large &large::operator>>=(uint k)    // Аналогично <<= {   int q = k / wLen, L = P.sizeO;
if (q >= L){*this = 0; return *this;}
if  (q)
{    for (int i=q;  i<L;  i++)  P[i-q]  = P[i]; SetLen(L - q); k %= wLen;
if (k == 0) {reduced; return *this;}
}
int n = P.sizeO - 1, kl = wLen - k; uint mask = (1 « k) - 1; for (int i=0;  i<=n;  i++) {   P[i] »= k;
if  (i < n)  P[i]   1=  ((P[i+1] & mask) « kl);
}
reduce(); return *this;
}
// compare возвращает: отрицательное число, если *this < у, // ноль, если *this == у, и положительное, если *this > у. int large::compare(const large &y)const {    if (neg != y.neg) return y.neg - neg;
int code = 0, L = P.sizeO, Ly = y.P.sizeO;
if  (L == 0  II Ly == 0) code = L - Ly; else
if (L < Ly) code = -1; else
if  (L > Ly)  code = +1; else
for  (int i = L - 1;  i >= 0;  i--)
{   if (P[i] > y.P[i])   {code = 1; break;} else if (P[i] < y.P[i])   {code = -1; break;}
}
return neg ? -code : code;
}
// Двуцифровое произведение (Hi, Lo)  = A * B: void large::DDproduct(uint A, uint B,
uint &Hi, uint &Lo)const {   uint   hiA = A » hLen, loA = A & rMask, hiB = В » hLen, loB = В & rMask, midl, mid2, old; Lo = loA * loB; Hi = hiA * hiB; midl = loA * hiB; mid2 = hiA * loB; old = Lo;
Lo += midl « hLen;
Hi +=  (Lo < old)  +  (midl >> hLen);
old = Lo;
Lo += mid2 << hLen;
Hi += (Lo < old)  +  (mid2 » hLen);
// Двуцифровое значение  (А, В) делится на d:
uint large::DDquotient(uint A, uint B, uint d)const
{   uint left, middle, right, qHi, qLo, x, dLol,
dHi = d >> hLen, dLo = d & rMask;
qHi = А/(dHi + 1);
// Это начальное приближение к qHi может оказаться
// слишком малым.
middle = qHi * dLo;
left = qHi * dHi;
x = В -  (middle << hLen);
A -=  (middle >> hLen)  + left +  (x > В); В = x;
dLol = dLo << hLen;
// Увеличить qHi при необходимости:
while  (A > dHi  ||   (A == dHi && В >= dLol))
{   x = В - dLol;
A -= dHi +  (x > B) ;
В = x;
qHi++;
}
qLo =  ((A « hLen)   I   (B » hLen))/(dHi + 1);
// Это начальное приближение к qLo может оказаться
// слишком малым.
right = qLo * dLo; middle = qLo * dHi; x = В - right; A -=  (x > B); В = x;
x = В -  (middle « hLen);
A -=  (middle >> hLen)  +  (x > B);
В = x;
// Увеличить qLo   при необходимости: while (A ||  В >= d) {   x = В - d;
A -=  (x > B);
В = x;
qLo++;
}
uint result =  (qHi « hLen)  + qLo;
return result == 0 && qHi > 0 ? uintmax : result;
}
// Вычесть произведение q * b из а, где а и b -
// значения длиной n цифр. Остаток a - q * b
// будет меньше, чем b, и должен быть неотрицательным.
// Последнее условие может потребовать
// уменьшения q на 1:
void large::subtractmul(uint *a, uint *b, int n, uint &q)const
{   uint Hi, Lo, d, carry = 0; int i;
for (i=0;  i<n;  i++)
{    DDproduct(b[i], q, Hi, Lo) ;
d = a[i];
a[i]  -= Lo;
if  (a[i]  > d) carry++; d = a[i + 1] ; a[i + 1]  -= Hi + carry; carry = a[i + 1] > d;
}
if (carry)  // q was too large {   q—; carry = 0;
for (i=0;  i<n; i++) {    d = a[i]  + carry; carry = d < carry; a[i] = d + b[i]; if (a[i] < d) carry = 1;
}
a[n]  = 0;
}
}
// Нормализация путем сдвига denom и num влево, // так что самая левая позиция denom станет 1; // оба операнда выражения num/denom сдвигаются // на х битовых позиций:
bool large::normalize(large &denom, large &num,
int &x)const {    int r = denom.P.size()  - 1;
uint у = denom.P[r]; x = 0;
while  ( (y & lBit)  == 0) {y «= 1; x++;}
denom <<= x; num «= x;
// Возможно второе действие согласно К. Дж. Мифсуду //  (см. библиографию):
if (г > 0 && denom.Р[г] < denom.Р[г-1]) {   denom *= uintmax; num *= uintmax; return 1;
}
return 0;
}
// Откатить нормализацию (включая поправку Мифсуда, // если SecondDone == 1), чтобы получить // правильный остаток:
void large::unnormalize(large &rem, int x, bool SecondDone)const
{   if (SecondDone)  rem /= uintmax;
if (x > 0) rem >>= x; else rem.reduce();
}
// Разделить *this на denom, получив quot = num / denom, // и, если RemDesired == 1, rem = num % denom: void large::divide(large denom,
large &quot, large &rem, bool RemDesired)const {   int L = P.sizeO, Ld = denom. P. size () ;
if (Ld == 0)   {cout « "Zero divide.\n"; return;}
bool QuotNeg = neg Л denom.neg;
int i, r, x = 0, n;
bool RemNeg = neg, SecondDone = false;
uint q, d;
large num = *this;
num.neg = denom.neg = 0;
if (num < denom)
{   quot = 0; rem = num; rem.neg = RemNeg; return; }
if  (Ld == 1 && L == 1)
{   quot = uint(num.P[0]/denom.P[0]);
rem = uint(num.P[0]%denom.P[0]);
quot.neg = QuotNeg; rem.neg = RemNeg;
return; }   else
if (Ld == 1 && (denom.P[0] & IMask) == 0) {   // Делитель умещается в половину слова
uint divisor = denom.Р[0], dHi = 0, ql, r, q2, dividend;
quot.SetLen(L);
for (int i=L-l; i>=0; i--)
{   dividend =  (dHi « hLen)   I   (P[i] >> hLen); ql = dividend/divisor; r = dividend % divisor; dividend =  (r « hLen)   I   (P[i] & rMask); q2 = dividend/divisor; dHi = dividend % divisor; quot.P[i] =  (ql « hLen)   I q2;
}
quot.reduce(); rem = dHi;
quot.neg = QuotNeg; rem.neg = RemNeg;
return;
}
large numO = num, denomO = denom;
SecondDone = normalize(denom, num, x);
r = denom.P.size()  - 1; n = num.P.sizeO  - 1;
quot.SetLen(n - r) ;
int Lq = quot.P.size();
for (i=Lq-l;  i>=0; i--) quot.P[i]  = 0; rem = num;
if (rem.P[n] >= denom.P[r]) {   rem.SetLen(rem.P.size()  + 1) ; n++;
quot.SetLen(Lq + 1);
}
d = denom.P[r];
for (int k=n; k>r; k—)
{   q = DDquotient(rem.P[k], rem.P[k-l], d); subtractmul(&rem.P[k - r - 1], &denom.P[0],
r + 1, q) ; quot.P[k - r - 1]  = q;
}
quot.reduce(); quot.neg = QuotNeg; if (RemDesired)
{   unnormalize(rem, x, SecondDone); rem.neg = RemNeg;
}
}
bool operator==(const large &x, const large &y) {   return x.compare(y)  == 0;
bool operator<(const large &x, const large &y) {   return x.compare(y) < 0;

bool operator!=(const large& x, const large& y) {   return x.compare(y)  != 0;

bool operator>(const large& x, const large& y) {   return x.compare(y) > 0;

// Функция num2char преобразует объект x класса large // в его символьное представление s в обратном порядке: void large::num2char(vector<char> &s) const {   large x = *this;
static uint plO = 1, iplO = 0;
if (x.P.sizeO == 0)  s.push_back(10'); else
{   uint r;
if (plO == 1)
{   while (plO <= UINT_MAX/10) {   plO *= 10; ipl0++;
}
}    // plO является максимальной степенью 10, // представляемой с помощью uint
// LP10 = plO = pow(10, iplO) large R, LP10 = plO; bool neg = x.neg; do
{   x.divide(LP10, x, R,  1) ;
r = (R.P.sized  ? R.P[0]   : 0) ; for (uint j=0; j<ipl0; j++) {   s.push_back(char(r % 10 + '0')); r /= 10;
if (r + x.P.sized == 0) break;
}
}   while (x.P.size());
if (neg)  s.push_back('-') ;
// s содержит строку в обратном порядке
}
}
ostream &operator« (ostream &os, const large &x) {   vector<char> s; x.num2char(s);
vector<char>::reverse_iterator i;
for (i=s.rbegin(); i != s.rendf); ++i) os « *i;
return os;
}
istream &operator>>(istream &is, large &x) {   char ch; x = 0;
bool neg = 0; is >> ch;
if (ch == '- ' ) {   neg = 1; is.get(ch);
}
while (isdigit(ch)) {   x = x * 10 +  (ch -  '0¦); is.get(ch);
}
if  (neg) x = -x; is.putback(ch); return is;

large abs(large a) {   if  (a < 0)  a = -a; return a;
 
large sqrt(const large &a) {   large x = a, b = a, q; b «= 1;
while (b >>= 2, b > large(0)) x >>= 1; while (x >  (q = a/x)  +1  II x < q - 1) {    x += q;  x >>= 1; }
return x < q ? x : q;
}
large power(large x, uint n) {    large y=l; while (n)
{   if  (n & 1) у *= x; X *= X;  П >>= 1;
}
return y;
}
8.3. Вычисление числа n
Хотя класс large предназначен для представления больших целых чисел, мы можем использовать его для приближенного представления веще¬ственных чисел, если будем использовать соответствующее масштабиро¬вание. Давайте продемонстрируем это путем вычисления числа к с произ¬вольной степенью точности. Один из известных способов вычисления этой константы с помощью формулы
тс = 16 arctan 4-4 arctan гХг
Джона Мачина (1680 -1752). Вместо этого мы воспользуемся формулой
к = 48 arctan ^+ 32 arctan j=L - 20 arctan^д-	(1)
которая предпочтительнее, поскольку наименьший знаменатель в этой формуле (18) больше, чем в формуле Мачина (5). Математики, интересу¬ющиеся задачей вычисления числа к, могут обратиться к книге Borwein, J.M. and Borwein, Р.В. (1987) Pi and the AGM, в которой приведены более сложные алгоритмы. Поскольку нас интересует программирование, мы просто примем приведенную формулу с тремя арктангенсами без доказа¬тельства. В свою очередь, функцию арктангенса мы будем аппроксимиро¬вать с помощью алгебраических операций путем приближенного вычис¬ления следующего ряда:
arctan х = х - ^ + ^- ^+ ...	(2)
Пользователь программы должен задать п - требуемое количество деся¬тичных знаков после запятой. Например, в выводе программы число к будет представлено как
3.
1415
если п равно 4. Так как мы приближенно представляем вещественные чис¬ла с помощью целых, то должны обращать внимание на последние цифры результата, чтобы избежать ошибок округления, связанных с нашим при¬ближенным вычислением функции arctan. Поэтому будем использовать коэффициент масштабирования
TenPower - 10п+3	(3)
и опустим последние три цифры при выводе результата. Вместо к мы на самом деле будем вычислять целое число, приблизительно равное TenPower х к.
В соответствии с формулой (1) переменная х в уравнении (2) может принимать значения, равные i/k, где k = 18, 57 или 239. Умножая уравне¬ние (2) на большую константу N, мы получим следующее приближение, где вторая строка содержит только целые числа:
N arctan х = N arctan (1 /k) ~
N/k - ЛУ(З^) + ЛГ/(5Ј5) - N/Clk1) + ... = Atan(k, N)	(4)
Здесь N является большим целым числом, а оператор деления / означает целочисленное деление (как в выражении 39/5 = 7). В результате много¬точие в выражении (4) обозначает конечное количество членов N/(ik'), поэтому мы можем вычислить все эти значения. После этого из формулы (1) следует, что TenPower х к приблизительно равняется следующему боль¬шому числу:
Atan(l8, 48 х TenPower) + Atan(51, 32 х TenPower) -Atan(23§, 20 x TenPower)
Следующая программа использует это выражение в вычислениях:
// largepi.cpp: Используем целые числа класса large
//	для вычисления числа Пи.
//	Скомпоновать с large.срр.
¦include	<fstream>
¦include	<time.h>
¦include	<stdlib.h>
¦include	"large.h"
 
// Для вычисления Пи: large Atan(uint к, const large &N) {    // Вычисляет N * atan(1.0/k) как // целое число класса large large а = О, w = N * к, zero = О, к2 = к * к,
i = -1,
two = 2; cout « "к = " « к « endl; while (w != zero) {   a +=  (w /= k2)/(i += two);
a -= (w /= k2)/(i += two);
}
return a;
}
void PiOutput(ostream &os, ofstream &ofile,
const large &x, int n) {   vector<char> s;
x.num2char(s);
// Символьное представление x находится в s //в обратном порядке. vector<char>::reverse_iterator i; int k = 0; char ch;
for (i=s.rbegin(); i != s.rendf); ++i) {   ch = *i; os << ch;
if  (ofile) ofile « ch;
// После десятичной точки напечатано к цифр.
if (k == 0)
{    os « "." << endl;
if  (ofile) ofile « "." « endl; }   else
if (k % 50 == 0) {   os << endl;
if  (ofile) ofile << endl; }   else
if  (k % 10 == 0) {    os « "  " ;
if  (ofile) ofile « "  ";
if  (k++ == n) break;
}
 
int main() {    int n, m;
cout << "Computation of pi. Number of decimals:  "; cin >> n; m = n + 3; cout «
"Copy of output to file pi.txt desired (у/n)? "; char answer; cin >> answer; ofstream ofile;
if  (answer == 'Y'   I I answer == 'у')
ofile.open("pi.txt"); large TenPower, Pi; clock_t tStart, tEnd; tStart = clock();
TenPower = power(5, m); TenPower <<= m;
// Быстрее, чем TenPower = power(10, m);
Pi =  (Atan(18, TenPower * 48) + Atan(57, TenPower * 32) - Atan(239, TenPower * 20))/1000;
tEnd = clock();
cout << "Digits of pi:" << endl; PiOutput(cout, ofile, Pi, n) ;
cout « "\nTime:  " « (tEnd - tStart) « " ticks\n"; return 0;
}
Для n, существенно больших 1000, выполнение программы начинает зани¬мать ощутимое время. Чтобы предоставить пользователю информацию о текущем состоянии расчетов, желательно показывать промежуточный вывод для каждого из следующих шагов:
1.	Вычисление TenPower = 10m, где т = п + 3.
2.	Вычисление Atan(239, TenPower * 20).
3.	Вычисление Atan(Sl, TenPower * 32).
4.	ВычислениеAtan( 18, TenPower* 48).
5.	Перевод переменной Pi класса large в символьную строку, содержащую п десятичных цифр для вывода.
На шаге 1 мы оптимизируем наши расчеты с помощью операции сдвига влево, заметив, что 10т = 5тх 2т. Отсюда мы можем вычислить значение 5т, а затем сдвинуть результат на т двоичных позиций влево. Поскольку время вычисления произведения чисел класса large зависит от их длины, мы можем вычислить значение 5т быстрее, чем 10т.
Шаги 2, 3 и 4 необязательно выполнять в этом порядке. Когда требует¬ся вычислить значение выражения /() - g(), язык С++ не указывает, в ка¬ком порядке происходят вызовы / и g. В нашем примере g вычисляется раньше, чем /.
После того как пользователь введет требуемое количество десятичных знаков, он должен указать, требуется ли записывать вывод программы в текстовый файл pi.txt. Затем программа показывает, что она выполняет шаги 2, 3 и 4, выводя на экран соответствующую информацию, как видно из примера на следующей странице.
Приводимый пример выполнялся на компьютере Pentium 166 с 32 Мб памяти; программа была откомпилирована с помощью ВС5 и запущена в окне DOS операционной системы Windows 95. Поскольку для ВС5 ин¬тервал таймера (tick) равен 1 миллисекунде, вычисление значения к в этом примере с точностью до 1000 десятичных знаков заняло около 0.3 секунды (не считая времени, потраченного на вывод текста на экран). Результаты проверялись путем сравнения десяти последних цифр этого результата (5 493 624 646) с результатами Ясамасы Канады из Токио, который вычис¬лил миллиард знаков числа к с помощью совершенно другого аппаратного и программного обеспечения.
1 Часто программы, использующие STL, выполняются даже эффективнее про¬грамм, которые используют другие методы. Так, например, алгоритм sort, опреде¬ленный в STL, в целом несколько эффективнее, чем алгоритм qsort, определенный в стандартной библиотеке языка С. - Прим. переводчика.
Как упоминалось в начале этой главы, моя предыдущая книга Algorithms and Data Structures in С++ содержит класс large, аналогичный представлен¬ному здесь, но не использующий STL. Вычисление к с помощью предыду¬щей версии программы заняло примерно такое же время, как и у представ¬ленной здесь версии, использующей STL. Однако на программирование класса large без STL разработчиком было затрачено гораздо больше вре¬мени. Несколько преувеличивая, мы можем сказать, что между програм¬мированием с применением STL и без примерно такая же разница, как у программирования на языках высокого уровня с программированием на ассемблере. Хотя программирование на ассемблере дает более эффектив¬ный код, в наше время использование ассемблера абсолютно нереально для большинства приложений. Программисты, отвергающие STL из-за боязни уменьшения эффективности, похожи на тех людей, которые в 60-е годы считали, что любая серьезная задача должна быть запрограммирова¬на с помощью ассемблера1.
 
Computation of pi. Number of decimals: 1000 Copy of output to file pi.txt desired (y/n)? n k = 239 k = 57 k = 18
Digits of pi: 3 .
1415926535 8979323846 2643383279 5028841971 6939937510 5820974944 5923078164 0628620899 8628034825 3421170679 8214808651 3282306647 0938446095 5058223172 5359408128 4811174502 8410270193 8521105559 6446229489 5493038196 4428810975 6659334461 2847564823 3786783165 2712019091 4564856692 3460348610 4543266482 1339360726 0249141273 7245870066 0631558817 4881520920 9628292540 9171536436 7892590360 0113305305 4882046652 1384146951 9415116094 3305727036 5759591953 0921861173 8193261179 3105118548 0744623799 6274956735 1885752724 8912279381 8301194912 9833673362 4406566430 8602139494 6395224737 1907021798 6094370277 0539217176 2931767523 8467481846 7669405132 0005681271 4526356082 7785771342 7577896091 7363717872 1468440901 2249534301 4654958537 1050792279 6892589235 4201995611 2129021960 8640344181 5981362977 4771309960 5187072113 4999999837 2978049951 0597317328 1609631859 5024459455 3469083026 4252230825 3344685035 2619311881 7101000313 7838752886 5875332083 8142061717 7669147303 5982534904 2875546873 1159562863 8823537875 9375195778 1857780532 1712268066 1300192787 6611195909 2164201989
Time: 312 ticks
 
Библиография
Ammeraal, L. (1995) С++ for Programmers, 2nd Edition, Chichester: John Wiley.
Ammeraal, L. (1996) Algorithms and Data Structures in С++, Chichester: John Wiley.
Borland International (1996) Borland С++ Programmer's Guide, Version 5,
Scotts Valley, CA: Borland International, Inc. Borwein, J.M. and Borwein, P.B. (1987) И and the AGM, New York, NY: John
Wiley.
Cormen, Т.Н., Leiserson, C.E. and Rivest, R.L. (1991) Introduction to
Algorithms, 5th Edition, Cambridge, MA: MIT Press. Mifsud, C.J. (1970) A multiple-precision division algorithm, Comm. ACM, Vol
13, Number 11 (November 1970), 666-668. Musser, D.R. and Saini, A. (1995) STL Tutorial and Reference Guide, Reading,
Mass.: Addison-Wesley. Plauger, P.J. (1995) The Standard Template Library / Серия ежемесячных ста¬тей в журнале C/C++ Users Journal, начиная с декабря 1995 года,
Boulder, СО: Miller Freeman. Sedgewick, R. (1992) Algorithms in С++, Reading, Mass.: Addison-Wesley. Stepanov, A. and Lee, M. (1994) The Standard Template Library, Palo Alto, С A:
Hewlett-Packard Company. Stroustrup, B. (1997) The С++ Programming Language, 3d Edition, Reading,
Mass.: Addison-Wesley. Имеется русский перевод: Страуструп Б. Язык
программирования С++, 3-е издание. - СПб.: Невский диалект;
М.: БИНОМ, 1999. Stroustrup, В. (1997) The Design and Evolution of С++, 2nd Edition, Reading,
Mass.: Addison-Wesley.
 
Указатель идентификаторов и английских названий
 
А
accumulate 52, 206 adjacentdifference 206 adjacent_find 158 advance 40 algo.h 52 algorithm 25 arctan 230 auto_ptr 49
В
back_inserter 151 BC5 17, 75 bcc32 17 begin 25
binary_function 141, 145 binary_search 188, 189 bindlst 143 bind2nd 58, 143 bool 12
Borland С++ 17 bstring.h 75

С
capacity 86 const 152
const_iterator 24, 82, 152 const_reference 82 const_reverse_iterator 82, 152 copy 30, 151, 164 copybarkward 165 count 55 count_if 56, 143 cstring.h 75
D
delete 49 deque 20
difference_type 82, 83 distance 40 divides 58, 149
E
end 25 equal 161
equal_range 188, 189 equal_to 58, 149 erase 22, 24, 46, 74
F
fill 173 fill_n 173 find 29 find_end 157 find_first_of 157 find_if 45 first 65 flip 83 for_each 54 front_inserter 151 functional 66
G
generate 174 get 49
greater 58, 149 greaterequal 58, 149
H
Hewlett-Packard 18 HP STL 18 includes 192 inner_product 203, 206 inplacemerge 191 insert 22, 73 inserter 32, 151 istream_iterator 154 iterator 82


less 58, 141, 149 less_equal 58, 149 lexicographicalcompare 199 list 20, 28 logical_and 58, 149 logical_not 58 logical_or 58, 149 lower_bound 188, 189
M
makeheap 196 max 198
max_element 199 merge 32, 100, 190 min 198
min_element 199 minus 58, 149 mismatch 160 modulus 58, 149 multiplies 53, 149
N
negate 58 new 49
next_permutation 201 not_equal_to 58, 149 not2 144 nth_element 186 NULL 16 numeric 52, 202
О
operator() 43 ostream iterator 153
pair 65
partial_sort 185 partial_sort_copy 185 partial_sum 204 partition 180 plus 58
pop 131, 134, 135 pop_back 22 pop_front 22, 92 pop_heap 196 prev_permutation 201 priority_queue 135 push 131, 134, 135 push_back 14, 22 push_front 22, 92 push_heap 196

Q
queue 134 R
random_shuffle 179 rbegin 16 reference 82 remove 46, 172 removeif 48, 172 rend 16 replace 41, 170 replace_copy_if 171 replace_if 170 reserve 87 reverse 41, 99, 178 reverseiterator 16, 82 rotate 167 rotate_copy 167


search 162 second 65 set_difference 192 set_intersection 192 set_symmetric_difference 192 set_union 192 size 85, 131 size_type 82 sort 25, 42, 95 sort_heap 196 splice 96
stable_partition 181 stable_sort 184 stack 131 string 75 strstr 162 swap 83, 168 swapranges 169
T
tick 233 times 53 top 131, 135 transform 149
и
unary_function 141, 147 unique 95, 176 unique_copy 178 upper_bound 188, 189 using namespace std 17 utility 65
value_type 64, 81, 82 V
VC5 17, 75 vector 14
 





Предметный указатель
 

адаптер 58
адаптер итератора 31, 151 адаптер функции 143 ассоциативный контейнер 59, 62
д
двумерный массив 101 двунаправленный итератор 36 двусвязный список 95 двусторонняя очередь 20, 27, 92 диапазон 15
 

 
бинарный предикат 140 булевский вектор 83
В
ввод-вывод (с помощью сору) 38 вектор 14
вектор указателей 102 виртуальная память 16 входной итератор 36 выходной итератор 36

заголовки STL 19 заголовок 17 значения итераторов 87
И
инициализация 28 исключение 16 итератор вставки 31, 151 итератор произвольного доступа 36
К
категории итераторов 35 ключ 59 контейнер 59
Л
лексикографический порядок 66 линейное время 22 линия регрессии 207
м
матрица 101
метод наименьших квадратов 206 множество 59
множество с дубликатами 59, 61 О
обобщенный алгоритм 25, 155 обратный итератор 152 объединение 32, 100, 190 оператор вызова 43 освобождение памяти 103 отрицатель 58, 144 очередь 134
очередь с приоритетами 135, 195 ошибка выделения памяти 16
п
пара 65
переносимость 17, 60, 214 перераспределение памяти 87 перестановка 201 пирамида 195 поиск 162
последовательные контейнеры 81 постоянное время 22 потоковые итераторы 38, 153 предикат 43, 57 привязка 58, 143 пространство имен 11, 17
простые числа 83 прямой итератор 36


режим вставки 31 режим замещения 31 решето Эратосфена 83


сбалансированное дерево 59 скалярное произведение 203 словарь 59
словарь с дубликатами 60, 64 сопутствующие данные 67 сортировка 24, 42, 182 список 20, 23 стабильность 46, 48, 184 стандарт С++ (проект) 13 стандартные заголовки 19 станд. функциональные объекты 58 стек 131
У
унарный предикат 142 утечка памяти 103
Ф
файл заголовка 9 функциональный класс 139 функцион. объект 43, 57, 138, 147


число К 211, 229
ш
шаблон функции 9 шаблонная функция 8 шаблонный класс 10
э
элемент, следующий за последним 26
 

